<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DPC&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/bfa2adcbfd5883f9905426b1399816ee</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dpcfury.github.io/"/>
  <updated>2020-04-03T07:35:17.799Z</updated>
  <id>https://dpcfury.github.io/</id>
  
  <author>
    <name>杜鹏程</name>
    <email>dpcspark@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内存泄漏和内存溢出</title>
    <link href="https://dpcfury.github.io/memory-leak-and-memory-overflow.html/"/>
    <id>https://dpcfury.github.io/memory-leak-and-memory-overflow.html/</id>
    <published>2020-04-03T06:35:50.000Z</published>
    <updated>2020-04-03T07:35:17.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>内存泄漏（Memory Leak）</strong>指的是申请了内存，但是在后续不用的时候没有进行释放，对程序而言这块内存一直处于占用状态。<br><strong>内存溢出（Memory Overflow）</strong>：指的是申请内存时，已经没有足够的内容可供使用；或者，给定一块内存，你却操作这块内存意外的地址空间，这时候就会OOM，即所谓的内存溢出。</p></blockquote><a id="more"></a><h4 id="二者关系"><a href="#二者关系" class="headerlink" title="二者关系"></a>二者关系</h4><p>内存泄漏的堆积最终必然会导致内存溢出，内存溢出就是需要的空间超过了系统所能分配给你的最大空间，此时系统无法满足分配器请求，就会报内存溢出的错误。<br>内存泄漏更倾向于是说，你申请了空间，但是没有在不使用的情况下释放，导致系统无法将这些空间分配给其他程序，也无法被gc进行回收。</p><h4 id="内存泄漏分类"><a href="#内存泄漏分类" class="headerlink" title="内存泄漏分类"></a>内存泄漏分类</h4><ol><li><p><strong>常发性内存泄漏</strong>：造成内存泄漏的代码经常被执行到，每次执行程序都会造成对应代码段的内存泄漏。</p></li><li><p><strong>偶发性内存泄漏</strong>：造成内存泄漏的代码段很少被执行到，只有在特定的环境和条件下执行某种操作才会发生。常发性和偶发性是相对的。在特定条件下，偶发的泄漏可能演化常发性的内存泄漏，所以需要考虑泄漏发生的条件和环境。</p></li><li><p><strong>一次性内存泄漏</strong>：在整个应用程序的生命周期中，造成内存泄漏的代码段只会执行一次，可能是由于算法、程序设计、加载机制上的缺陷，导致总会发生一次内存泄漏。例如在加载阶段的初始化分配内存，但是后续类一直需要使用，因此不使用的内存一直没有被释放。</p></li><li><p><strong>隐式内存泄漏</strong>：程序在执行过程中（例如处理web用户的一次查询请求），由于程序设计问题，不停的在请求分配内存，但是直到请求处理完成才能释放内存。严格来说，这里并不能成为内存泄漏，因为程序如果能吹完成请求会释放所申请的内存。但是对于程序而言，不断申请大量的内内存，并且不及时释放（相对及时），最终还是会导致系统的内存耗尽。因此，把这种泄漏行为成为隐式内存泄漏。</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>内存泄漏多处于程序设计原因，产生内存泄漏不一定会导致系统问题，但是内存泄漏的情况频繁、泄漏的内存较大，就会导致程序内存溢出，严重的会导致机器hang住，只能重启。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;内存泄漏（Memory Leak）&lt;/strong&gt;指的是申请了内存，但是在后续不用的时候没有进行释放，对程序而言这块内存一直处于占用状态。&lt;br&gt;&lt;strong&gt;内存溢出（Memory Overflow）&lt;/strong&gt;：指的是申请内存时，已经没有足够的内容可供使用；或者，给定一块内存，你却操作这块内存意外的地址空间，这时候就会OOM，即所谓的内存溢出。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发" scheme="https://dpcfury.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="内存泄漏" scheme="https://dpcfury.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="内存溢出" scheme="https://dpcfury.github.io/tags/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Mac下安装Mysql-Python</title>
    <link href="https://dpcfury.github.io/mac-mysql-python-installation.html/"/>
    <id>https://dpcfury.github.io/mac-mysql-python-installation.html/</id>
    <published>2020-04-03T03:00:34.000Z</published>
    <updated>2020-04-03T06:35:25.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>历史原因，接受项目的运行和调试基本放在开发测试机上，买了Pycharm之后，希望能借助本地的调试功能避免在开机上测试的时间成本，但是在本地安装依赖的过程中，发现着实遇到不少的坑，这次先说说安装的Mysql-python这个库。</p></blockquote><a id="more"></a><h4 id="Mysql-python"><a href="#Mysql-python" class="headerlink" title="Mysql-python"></a>Mysql-python</h4><p>MySQL-python又叫MySQLdb，是Python连接MySQL最流行的一个驱动，很多框架都也是基于此库进行开发，遗憾的是它只支持 Python2.x，而且安装的时候有很多前置条件，因为它是基于C开发的库，这意味着，你在不同的开发测试环境，可能需要安装额外的上游依赖。</p><p>系统环境：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -V</span><br><span class="line">$ Python 2.7.10</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sw_vers</span><br><span class="line">ProductName:  Mac OS X</span><br><span class="line">ProductVersion: 10.14.6</span><br><span class="line">BuildVersion:   18G103</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>首先使用Pycharm安装失败，然后转为手动到命令行安装，可以报错信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dupengcheng@dpc-MacBook ~ pip install MySQL-python</span><br><span class="line">DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won<span class="string">'t be maintained after that date. A future version of pip will drop support for Python 2.7.</span></span><br><span class="line"><span class="string">Collecting MySQL-python</span></span><br><span class="line"><span class="string">  Downloading https://files.pythonhosted.org/packages/a5/e9/51b544da85a36a68debe7a7091f068d802fc515a3a202652828c73453cad/MySQL-python-1.2.5.zip (108kB)</span></span><br><span class="line"><span class="string">    100% |████████████████████████████████| 112kB 3.1kB/s</span></span><br><span class="line"><span class="string">    Complete output from command python setup.py egg_info:</span></span><br><span class="line"><span class="string">    sh: mysql_config: command not found</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      File "&lt;string&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">      File "/private/var/folders/8h/kmnz1jj95s9g674q6vd1bmv40000gp/T/pip-install-DNT2Pa/MySQL-python/setup.py", line 17, in &lt;module&gt;</span></span><br><span class="line"><span class="string">        metadata, options = get_config()</span></span><br><span class="line"><span class="string">      File "setup_posix.py", line 43, in get_config</span></span><br><span class="line"><span class="string">        libs = mysql_config("libs_r")</span></span><br><span class="line"><span class="string">      File "setup_posix.py", line 25, in mysql_config</span></span><br><span class="line"><span class="string">        raise EnvironmentError("%s not found" % (mysql_config.path,))</span></span><br><span class="line"><span class="string">    EnvironmentError: mysql_config not found</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ----------------------------------------</span></span><br></pre></td></tr></table></figure></p><p>和Java中不同，python的mysql连接驱动依赖了部分c库实现，推测这里的mysql_config也是某个c库提供，于是goole一波，mysql_config 在 Mac 下是由 mysql-connector-c 提供的。</p><blockquote><p>diss 一波，联动的依赖管理和坑，给开发和后续维护埋了多少坑，2.7语言即将不支持，Mysql-Python也过于老旧，这种后续在客户侧升级演进隐藏的成本极高。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install mysql <span class="comment"># 非本地数据库可以不安装</span></span><br><span class="line">$ brew install mysql-connector-c</span><br></pre></td></tr></table></figure><p>安装mysql-connector-c之后，重新pip install<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won<span class="string">'t be maintained after that date. A future version of pip will drop support for Python 2.7.</span></span><br><span class="line"><span class="string">Collecting MySQL-python</span></span><br><span class="line"><span class="string">  Using cached https://files.pythonhosted.org/packages/a5/e9/51b544da85a36a68debe7a7091f068d802fc515a3a202652828c73453cad/MySQL-python-1.2.5.zip</span></span><br><span class="line"><span class="string">    Complete output from command python setup.py egg_info:</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      File "&lt;string&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">      File "/private/var/folders/8h/kmnz1jj95s9g674q6vd1bmv40000gp/T/pip-install-bQBOWl/MySQL-python/setup.py", line 17, in &lt;module&gt;</span></span><br><span class="line"><span class="string">        metadata, options = get_config()</span></span><br><span class="line"><span class="string">      File "setup_posix.py", line 53, in get_config</span></span><br><span class="line"><span class="string">        libraries = [ dequote(i[2:]) for i in libs if i.startswith(compiler_flag("l")) ]</span></span><br><span class="line"><span class="string">      File "setup_posix.py", line 8, in dequote</span></span><br><span class="line"><span class="string">        if s[0] in "\"'</span><span class="string">" and s[0] == s[-1]:</span></span><br><span class="line"><span class="string">    IndexError: string index out of range</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ----------------------------------------</span></span><br></pre></td></tr></table></figure></p><p>修改/usr/local/Cellar/mysql-connector-c/6.1.11/bin/mysql_config<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create options</span></span><br><span class="line">113 libs=<span class="string">"-L<span class="variable">$pkglibdir</span>"</span></span><br><span class="line">114 <span class="comment"># libs="$libs -l "</span></span><br><span class="line">115 libs=<span class="string">"<span class="variable">$libs</span> -lmysqlclient -lssl -lcrypto"</span></span><br></pre></td></tr></table></figure></p><p>再次pip isstall 一次，又出了新问题，提示库缺少，命名已经安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">13 warnings generated.</span><br><span class="line">    cc -bundle -undefined dynamic_lookup -Wl,-F. build/temp.macosx-10.14-intel-2.7/_mysql.o -L/usr/<span class="built_in">local</span>/Cellar/mysql-connector-c/6.1.11/lib -lmysqlclient -lssl -lcrypto -o build/lib.macosx-10.14-intel-2.7/_mysql.so</span><br><span class="line">    ld: library not found <span class="keyword">for</span> -lssl</span><br><span class="line">    clang: error: linker <span class="built_in">command</span> failed with <span class="built_in">exit</span> code 1 (use -v to see invocation)</span><br><span class="line">    error: <span class="built_in">command</span> <span class="string">'cc'</span> failed with <span class="built_in">exit</span> status 1</span><br></pre></td></tr></table></figure></p><p>没法了，继续google解决方案，尝试添加连接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LDFLAGS=<span class="string">"-I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib"</span></span><br></pre></td></tr></table></figure></p><p>再次安装，发现权限问题,加上sudo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo env LDFLAGS=<span class="string">"-I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib"</span> pip install Mysql-python</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collecting Mysql-python</span><br><span class="line">  Downloading https://files.pythonhosted.org/packages/a5/e9/51b544da85a36a68debe7a7091f068d802fc515a3a202652828c73453cad/MySQL-python-1.2.5.zip (108kB)</span><br><span class="line">    100% |████████████████████████████████| 112kB 5.3kB/s</span><br><span class="line">Installing collected packages: Mysql-python</span><br><span class="line">  Running setup.py install <span class="keyword">for</span> Mysql-python ... <span class="keyword">done</span></span><br><span class="line">Successfully installed Mysql-python-1.2.5</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>python在平台无关性上确实不如Java，环境的依赖管理尽管有pip这样的工具，但是实际的对操作系统依赖还是无法避免，在做代码移植上确实会存在问题。此外，遇到这种老版本依赖的升级，相比也会遇到更多的坑，这个在技术规划阶段就需要考虑，用的时候一时爽，后面维护火葬场。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;历史原因，接受项目的运行和调试基本放在开发测试机上，买了Pycharm之后，希望能借助本地的调试功能避免在开机上测试的时间成本，但是在本地安装依赖的过程中，发现着实遇到不少的坑，这次先说说安装的Mysql-python这个库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="django" scheme="https://dpcfury.github.io/categories/django/"/>
    
    
      <category term="开发" scheme="https://dpcfury.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="django" scheme="https://dpcfury.github.io/tags/django/"/>
    
      <category term="python" scheme="https://dpcfury.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[289] Game of Life</title>
    <link href="https://dpcfury.github.io/leetcode-game-of-life.html/"/>
    <id>https://dpcfury.github.io/leetcode-game-of-life.html/</id>
    <published>2020-04-02T14:44:34.000Z</published>
    <updated>2020-04-02T15:45:29.786Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener">Leetcode 289. Game of Life</a><br>题目给定一个二维面板，每个格子中的细胞存活由0，1代表，给定一定的繁衍规律，希望在面板上直接更新细胞的下一次存活状态。题目特别强调的是in-place修改，以及边界控制。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由于不能使用额外的存储空间标记细胞的上一轮状态，所以想到了，有没有社么办法，先在遍历过程中，将值做一个转换，在计算每个细胞的下一个状态时，同时还能保持记录上一轮状态。此时，题目的重点就是：如何提供一种编码方式，将细胞的更新值和上一轮状态保留，后续再进行一次遍历，即获取最终的值。</p><p>分析值变化情况：</p><ul><li>0 -&gt; 1 利用101标记，上一轮状态为0，更新状态为1</li><li>1 -&gt; 0 利用10 标记，上一轮状态为1，更新状态为0</li><li>0 -&gt; 0 不变</li><li>1 -&gt; 1 不变</li></ul><p>再加上八个方向的边界控制，题目的解法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> row = board.length;</span><br><span class="line">       <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">               <span class="keyword">int</span> numOfOne = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">int</span> numOfZero = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                   <span class="keyword">int</span> curX = i + dir[<span class="number">0</span>];</span><br><span class="line">                   <span class="keyword">int</span> curY = j + dir[<span class="number">1</span>];</span><br><span class="line">                   <span class="keyword">if</span> (inArea(curX, curY, row, col)) &#123;</span><br><span class="line">                       <span class="keyword">int</span> value = board[curX][curY];</span><br><span class="line">                       <span class="keyword">if</span> (value == <span class="number">1</span> || value == <span class="number">10</span>) numOfOne++;</span><br><span class="line">                       <span class="keyword">else</span> numOfZero++;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (board[i][j] == <span class="number">0</span> &amp;&amp; numOfOne == <span class="number">3</span>) board[i][j] = <span class="number">101</span>; <span class="comment">// 0-&gt;1</span></span><br><span class="line">               <span class="keyword">if</span> (board[i][j] == <span class="number">1</span> &amp;&amp; (numOfOne &lt; <span class="number">2</span> || numOfOne &gt; <span class="number">3</span>)) board[i][j] = <span class="number">10</span>; <span class="comment">// 1-&gt;0</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">               <span class="keyword">int</span> value = board[i][j];</span><br><span class="line">               <span class="keyword">if</span> (value == <span class="number">101</span>) board[i][j] = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span> (value == <span class="number">10</span>) board[i][j] = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= row) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (y &lt; <span class="number">0</span> || y &gt;= col) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/game-of-life/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 289. Game of Life&lt;/a&gt;&lt;br&gt;题目给定一个二维面板，每个格子中的细胞存活由0，1代表，给定一定的繁衍规律，希望在面板上直接更新细胞的下一次存活状态。题目特别强调的是in-place修改，以及边界控制。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="bit" scheme="https://dpcfury.github.io/tags/bit/"/>
    
  </entry>
  
  <entry>
    <title>django 启动 libmysqlclient_r.so.16找不到</title>
    <link href="https://dpcfury.github.io/django-libmysqlclient-error.html/"/>
    <id>https://dpcfury.github.io/django-libmysqlclient-error.html/</id>
    <published>2020-04-02T05:51:29.000Z</published>
    <updated>2020-04-02T06:03:29.870Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>问题：开发环境由于yum安装的mysql版本太低，卸载后从mysql官网下载rpm进行安装，正常设置mysql之后，在启动Django时，提示libmysqlclient_r.so.16找不到。</p></blockquote><a id="more"></a><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module: libmysqlclient_r.so.16: cannot open shared object file: No such file or directory.</p></blockquote><p>在网上找了不少回答，发现都是扯的很，最后发现的问题是，在通过rpm方式安装mysql时，使用的是mysql-rpm-bundle的版本，当时只安装了mysql-client和mysql-server。</p><p>完整的安装包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- -rw-r--r--  1 root root  285470720 Mar 31 19:53 MySQL-5.6.46-1.el6.x86_64.rpm-bundle.tar</span><br><span class="line">- -rw-r--r--  1 7155 31415  35528000 Sep 29  2019 MySQL-client-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415   6191888 Sep 29  2019 MySQL-devel-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415  98136984 Sep 29  2019 MySQL-embedded-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415  80628348 Sep 29  2019 MySQL-server-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415   3722376 Sep 29  2019 MySQL-shared-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415   3969752 Sep 29  2019 MySQL-shared-compat-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415  57279436 Sep 29  2019 MySQL-test-5.6.46-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>缺少libmysqlclient_r.so.16是因为MySQL-shared-compat-5.6.46-1.el6.x86_64.rpm没有安装，直接安装即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh MySQL-shared-compat-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">warning: MySQL-shared-compat-5.6.46-1.el6.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing...                <span class="comment">########################################### [100%]</span></span><br><span class="line">   1:MySQL-shared-compat    <span class="comment">########################################### [100%]</span></span><br><span class="line"></span><br><span class="line">[root@dpctest upload]<span class="comment"># find / -name libmysqlclient_r.so.16</span></span><br><span class="line">/usr/lib64/libmysqlclient_r.so.16</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;问题：开发环境由于yum安装的mysql版本太低，卸载后从mysql官网下载rpm进行安装，正常设置mysql之后，在启动Django时，提示libmysqlclient_r.so.16找不到。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="django" scheme="https://dpcfury.github.io/categories/django/"/>
    
    
      <category term="开发" scheme="https://dpcfury.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="django" scheme="https://dpcfury.github.io/tags/django/"/>
    
      <category term="mysql" scheme="https://dpcfury.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1111] Maximum Nesting Depth of Two Valid Parentheses Strings</title>
    <link href="https://dpcfury.github.io/Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings.html/"/>
    <id>https://dpcfury.github.io/Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings.html/</id>
    <published>2020-04-01T15:18:21.000Z</published>
    <updated>2020-04-01T15:59:09.464Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/" target="_blank" rel="noopener">Leetcode 1111. Maximum Nesting Depth of Two Valid Parentheses Strings</a><br>题目的描述很长，但是表达的意思我理解就是，怎么均分一下A B两个子括号，这边借用的是交替均分‘（’的方法，这题有点偏trick，👎的比例相对较高，不做过多细节描述。</p></blockquote><a id="more"></a><h4 id="方法一：用栈进行括号匹配"><a href="#方法一：用栈进行括号匹配" class="headerlink" title="方法一：用栈进行括号匹配"></a>方法一：用栈进行括号匹配</h4><p>思路及算法</p><p>要求划分出使得最大嵌套深度最小的分组，我们首先得知道如何计算嵌套深度。我们可以通过栈实现括号匹配来计算：</p><p>维护一个栈 s，从左至右遍历括号字符串中的每一个字符：</p><ul><li><p>如果当前字符是 (，就把 ( 压入栈中，此时这个 ( 的嵌套深度为栈的高度；</p></li><li><p>如果当前字符是 )，此时这个 ) 的嵌套深度为栈的高度，随后再从栈中弹出一个 (。</p></li></ul><p>下面给出了括号序列 (()(())()) 在每一个字符处的嵌套深度：</p><blockquote><p>括号序列   ( ( ) ( ( ) ) ( ) )<br>下标编号   0 1 2 3 4 5 6 7 8 9<br>嵌套深度   1 2 2 2 3 3 2 2 2 1 </p></blockquote><p>知道如何计算嵌套深度，问题就很简单了：只要在遍历过程中，我们保证栈内一半的括号属于序列 A，一半的括号属于序列 B，那么就能保证拆分后最大的嵌套深度最小，是当前最大嵌套深度的一半。要实现这样的对半分配，我们只需要把奇数层的 ( 分配给 A，偶数层的 ( 分配给 B 即可。对于上面的例子，我们将嵌套深度为 1 和 3 的所有括号 (()) 分配给 A，嵌套深度为 2 的所有括号 ()()() 分配给 B。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxDepthAfterSplit(String seq) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[seq.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, depth = <span class="number">0</span>; i &lt; seq.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                res[i] = depth++ &amp; <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = --depth &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：找规律"><a href="#方法二：找规律" class="headerlink" title="方法二：找规律"></a>方法二：找规律</h4><p>思路及算法</p><p>我们还是使用上面的例子 (()(())())，但这里我们把 ( 和 ) 的嵌套深度分成两行：</p><blockquote><p>括号序列   ( ( ) ( ( ) ) ( ) )<br>下标编号   0 1 2 3 4 5 6 7 8 9<br>嵌套深度   1 2 - 2 3 - - 2 - -<br>嵌套深度   - - 2 - - 3 2 - 2 1<br>有没有发现什么规律？</p></blockquote><ul><li><p>左括号 ( 的下标编号与嵌套深度的奇偶性相反，也就是说：</p><ul><li><p>下标编号为奇数的 (，其嵌套深度为偶数，分配给 B；</p></li><li><p>下标编号为偶数的 (，其嵌套深度为奇数，分配给 A。</p></li><li><p>右括号 ) 的下标编号与嵌套深度的奇偶性相同，也就是说：</p></li></ul></li><li><p>下标编号为奇数的 )，其嵌套深度为奇数，分配给 A；</p><ul><li><p>下标编号为偶数的 )，其嵌套深度为偶数，分配给 B。</p></li><li><p>这样以来，我们只需要根据每个位置是哪一种括号以及该位置的下标编号，就能确定将对应的对应的括号分到哪个组了。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1111. Maximum Nesting Depth of Two Valid Parentheses Strings&lt;/a&gt;&lt;br&gt;题目的描述很长，但是表达的意思我理解就是，怎么均分一下A B两个子括号，这边借用的是交替均分‘（’的方法，这题有点偏trick，👎的比例相对较高，不做过多细节描述。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="trick" scheme="https://dpcfury.github.io/tags/trick/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[322] Coin Change</title>
    <link href="https://dpcfury.github.io/leetcode-coin-change.html/"/>
    <id>https://dpcfury.github.io/leetcode-coin-change.html/</id>
    <published>2020-04-01T15:06:32.000Z</published>
    <updated>2020-04-01T15:16:22.315Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">Leetcode 322. Coin Change</a><br>经典的找零问题，遇到此类问题，首先分析是否可以缩小amount的规模，来找到子问题（最优子结构），然后自顶向下分析，推导出递归表达式，再写出对应的自顶向下或者自底向上代码。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>令F(amount) 为拼凑amount需要的最少硬币数量，那么F(amount) = min(F(amout-coin[i]))中来的，得到这样的一个递归后，就可将问题一步步拆解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i &amp;&amp; dp[i - coins[j]] != -<span class="number">1</span>)<span class="comment">//之前能满足</span></span><br><span class="line">                    min = Math.min(dp[i - coins[j]] + <span class="number">1</span>, min);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = min == Integer.MAX_VALUE ? -<span class="number">1</span> : min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/coin-change/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 322. Coin Change&lt;/a&gt;&lt;br&gt;经典的找零问题，遇到此类问题，首先分析是否可以缩小amount的规模，来找到子问题（最优子结构），然后自顶向下分析，推导出递归表达式，再写出对应的自顶向下或者自底向上代码。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot统一异常处理实践</title>
    <link href="https://dpcfury.github.io/spring-boot-exception-handling.html/"/>
    <id>https://dpcfury.github.io/spring-boot-exception-handling.html/</id>
    <published>2020-04-01T11:14:57.000Z</published>
    <updated>2020-04-01T12:09:55.870Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在web开发中，经常需要处理各类异常情况，这种处理逻辑经常会被分散在代码的各个层次，导致异常的处理和业务逻辑混杂，后续重构代价升高，前后端交互成本提高，不利用系统的持续演进。本文针对工作中遇到的不良实践进行总结，试图找寻一种可以解决大部分问题的工程实践方案。</p></blockquote><a id="more"></a><h4 id="核心关注点"><a href="#核心关注点" class="headerlink" title="核心关注点"></a>核心关注点</h4><p>对异常的处理，总结先来，主要有三个核心的关注点：</p><ul><li>在什么时候，什么地方捕获异常（try-catch），什么时候需要抛出（throws）异常</li><li>在DAO、Service还是在Controller层次进行捕获</li><li>抛出一场后，如何处理，如何向前端返回错误</li></ul><h4 id="工作中遇到的反例"><a href="#工作中遇到的反例" class="headerlink" title="工作中遇到的反例"></a>工作中遇到的反例</h4><p>以个人在工作中接触的一个django项目为例，其业务逻辑都集中在view.py文件中，通过装饰器，将返回内容统一转换为json形式进行返回，系统在异常处理存在的问题集中体现在：</p><ul><li>分散在业务各处的返回信息处理</li><li>满大街的try-catch，可能一层套一层</li><li>混乱的返回方式</li></ul><p>后端和前端约定返回结果形式：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message"</span>:<span class="string">"ok"</span>,</span><br><span class="line">    <span class="attr">"data"</span>:[],</span><br><span class="line">    <span class="attr">"success"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>分散的返回处理</strong><br>即返回结果的处理没有统一的入口，可能分散在代码的多个层次中，导致返回信息的组织和业务逻辑交织在一起，代码逻辑非常不清晰，其次，会导致返回信息不对的情况下，排查人力投入明显增加。经常看到返回的结果message对应的从约定的”ok”变成了其他的词，”success”也出现五花八门的返回结果。</p><p><strong>满大街的try-catch</strong><br>在代码的不同层次，你都能找到活多或少的try-cath处理段，过多的try-catch 导致业务代码分割严重，也增加了对应处理逻辑，导致系统的复杂度上升，后续维护重构举步维艰。</p><p><strong>混乱的返回方式</strong><br>在spring-mvc中，返回统一在controller层次，第一层的函数就负责了结果的返回，但是接触到的django项目，它的返回逻辑甚至能在入口跳转6次的函数中，没有统一的处理入口，出了问题需要到处排查，前后端要一起折腾。</p><p><strong>总结</strong><br>当前项目的异常处理方式非常失败，处于xx原因，就不好列举代码了。</p><h4 id="异常处理规范"><a href="#异常处理规范" class="headerlink" title="异常处理规范"></a>异常处理规范</h4><p>为了进行统一的异常处理，一般会约定异常处理规范，这里不仅仅是将结果形式定义了就完事了，还得通过前后端各种工程实践将这个规范践行下去。</p><h4 id="原则一：-不捕获任何异常"><a href="#原则一：-不捕获任何异常" class="headerlink" title="原则一： 不捕获任何异常"></a>原则一： 不捕获任何异常</h4><p>根据大佬们的实践经验，不再对与业务逻辑和数据处理中的异常进行捕获，即将DAO、Service、Controller中所有的异常全部抛出到上层，从而不眠代码中一堆的try-catch，减少维护的难度。</p><h4 id="原则二：统一返回结果集"><a href="#原则二：统一返回结果集" class="headerlink" title="原则二：统一返回结果集"></a>原则二：统一返回结果集</h4><p>这个原则很多开发实践都已经明确，就是按照统一的一个格式进行结果返回，返回结果中应该起码包含请求的处理状态标志，此外用一层数组包装查询的结果。</p><p>而在spring-boot(mvc)架构中，通常会定义一个Java的DTO对象，用来进行统一的结果返回，for example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code; <span class="comment">// 统一协商的状态码</span></span><br><span class="line">    <span class="keyword">private</span> String message; <span class="comment">// 携带的额外提示信息</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;T&gt; data; <span class="comment">// 请求返回的数据集</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ResultBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultBean <span class="title">error</span><span class="params">(<span class="keyword">int</span> code, String message)</span> </span>&#123;</span><br><span class="line">        ResultBean resultBean = <span class="keyword">new</span> ResultBean();</span><br><span class="line">        resultBean.setCode(code);</span><br><span class="line">        resultBean.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> resultBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultBean <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ResultBean resultBean = <span class="keyword">new</span> ResultBean();</span><br><span class="line">        resultBean.setCode(<span class="number">0</span>);</span><br><span class="line">        resultBean.setMessage(<span class="string">"success"</span>);</span><br><span class="line">        <span class="keyword">return</span> resultBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function">ResultBean&lt;V&gt; <span class="title">success</span><span class="params">(Collection&lt;V&gt; data)</span> </span>&#123;</span><br><span class="line">        ResultBean resultBean = <span class="keyword">new</span> ResultBean();</span><br><span class="line">        resultBean.setCode(<span class="number">0</span>);</span><br><span class="line">        resultBean.setMessage(<span class="string">"success"</span>);</span><br><span class="line">        resultBean.setData(data);</span><br><span class="line">        <span class="keyword">return</span> resultBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter / setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而，在成功的情况下，只需要返回ResultBean.success() 或 ResultBean.success(Collection<v> data)需要返回数据按照下面的形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/host/add"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultBean&lt;Goods&gt; <span class="title">getAllHosts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Host&gt; hosts = hostService.findAll();</span><br><span class="line">    <span class="keyword">return</span> ResultBean.success(hosts);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/host/update"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultBean <span class="title">updatehosts</span><span class="params">(Host hosts)</span> </span>&#123;</span><br><span class="line">    hostsService.update(host);</span><br><span class="line">    <span class="keyword">return</span> ResultBean.success();</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></v></p><p>只有查询方法需要调用 ResultBean.success(Collection<v> data) 来返回 N 条数据, 删除, 修改等方法都应该调用 ResultBean.success(), 即在业务代码中只处理正确的功能, 不对异常做任何判断. 也不需要对 update 或 delete 的更新条数做判断. 只要没有抛出异常, 就等价于用户请求处理成功，再加足够的日志即可，且操作成功的提示信息在前端处理, 不要后台返回 “操作成功” 等字段，这种设计在国际化的时候能减轻不少的工作量。</v></p><p>前台接受的json for example：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"success"</span>,</span><br><span class="line">    <span class="string">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"sn"</span>: <span class="string">"xxxx"</span>,</span><br><span class="line">            <span class="string">"hostname"</span>: <span class="string">"xxxxx"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"sn"</span>: <span class="string">"xxxx"</span>,</span><br><span class="line">            <span class="string">"hostname"</span>: <span class="string">"xxxx"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在后端报错情况下，在后端统一调用ResultBean.error(int code, String message), 来将状态码和错误信息返回, 我们约定 code 为 0 表示操作成功, 1 标示系统错误， 2标示 参数错误（协商解决）</li></ul><p>前台收到错误结果后，只要根据对应的错误code进行相应的提示信息弹出即可。</p><h4 id="后端统一异常处理"><a href="#后端统一异常处理" class="headerlink" title="后端统一异常处理"></a>后端统一异常处理</h4><p>这里是最重点的地方，spring-boot（mvc）开发的web应用中，如何进行统一的异常处理呢，spring利用AOP，提供了一种@Advice的处理方式，我们所有的异常只要能保证抛出到controller层次， 就能由统一的Advice进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(RequestExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultBean <span class="title">unknownSn</span><span class="params">(UnknownSntException e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"机器sn不存在"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(<span class="number">1</span>, <span class="string">"sn不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultBean <span class="title">incorrectMac</span><span class="params">(IncorrectMacException e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"mac地址不对"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(-<span class="number">2</span>, <span class="string">"mac地址错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultBean <span class="title">unknownException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"内部错误"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(-<span class="number">99</span>, <span class="string">"系统出现错误，联系管理员处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>不要满大街的try-catch</li><li>统一返回值，集中异常的处理逻辑</li><li>认真对待写的代码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在web开发中，经常需要处理各类异常情况，这种处理逻辑经常会被分散在代码的各个层次，导致异常的处理和业务逻辑混杂，后续重构代价升高，前后端交互成本提高，不利用系统的持续演进。本文针对工作中遇到的不良实践进行总结，试图找寻一种可以解决大部分问题的工程实践方案。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发" scheme="https://dpcfury.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
      <category term="spring-boot" scheme="https://dpcfury.github.io/categories/%E5%BC%80%E5%8F%91/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="https://dpcfury.github.io/tags/spring-boot/"/>
    
      <category term="工程实践" scheme="https://dpcfury.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://dpcfury.github.io/sorting.html/"/>
    <id>https://dpcfury.github.io/sorting.html/</id>
    <published>2020-03-31T14:11:02.000Z</published>
    <updated>2020-03-31T15:54:32.613Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>十大排序算法可以说是每个程序员都必须得掌握的了，为了方便个人复习和总结，把它整理成一篇独立文章，每种算法会有简单的算法思想描述，为了方便大家理解，从网上搜集了动图演示。</p></blockquote><a id="more"></a><ul><li>选择排序</li><li>插入排序</li><li>冒泡排序</li><li>非优化版本</li><li>优化版本</li><li>希尔排序</li><li>归并排序</li><li>递归式归并排序</li><li>非递归式归并排序</li><li>快速排序</li><li>堆排序</li><li>基数排序</li><li>非优化版本</li><li>优化版本</li><li>桶排序</li><li>基数排序</li></ul><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>过程简单描述：</strong> 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为选择排序。</p><p><img src="https://pic1.zhimg.com/v2-f20b8898585b3ca03843d93ce2c35a68_b.gif" alt="选择排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[min]) min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[min];</span><br><span class="line">            nums[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="https://zhuanlan.zhihu.com/p/57088609" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57088609</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;十大排序算法可以说是每个程序员都必须得掌握的了，为了方便个人复习和总结，把它整理成一篇独立文章，每种算法会有简单的算法思想描述，为了方便大家理解，从网上搜集了动图演示。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="sorting" scheme="https://dpcfury.github.io/tags/sorting/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1218] Longest Arithmetic Subsequence of Given Difference</title>
    <link href="https://dpcfury.github.io/longest-arithmetic-subsequence-of-given-difference.html/"/>
    <id>https://dpcfury.github.io/longest-arithmetic-subsequence-of-given-difference.html/</id>
    <published>2020-03-30T15:14:37.000Z</published>
    <updated>2020-03-30T15:20:26.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/" target="_blank" rel="noopener">Leetcode 1218. Longest Arithmetic Subsequence of Given Difference</a><br>题目阅读下来，看到子序列这种问题，立马就会想到动态规划，首先会去想如何缩小问题的规模。从这个差来看，对于每一个遍历的数n而言，如果能知道以 n-difference结尾的子序列长度，就能计算以n为结尾的子序列长度，由于差值不是坐标，可以用HashMap存储dp的中间值。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">       map.put(arr[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (map.containsKey(arr[i] - difference)) &#123;</span><br><span class="line">               map.put(arr[i], map.get(arr[i] - difference) + <span class="number">1</span>);</span><br><span class="line">               max = Math.max(map.get(arr[i]), max);</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               map.put(arr[i], <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1218. Longest Arithmetic Subsequence of Given Difference&lt;/a&gt;&lt;br&gt;题目阅读下来，看到子序列这种问题，立马就会想到动态规划，首先会去想如何缩小问题的规模。从这个差来看，对于每一个遍历的数n而言，如果能知道以 n-difference结尾的子序列长度，就能计算以n为结尾的子序列长度，由于差值不是坐标，可以用HashMap存储dp的中间值。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>力扣中国[62] Joseph Circle Problem</title>
    <link href="https://dpcfury.github.io/joseph-circle-problem.html/"/>
    <id>https://dpcfury.github.io/joseph-circle-problem.html/</id>
    <published>2020-03-30T13:46:19.000Z</published>
    <updated>2020-03-30T14:00:09.357Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指offer Joseph Problem</a><br>题目不用多介绍，经典的约瑟夫环问题，求解的过程主要包含两种。一种是直观的构造循环链表，通过多次多次遍历，求的最终结果，时间复杂度为O(mn),另一种就是通过数学分析，找出递归的规律，然后使用递归或者动归求解。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>令f(n-1,m) 为n-1个人，报数m，最终留下的胜者坐标，那么f(n,m)的的胜者同样是f(n-1,m)胜者，但是其下坐标遍了，那么上一轮中胜者的坐标对应应该是(f(n-1,m)+m) % n</p><p>即关系式为：f(n,m) = (f(n-1,m)+m) % n</p><p>针对0和1个数的情况，胜者坐标都为0<br>因此解法可写为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp = (dp + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>对于这个推到技巧，在知乎看到这么一个总结，感觉比较实用</p></blockquote><p>递归问题分3步走：<br>1、递归收敛：由于m是不变的，所以只能通过n将规模不断缩小<br>2、找出口：当递归收敛到最小单位时，能得到一个出口。即当n=1时，胜者的位置为0<br>3、找规律：分析已知条件，与我们需要结果的关联。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指offer Joseph Problem&lt;/a&gt;&lt;br&gt;题目不用多介绍，经典的约瑟夫环问题，求解的过程主要包含两种。一种是直观的构造循环链表，通过多次多次遍历，求的最终结果，时间复杂度为O(mn),另一种就是通过数学分析，找出递归的规律，然后使用递归或者动归求解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="Math" scheme="https://dpcfury.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1162] As Far from Land as Possible</title>
    <link href="https://dpcfury.github.io/leetcode-as-far-from-land-as-possible.html/"/>
    <id>https://dpcfury.github.io/leetcode-as-far-from-land-as-possible.html/</id>
    <published>2020-03-29T13:44:36.000Z</published>
    <updated>2020-03-29T13:49:56.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">Leetcode 1162. As Far from Land as Possible</a><br>题目的意思需要多读几次，最终的目的就是求离陆地最远的海洋距离。这类题目可以属于一道简单的bfs题目。leetcode中海洋陆地问题的题目很多，大多都是bfs或是dfs题目。这里再简单啰嗦一下bfs的思路。首先我们选取一些特征一致的点作为起始目标，然后从这些目标开始向四周扩散一步，四周的点只要在数组边界之内并且其特征与初始特征不一致，我们就将其变为与起始点同一特征（染色）。同时将这些新染色的点作为起始再向四周扩散一步，执行相同操作，直到全部同化完成。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>先找出所有陆地的坐标，作为bfs的起始条件。</li><li>通过所有的陆地坐标向外bfs。直到找到最后一块海洋为止。这期间所用到的步数即是答案，也即从某个初始点扩散到这块海洋，所需要的最长距离。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">int</span> dist;</span><br><span class="line"></span><br><span class="line">        Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dist) &#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.dist = dist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length;</span><br><span class="line">        <span class="keyword">int</span> maxDistance = -<span class="number">1</span>;</span><br><span class="line">        Queue&lt;Point&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Point(i, j, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有陆地或者全是陆地，直接返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (queue.size() == <span class="number">0</span> || queue.size() == n * n) <span class="keyword">return</span> maxDistance;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Point p = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (p.x &lt; <span class="number">0</span> || p.x &gt; grid.length - <span class="number">1</span> || p.y &lt; <span class="number">0</span> || p.y &gt; grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[p.x][p.y]) &#123;</span><br><span class="line">                visited[p.x][p.y] = <span class="keyword">true</span>;</span><br><span class="line">                maxDistance = Math.max(maxDistance, p.dist);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                    <span class="keyword">int</span> curX = p.x + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> curY = p.y + dir[<span class="number">1</span>];</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Point(curX, curY, p.dist+ <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDistance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/as-far-from-land-as-possible/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1162. As Far from Land as Possible&lt;/a&gt;&lt;br&gt;题目的意思需要多读几次，最终的目的就是求离陆地最远的海洋距离。这类题目可以属于一道简单的bfs题目。leetcode中海洋陆地问题的题目很多，大多都是bfs或是dfs题目。这里再简单啰嗦一下bfs的思路。首先我们选取一些特征一致的点作为起始目标，然后从这些目标开始向四周扩散一步，四周的点只要在数组边界之内并且其特征与初始特征不一致，我们就将其变为与起始点同一特征（染色）。同时将这些新染色的点作为起始再向四周扩散一步，执行相同操作，直到全部同化完成。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="BFS" scheme="https://dpcfury.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[423] Reconstruct Original Digits from English</title>
    <link href="https://dpcfury.github.io/reconstruct-original-digits-from-english.html/"/>
    <id>https://dpcfury.github.io/reconstruct-original-digits-from-english.html/</id>
    <published>2020-03-29T05:49:52.000Z</published>
    <updated>2020-03-29T06:08:49.856Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/reconstruct-original-digits-from-english/" target="_blank" rel="noopener">423. Reconstruct Original Digits from English</a><br>题目的意思第一遍读，以为是和编解码同类型的题目，想用回溯去尝试，后来发现给定的一个条件是input长度小于5000，那就说明可能存在重复的数字，回溯走不通。再看看discuss，发现这题主要是在找规律，即分析每个数字英文所包含的字母和其对应关系，再从input中判断特征字母的出现次数，计算每个数字的出现次数。</p></blockquote><a id="more"></a><p>如果我们用numbers数组存储出现的数字个数，其中下标表示着对应0-9的数字，那么我们会有下面这个结果：</p><table><thead><tr><th>数字</th><th>数字的个数</th></tr></thead><tbody><tr><td>0</td><td>numbers[0] = ‘z’的个数</td></tr><tr><td>2</td><td>numbers[2] = ‘w’的个数</td></tr><tr><td>4</td><td>numbers[4] = ‘u’的个数</td></tr><tr><td>6</td><td>numbers[6] = ‘x’的个数</td></tr><tr><td>8</td><td>numbers[8] = ‘g’的个数</td></tr></tbody></table><p>而其他的数字个数，比如5的个数，因为‘f’的数目由four和five的数目组成，而我们已知four的数目为numbers[4]，所以numbers[5] = ‘f’的个数-number[4]。其他的数字同样处理。<br>最后得到了下面的映射关系：</p><table><thead><tr><th>数字</th><th>数字的个数</th></tr></thead><tbody><tr><td>5</td><td>numbers[5] = ‘f’的个数 - numbers[4]</td></tr><tr><td>3</td><td>numbers[3] = ‘h’的个数 - numbers[8]</td></tr><tr><td>7</td><td>numbers[7] = ‘s’的个数 - numbers[6]</td></tr><tr><td>1</td><td>numbers[1] = ‘o’的个数 - numbers[0] - numbers[2] - numbers[4]</td></tr><tr><td>9</td><td>numbers[9] = ‘i’的个数 - numbers[5] - numbers[6] - numbers[8]</td></tr></tbody></table><p>于是乎，代码写成下面这种格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">originalDigits</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            count.put(c, count.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[<span class="number">8</span>] = count.getOrDefault(<span class="string">'g'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">6</span>] = count.getOrDefault(<span class="string">'x'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">4</span>] = count.getOrDefault(<span class="string">'u'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">2</span>] = count.getOrDefault(<span class="string">'w'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">0</span>] = count.getOrDefault(<span class="string">'z'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">5</span>] = count.getOrDefault(<span class="string">'f'</span>, <span class="number">0</span>) - nums[<span class="number">4</span>];</span><br><span class="line">        nums[<span class="number">3</span>] = count.getOrDefault(<span class="string">'h'</span>, <span class="number">0</span>) - nums[<span class="number">8</span>];</span><br><span class="line">        nums[<span class="number">7</span>] = count.getOrDefault(<span class="string">'s'</span>, <span class="number">0</span>) - nums[<span class="number">6</span>];</span><br><span class="line">        nums[<span class="number">1</span>] = count.getOrDefault(<span class="string">'o'</span>, <span class="number">0</span>) - nums[<span class="number">0</span>] - nums[<span class="number">2</span>] - nums[<span class="number">4</span>];</span><br><span class="line">        nums[<span class="number">9</span>] = count.getOrDefault(<span class="string">'i'</span>, <span class="number">0</span>) - nums[<span class="number">5</span>] - nums[<span class="number">6</span>] - nums[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                str.append((<span class="keyword">char</span>) (<span class="string">'0'</span> + i));</span><br><span class="line">                nums[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>看到discuss中有给出的拓扑排序解法，但是这题给人的感觉更倾向于找规律，因此不再讨论另外的解法。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reconstruct-original-digits-from-english/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;423. Reconstruct Original Digits from English&lt;/a&gt;&lt;br&gt;题目的意思第一遍读，以为是和编解码同类型的题目，想用回溯去尝试，后来发现给定的一个条件是input长度小于5000，那就说明可能存在重复的数字，回溯走不通。再看看discuss，发现这题主要是在找规律，即分析每个数字英文所包含的字母和其对应关系，再从input中判断特征字母的出现次数，计算每个数字的出现次数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[820] Short Encoding of Words</title>
    <link href="https://dpcfury.github.io/leetcode-short-encoding-of-words.html/"/>
    <id>https://dpcfury.github.io/leetcode-short-encoding-of-words.html/</id>
    <published>2020-03-28T12:44:24.000Z</published>
    <updated>2020-03-28T13:03:46.304Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">Leetcode 820. Short Encoding of Words</a><br>题目给出一组字符串数组，计算最短的编码字符串长度。编码的方式就是通过‘#‘号分割，再加一个索引，能够从编码字符串中解码初原始字符串。读一下题目，大致可以知道这题的意思是和后缀有关，因为如果一个单词是其他单词的后缀，它的长度肯定不会被计算入加密字符串。因此，先给字符串数组排个序，让长的字符串在前，短的在后，通过每次比较当前字符串和已构造的加密字符对比，含是否是已有字符串的后缀。</p></blockquote><a id="more"></a><h4 id="approach-1"><a href="#approach-1" class="headerlink" title="approach 1"></a>approach 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="keyword">null</span> | words.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[words.length];</span><br><span class="line">        Arrays.sort(words, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.length() - o1.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) strs[i] = words[i] + <span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = strs[i - <span class="number">1</span>].indexOf(words[i]);</span><br><span class="line">                <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123; <span class="comment">// 看能否匹配到#</span></span><br><span class="line">                    <span class="keyword">if</span> (strs[i - <span class="number">1</span>].charAt(index + words[i].length()) == <span class="string">'#'</span>) &#123;</span><br><span class="line">                        strs[i] = strs[i - <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                strs[i] = strs[i - <span class="number">1</span>] + words[i] + <span class="string">'#'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[words.length - <span class="number">1</span>].length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="approach-2"><a href="#approach-2" class="headerlink" title="approach 2"></a>approach 2</h4><blockquote><p>从leetcode 官网给的solution也可以看出来，既然本质是剔除那些本身是其他单词后缀的单词。提到后缀，其实变相的就是逆前缀，而提到前缀就会想到Trie字典树，字典树的分支就是26个字母分叉，对于不是其他单词后缀的单词，其对应在字典树中一定能从根遍历到叶子结点。因此遍历字符串数组的过程中，可以去构造逆向的前缀树，然后统计能走到叶子结点的字符串长度和即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        TrieNode trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        Map&lt;TrieNode, Integer&gt; nodes = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; ++i) &#123;</span><br><span class="line">            String word = words[i];</span><br><span class="line">            TrieNode cur = trie;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = word.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                cur = cur.get(word.charAt(j));</span><br><span class="line">            nodes.put(cur, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (TrieNode node: nodes.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.count == <span class="number">0</span>) <span class="comment">// 走到叶子结点</span></span><br><span class="line">                ans += words[nodes.get(node)].length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (children[c-<span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            children[c-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> children[c - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/short-encoding-of-words/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 820. Short Encoding of Words&lt;/a&gt;&lt;br&gt;题目给出一组字符串数组，计算最短的编码字符串长度。编码的方式就是通过‘#‘号分割，再加一个索引，能够从编码字符串中解码初原始字符串。读一下题目，大致可以知道这题的意思是和后缀有关，因为如果一个单词是其他单词的后缀，它的长度肯定不会被计算入加密字符串。因此，先给字符串数组排个序，让长的字符串在前，短的在后，通过每次比较当前字符串和已构造的加密字符对比，含是否是已有字符串的后缀。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="tries" scheme="https://dpcfury.github.io/tags/tries/"/>
    
      <category term="suffix" scheme="https://dpcfury.github.io/tags/suffix/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[914] X of a Kind in a Deck of Cards</title>
    <link href="https://dpcfury.github.io/leetcode-x-of-a-kind-in-a-deck.html/"/>
    <id>https://dpcfury.github.io/leetcode-x-of-a-kind-in-a-deck.html/</id>
    <published>2020-03-27T13:17:06.000Z</published>
    <updated>2020-03-27T13:22:16.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/" target="_blank" rel="noopener">Leetcode 914. X of a Kind in a Deck of Cards</a><br>题目的直白含义就是：给出一堆数组，判断是否有一种划分方式，让每个分组内的元素都相同，每个组的元素个数页相同。暴力的解法比较直观，但是背后的含义其实是：对于每一种的牌的数量Ni，如果能够满足按x进行分组，那么Ni % x ==0,那么对于不同种类的牌而言，是否存在x这种划分，就变成，这组牌的数量的最大公约数是否满足大于等于 2，由此变为如何求一组数的最大公约数。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : deck) count.put(i, count.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> g = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (g == -<span class="number">1</span>) &#123;</span><br><span class="line">               g = entry.getValue();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               g = gcd(g, entry.getValue());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> g &gt;= <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> y;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> gcd(y % x, x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 914. X of a Kind in a Deck of Cards&lt;/a&gt;&lt;br&gt;题目的直白含义就是：给出一堆数组，判断是否有一种划分方式，让每个分组内的元素都相同，每个组的元素个数页相同。暴力的解法比较直观，但是背后的含义其实是：对于每一种的牌的数量Ni，如果能够满足按x进行分组，那么Ni % x ==0,那么对于不同种类的牌而言，是否存在x这种划分，就变成，这组牌的数量的最大公约数是否满足大于等于 2，由此变为如何求一组数的最大公约数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="gcd" scheme="https://dpcfury.github.io/tags/gcd/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[168] Excel Sheet Column Title</title>
    <link href="https://dpcfury.github.io/leetcode-excel-sheet-column-title.html/"/>
    <id>https://dpcfury.github.io/leetcode-excel-sheet-column-title.html/</id>
    <published>2020-03-27T11:38:32.000Z</published>
    <updated>2020-03-28T15:43:15.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">Leetcode 168. Excel Sheet Column Title</a><br>题目求数字到Excel sheet编号的转换，其实本质就是进制的转换，但是需要注意的是，这边的A是代表1，z代表的是26，如果直接取余数，会发现结果查一位，这里有个技巧就是，每次将初数-1操作,可以看成逻辑上将A从0开始算。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">int</span> num = n % <span class="number">26</span>;</span><br><span class="line">            str.append((<span class="keyword">char</span>) (num + <span class="number">65</span>));</span><br><span class="line">            n = n / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/excel-sheet-column-title/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 168. Excel Sheet Column Title&lt;/a&gt;&lt;br&gt;题目求数字到Excel sheet编号的转换，其实本质就是进制的转换，但是需要注意的是，这边的A是代表1，z代表的是26，如果直接取余数，会发现结果查一位，这里有个技巧就是，每次将初数-1操作,可以看成逻辑上将A从0开始算。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[999] Available Captures for Rook</title>
    <link href="https://dpcfury.github.io/available-captures-for-root.html/"/>
    <id>https://dpcfury.github.io/available-captures-for-root.html/</id>
    <published>2020-03-26T14:37:54.000Z</published>
    <updated>2020-03-26T14:41:07.426Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/available-captures-for-rook/" target="_blank" rel="noopener">999. Available Captures for Rook</a> 题目要求8x8的棋局上，Rook上下左右移动可以补货的黑色卒数量，只要遍历上下左右位置即可。实际题目并没有什么含量，奈何把黑色卒缩写理解成‘B’,稍微折腾了一下，并给题目点了个👎。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> canCapture(board, row, col, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">canCapture</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> up = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (up &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[up][j];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                up--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; col) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[i][right];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[i][left];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> down = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (down &lt; row) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[down][j];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                down++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/available-captures-for-rook/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;999. Available Captures for Rook&lt;/a&gt; 题目要求8x8的棋局上，Rook上下左右移动可以补货的黑色卒数量，只要遍历上下左右位置即可。实际题目并没有什么含量，奈何把黑色卒缩写理解成‘B’,稍微折腾了一下，并给题目点了个👎。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[92] Reverse Linked List II</title>
    <link href="https://dpcfury.github.io/leetcode-reverse-linked-list-II.html/"/>
    <id>https://dpcfury.github.io/leetcode-reverse-linked-list-II.html/</id>
    <published>2020-03-25T13:35:07.000Z</published>
    <updated>2020-03-25T13:41:06.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">Leetcode 92. Reverse Linked List II</a><br>题目要求在一次遍历完成对链表中m-n的元素进行反转，由于是单链表，涉及到这种顺序的饭庄，首先会想到栈，将m-n的元素放入栈中，再记录m-1个元素的位置，通过出栈再重新链接，即可得到反转后的链表。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        ListNode before = newHead;</span><br><span class="line">        ListNode p = newHead;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            before = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count == m) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt;= n &amp;&amp; p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.add(p);</span><br><span class="line">            p = p.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            ListNode node = stack.pop();</span><br><span class="line">            before.next = node;</span><br><span class="line">            before = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        before.next = p;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 92. Reverse Linked List II&lt;/a&gt;&lt;br&gt;题目要求在一次遍历完成对链表中m-n的元素进行反转，由于是单链表，涉及到这种顺序的饭庄，首先会想到栈，将m-n的元素放入栈中，再记录m-1个元素的位置，通过出栈再重新链接，即可得到反转后的链表。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="linkedlist" scheme="https://dpcfury.github.io/tags/linkedlist/"/>
    
      <category term="stack" scheme="https://dpcfury.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[543] Diameter of Binary Tree</title>
    <link href="https://dpcfury.github.io/leetcode-diameter-of-binary-tree.html/"/>
    <id>https://dpcfury.github.io/leetcode-diameter-of-binary-tree.html/</id>
    <published>2020-03-25T11:55:19.000Z</published>
    <updated>2020-03-25T13:49:13.835Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. Diameter of Binary Tree</a><br>题目要求二叉树的最大直径，所谓直径就是这颗树的任意两个叶子结点连接，所能经过的最多节点数。分析这个路径的可能构成情况，可能是存在于左子树、右子树，或者存在于左右子树+根节点。所以对于当前任意节点，这颗树的最大直径，可以分为包含这个节点的路径情况：即左右子树高度+1，不包含的情况，即左子树的最大直径、或右子树的最大直径。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = getDepth(root.left) + getDepth(root.right);</span><br><span class="line">        <span class="keyword">int</span> leftMax = diameterOfBinaryTree(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightMax = diameterOfBinaryTree(root.right);</span><br><span class="line">        <span class="keyword">if</span> (leftMax &gt; max)</span><br><span class="line">            max = leftMax;</span><br><span class="line">        <span class="keyword">if</span> (rightMax &gt; max)</span><br><span class="line">            max = rightMax;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(getDepth(node.left), getDepth(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/diameter-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;543. Diameter of Binary Tree&lt;/a&gt;&lt;br&gt;题目要求二叉树的最大直径，所谓直径就是这颗树的任意两个叶子结点连接，所能经过的最多节点数。分析这个路径的可能构成情况，可能是存在于左子树、右子树，或者存在于左右子树+根节点。所以对于当前任意节点，这颗树的最大直径，可以分为包含这个节点的路径情况：即左右子树高度+1，不包含的情况，即左子树的最大直径、或右子树的最大直径。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[198] House Robber</title>
    <link href="https://dpcfury.github.io/leetcode-house-robber.html/"/>
    <id>https://dpcfury.github.io/leetcode-house-robber.html/</id>
    <published>2020-03-24T14:10:43.000Z</published>
    <updated>2020-03-24T14:16:47.064Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">198. House Robber</a><br>题目描述，给定一组序列，对其中的每一个元素，可以选择拿或者不拿，但是拿了之后，后相邻的下一个元素就不能拿，求能够拿的最大数量。属于特别典型的dp问题，推到出递归式即可。这题在国内还换了种说法，变成了<a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">按摩师</a>，内容完全一样。</p></blockquote><a id="more"></a><h4 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                max[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                max[i] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                max[i] = Math.max(max[i - <span class="number">1</span>], max[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;198. House Robber&lt;/a&gt;&lt;br&gt;题目描述，给定一组序列，对其中的每一个元素，可以选择拿或者不拿，但是拿了之后，后相邻的下一个元素就不能拿，求能够拿的最大数量。属于特别典型的dp问题，推到出递归式即可。这题在国内还换了种说法，变成了&lt;a href=&quot;https://leetcode-cn.com/problems/the-masseuse-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;按摩师&lt;/a&gt;，内容完全一样。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[876] Middle of the Linked List</title>
    <link href="https://dpcfury.github.io/leetcode-middle-of-the-linked-list.html/"/>
    <id>https://dpcfury.github.io/leetcode-middle-of-the-linked-list.html/</id>
    <published>2020-03-23T14:35:01.000Z</published>
    <updated>2020-03-23T14:45:15.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">Leetcode 876. Middle of the Linked List</a><br>题目目的是求一个非空链表中，从中间元素开始往后的截取一半列表。比较直观的就是设立两个元素以相差一倍的速度进行遍历，当跑的快的达到null，或者即将为null，再返回慢的元素或慢元素的下一个位置。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode q = head.next;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q == <span class="keyword">null</span> || q.next == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q == <span class="keyword">null</span> ? p : p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/middle-of-the-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 876. Middle of the Linked List&lt;/a&gt;&lt;br&gt;题目目的是求一个非空链表中，从中间元素开始往后的截取一半列表。比较直观的就是设立两个元素以相差一倍的速度进行遍历，当跑的快的达到null，或者即将为null，再返回慢的元素或慢元素的下一个位置。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="linked list" scheme="https://dpcfury.github.io/tags/linked-list/"/>
    
  </entry>
  
</feed>
