<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DPC&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/bfa2adcbfd5883f9905426b1399816ee</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dpcfury.github.io/"/>
  <updated>2020-04-29T16:15:46.448Z</updated>
  <id>https://dpcfury.github.io/</id>
  
  <author>
    <name>杜鹏程</name>
    <email>dpcspark@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode[1095] Find in Mountain Array</title>
    <link href="https://dpcfury.github.io/find-in-mountain-array.html/"/>
    <id>https://dpcfury.github.io/find-in-mountain-array.html/</id>
    <published>2020-04-29T16:10:36.000Z</published>
    <updated>2020-04-29T16:15:46.448Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">Leetcode 1095. Find in Mountain Array</a><br>题目：给定一个山脉数组，以及一个目标数，判断山脉数组中是否包含这个数，对查询的操作只能通过MoutainArray接口，并且超过指定的查找次数就会提示超时，属于interactive problem。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>想到很快的能够找到对应元素，以及山脉数组的特征，会想到二分查找，核心是：</p><ul><li>找到山峰，切分为两个子有序数组</li><li>分别再二分查找</li><li>缓存已查询的结果</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>大晚上下班赶着写的，目前还比较糙，后续待优化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr)</span> </span>&#123;</span><br><span class="line">        len = mountainArr.length();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> peek = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> value = get(mid, mountainArr);</span><br><span class="line">            <span class="keyword">int</span> right = mid + <span class="number">1</span> &lt; len ? get(mid + <span class="number">1</span>, mountainArr) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; right) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        peek = low;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = peek;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> value = get(mid, mountainArr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (value == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; target) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        low = peek;</span><br><span class="line">        high = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> value = get(mid, mountainArr);</span><br><span class="line">            <span class="keyword">if</span> (value == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; target) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, MountainArray array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cache.containsKey(index)) <span class="keyword">return</span> cache.get(index);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> value = array.get(index);</span><br><span class="line">                cache.put(index, value);</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/find-in-mountain-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1095. Find in Mountain Array&lt;/a&gt;&lt;br&gt;题目：给定一个山脉数组，以及一个目标数，判断山脉数组中是否包含这个数，对查询的操作只能通过MoutainArray接口，并且超过指定的查找次数就会提示超时，属于interactive problem。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
      <category term="binary search" scheme="https://dpcfury.github.io/tags/binary-search/"/>
    
      <category term="interactive problem" scheme="https://dpcfury.github.io/tags/interactive-problem/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[260] Single Number III</title>
    <link href="https://dpcfury.github.io/single-num-III.html/"/>
    <id>https://dpcfury.github.io/single-num-III.html/</id>
    <published>2020-04-28T13:42:18.000Z</published>
    <updated>2020-04-28T15:41:22.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="noopener">Leetcode 260. Single Number III</a><br>题目：一个整型数组nums里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果题目是找到数组中出现次数为1的唯一元素，那么通过一遍xor操作就能将重复的数置零。但是题目要的是两个数，怎么做呢，还是先亦或加，这样得到的是AxorB的结果，因为A！=B ，则必然有一位，A和B在这位上不同，找到第一个这个位，将数组中其他元素也按这个位是否为1进行切分，自然变成了两个只包含出现一个数只出现一次的子数组，那么再分别亦或加就能得到两个子数组中唯一的数。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> res0 = <span class="number">0</span>, res1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum ^= num;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sum &gt;&gt; i &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((num &gt;&gt; i &amp; <span class="number">1</span>) == <span class="number">1</span>) res1 ^= num;</span><br><span class="line">                <span class="keyword">else</span> res0 ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;res0, res1&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>本题和主站260 是一样的. 除了这个，主站还有136和137，645。 总共加起来本系列一共四道题。 四道题全部都是位运算的套路，如果你想练习位运算的话，不要错过哦～～</p><ul><li><a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">Leetcode 136. Single Number</a></li><li><a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="noopener">Leetcode 137. Single Number II</a></li><li><a href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="noopener">Leetcode 260. Single Number III</a></li><li><a href="https://leetcode.com/problems/set-mismatch/" target="_blank" rel="noopener">Leetcode 645. Set Mismatch</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/single-number-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 260. Single Number III&lt;/a&gt;&lt;br&gt;题目：一个整型数组nums里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="array" scheme="https://dpcfury.github.io/tags/array/"/>
    
      <category term="bit" scheme="https://dpcfury.github.io/tags/bit/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[33]Search in Rotated Sorted Array</title>
    <link href="https://dpcfury.github.io/search-in-rotated-sorted-array.html/"/>
    <id>https://dpcfury.github.io/search-in-rotated-sorted-array.html/</id>
    <published>2020-04-27T13:42:15.000Z</published>
    <updated>2020-04-27T15:41:01.758Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">Leetcode 33. Search in Rotated Sorted Array</a><br>题目：假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p></blockquote><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>遇到有序的数组，时间复杂度又是要求logn，自然而然会想到<strong> binary search </strong> ，但是此题不同的是，数组是一半一半的有序，而不是完整的一个有序数组，那么如何在这样的数组上进行二叉搜索呢，核心是判断[start,mid]元素是处于有序状态，还是[mid, end]处于有序状态，再分情况去更新搜索的左右边界。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[start] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start])</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= nums[end]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end])</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/search-in-rotated-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 33. Search in Rotated Sorted Array&lt;/a&gt;&lt;br&gt;题目：假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。&lt;/p&gt;
&lt;p&gt;搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。&lt;/p&gt;
&lt;p&gt;你可以假设数组中不存在重复的元素。&lt;/p&gt;
&lt;p&gt;你的算法时间复杂度必须是 O(log n) 级别。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="binary search" scheme="https://dpcfury.github.io/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[26] Merge k Sorted Lists</title>
    <link href="https://dpcfury.github.io/merge-k-sorted-list.html/"/>
    <id>https://dpcfury.github.io/merge-k-sorted-list.html/</id>
    <published>2020-04-26T12:28:38.000Z</published>
    <updated>2020-04-26T12:34:00.842Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">Leetcode 26. Merge k Sorted Lists</a><br>题目：合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>将所有链表中的元素遍历存入有限队列中，再通过头插法进行重组链表，时间复杂度O(kN * logkN),空间复杂度O(kN)，其他则可以两两合并，或者分治归并，这里偷懒写的是优先队列的形式。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.val - o1.val; <span class="comment">// 降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ListNode p : lists) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(p);</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            ListNode p = queue.poll();</span><br><span class="line">            p.next = head.next; <span class="comment">// 头插法</span></span><br><span class="line">            head.next = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-k-sorted-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 26. Merge k Sorted Lists&lt;/a&gt;&lt;br&gt;题目：合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="linkedlist" scheme="https://dpcfury.github.io/tags/linkedlist/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>力扣中国 面试题51. 数组中的逆序对</title>
    <link href="https://dpcfury.github.io/reverse-pairs.html/"/>
    <id>https://dpcfury.github.io/reverse-pairs.html/</id>
    <published>2020-04-25T13:26:28.000Z</published>
    <updated>2020-04-25T13:34:05.755Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a><br>题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这题可以和归并排序紧密结合，在合并的过程中，就能统计出全局的逆序对数，所以需要选择一个合适的归并排序实现方式即可。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> count;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 左边</span></span><br><span class="line">            mergeSort(nums, low, mid);</span><br><span class="line">            <span class="comment">// 右边</span></span><br><span class="line">            mergeSort(nums, mid + <span class="number">1</span>, high);</span><br><span class="line">            <span class="comment">// 左右归并</span></span><br><span class="line">            merge(nums, low, mid, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = low;<span class="comment">// 左指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">// 右指针</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">                temp[k++] = a[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = a[j++];</span><br><span class="line">                count += (mid - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把左边剩余的数移入数组</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line"><span class="comment">//            count++;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把新数组中的数覆盖nums数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">            a[k2 + low] = temp[k2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt;= nums2[j]) &#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k] = nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                nums1[k] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题51. 数组中的逆序对&lt;/a&gt;&lt;br&gt;题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="merge sort" scheme="https://dpcfury.github.io/tags/merge-sort/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[46] Permutations</title>
    <link href="https://dpcfury.github.io/permutations.html/"/>
    <id>https://dpcfury.github.io/permutations.html/</id>
    <published>2020-04-25T13:10:51.000Z</published>
    <updated>2020-04-25T13:26:09.249Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">Leetcode 46. Permutations</a><br>题目：给定一个 <strong>没有重复 数字的序列</strong>，返回其所有可能的全排列。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>不带重读的全排列问题，这种permutations、Subsets、Combinations问题，基本都可以沿用回溯的方法去搜索求解，具有比较一致的重复套路：<a href="https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning" target="_blank" rel="noopener">通用回溯思路</a>)。</p><p>但是深入理解回溯和搜索空间以及优化，对后面的结题其实有非常大的帮助,这里贴出力扣中国给出的社区解答：<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">官网解答</a></p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>approach1：原始通用解法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// Arrays.sort(nums); // not necessary</span></span><br><span class="line">   backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums);</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</span><br><span class="line">      list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">   &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123; </span><br><span class="line">         <span class="keyword">if</span>(tempList.contains(nums[i])) <span class="keyword">continue</span>; <span class="comment">// element already exists, skip</span></span><br><span class="line">         tempList.add(nums[i]);</span><br><span class="line">         backtrack(list, tempList, nums);</span><br><span class="line">         tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>approach2：优化的swap解法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Arrays.sort(nums); // not necessary</span></span><br><span class="line">        backtrack(list, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, <span class="keyword">int</span> start, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">            List&lt;Integer&gt; tmpList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)</span><br><span class="line">                tmpList.add(i);</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmpList));</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">                swap(start,i,nums);</span><br><span class="line">                backtrack(list, start+<span class="number">1</span>, nums);</span><br><span class="line">                swap(i,start,nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/permutations/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 46. Permutations&lt;/a&gt;&lt;br&gt;题目：给定一个 &lt;strong&gt;没有重复 数字的序列&lt;/strong&gt;，返回其所有可能的全排列。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode.cn 面试题 08.11. 硬币</title>
    <link href="https://dpcfury.github.io/way-to-change.html/"/>
    <id>https://dpcfury.github.io/way-to-change.html/</id>
    <published>2020-04-23T14:17:21.000Z</published>
    <updated>2020-04-23T15:25:11.834Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">力扣中国 面试题 08.11. 硬币</a><br>题目：给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>一条非常好的题，从问题的思考，到一步一步的优化，对深入理解动态规划、背包问题以及滚动数组有非常大的帮助。思路参照乐扣中国给出的官方分析，非常到位，这里不做重复描述：<a href="https://leetcode-cn.com/problems/coin-lcci/solution/ying-bi-by-leetcode-solution/" target="_blank" rel="noopener">官方解答</a></p><p>这道题本质是完全背包问题，在限定的体积V（题中的n），达到V的最大组合方案数</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> coin = coins[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = coin; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>这题是深入理解背包问题、找零问题的契机，后续关注：<a href="https://leetcode-cn.com/problems/coin-lcci/solution/bei-bao-jiu-jiang-ge-ren-yi-jian-da-jia-fen-xiang-/" target="_blank" rel="noopener">背包问题、非常棒的讲法</a></p><p>ps: B站的大雪菜up主有一期视频就是讲解背包九讲的十分细致，推荐观看。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/coin-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;力扣中国 面试题 08.11. 硬币&lt;/a&gt;&lt;br&gt;题目：给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>MapStruct使用</title>
    <link href="https://dpcfury.github.io/mapstruct-intro.html/"/>
    <id>https://dpcfury.github.io/mapstruct-intro.html/</id>
    <published>2020-04-22T14:53:27.000Z</published>
    <updated>2020-04-26T12:50:24.889Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://mapstruct.org/" target="_blank" rel="noopener">MapStruct</a><br>在当前的系统设计中，经常会在PO、VO，DTO之间来回转换，为了在业务代码中尽量不让set、get打断代码逻辑，方便阅读理解代码，需要提供对象之间灵活转换的解决方案，而MapStruct正是今天介绍的一种映射库。只需要定义一个 Mapper 接口，MapStruct 就会自动实现这个映射接口，避免了复杂繁琐的映射实现。</p></blockquote><a id="more"></a><h4 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.1.Final&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.1.Final&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>ps: springboot没有提供默认的mapstruct版本，所以在boot中引用需要手动指定对应的版本号，目前的稳定版本是<strong> 1.3.1.Final</strong></p></blockquote><h4 id="接口编写"><a href="#接口编写" class="headerlink" title="接口编写"></a>接口编写</h4><p>假设我们需要转换Host（机器实体）到HostDTO（rpc、http传输对象），只需要编写下面的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>(componentModel = <span class="string">"spring"</span>) <span class="comment">// 利用spring注入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HostMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"sn"</span>, target = <span class="string">"sn"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"hostName"</span>, target = <span class="string">"hostName"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"iloMac"</span>, target = <span class="string">"iloMac"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"mac1"</span>, target = <span class="string">"mac1"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"cpu"</span>, target = <span class="string">"cpu"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"memory"</span>, target = <span class="string">"memory"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"hardDisk"</span>, target = <span class="string">"hardDisk"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"ssd"</span>, target = <span class="string">"ssd"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"model"</span>, target = <span class="string">"model"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"manufacturer"</span>, target = <span class="string">"manufacturer"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"os"</span>, target = <span class="string">"os"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"description"</span>, target = <span class="string">"description"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"arrivedTime"</span>, target = <span class="string">"arrivedTime"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"extraInfo"</span>, target = <span class="string">"extraInfo"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"suit"</span>, target = <span class="string">"suit"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Host <span class="title">from</span><span class="params">(HostDTO hostDTO)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"sn"</span>, target = <span class="string">"sn"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"hostName"</span>, target = <span class="string">"hostName"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"iloMac"</span>, target = <span class="string">"iloMac"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"mac1"</span>, target = <span class="string">"mac1"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"cpu"</span>, target = <span class="string">"cpu"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"memory"</span>, target = <span class="string">"memory"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"hardDisk"</span>, target = <span class="string">"hardDisk"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"ssd"</span>, target = <span class="string">"ssd"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"model"</span>, target = <span class="string">"model"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"manufacturer"</span>, target = <span class="string">"manufacturer"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"os"</span>, target = <span class="string">"os"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"description"</span>, target = <span class="string">"description"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"arrivedTime"</span>, target = <span class="string">"arrivedTime"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"extraInfo"</span>, target = <span class="string">"extraInfo"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(source= <span class="string">"suit"</span>, target = <span class="string">"suit"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HostDTO <span class="title">from</span><span class="params">(Host host)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>我们在Junit中尝试使用这个mapper进行对象的转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> HostMapper hostMapper; <span class="comment">// IOC 依赖注入</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHostMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HostDTO hostDTO = <span class="keyword">new</span> HostDTO();</span><br><span class="line">        hostDTO.setSn(<span class="string">"host01"</span>);</span><br><span class="line">        hostDTO.setHostName(<span class="string">"host01.maas"</span>);</span><br><span class="line">        hostDTO.setIloMac(<span class="string">"weqweqweqw"</span>);</span><br><span class="line">        hostDTO.setMac1(<span class="string">"sdasdasdsa"</span>);</span><br><span class="line">        hostDTO.setCpu(<span class="string">"core 24"</span>);</span><br><span class="line">        hostDTO.setMemory(<span class="string">"512GB"</span>);</span><br><span class="line">        hostDTO.setHardDisk(<span class="string">"8600GB"</span>);</span><br><span class="line">        hostDTO.setSsd(<span class="string">"6x480"</span>);</span><br><span class="line">        hostDTO.setModel(<span class="string">"xxxx"</span>);</span><br><span class="line">        hostDTO.setManufacturer(<span class="string">"H3C"</span>);</span><br><span class="line">        hostDTO.setArrivedTime(<span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">        hostDTO.setSuit(<span class="string">"Y32-X14"</span>);</span><br><span class="line"></span><br><span class="line">        Host host = hostMapper.from(hostDTO);</span><br><span class="line"></span><br><span class="line">        System.out.println(host);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://mapstruct.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MapStruct&lt;/a&gt;&lt;br&gt;在当前的系统设计中，经常会在PO、VO，DTO之间来回转换，为了在业务代码中尽量不让set、get打断代码逻辑，方便阅读理解代码，需要提供对象之间灵活转换的解决方案，而MapStruct正是今天介绍的一种映射库。只需要定义一个 Mapper 接口，MapStruct 就会自动实现这个映射接口，避免了复杂繁琐的映射实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发" scheme="https://dpcfury.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="spring-boot" scheme="https://dpcfury.github.io/tags/spring-boot/"/>
    
      <category term="Java" scheme="https://dpcfury.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[560] Subarray Sum Equals K</title>
    <link href="https://dpcfury.github.io/subarray-sum-equals-k.html/"/>
    <id>https://dpcfury.github.io/subarray-sum-equals-k.html/</id>
    <published>2020-04-22T14:16:46.000Z</published>
    <updated>2020-04-22T14:28:05.463Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">Leetcode 560. Subarray Sum Equals K</a><br>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。这题是比较典型的前缀和应用类问题，最粗暴的就是O(n^3)的暴力求解。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>approach1 优化求子数组和过程</p><ul><li>令sum(i) 为遍历到nums第i个元素的前缀和，那么计算 子数组nums[j]-&gt; nusm[k]的和直接等于 nums[k]-nums[i]</li><li>遍历所有可能的j、k组合，统计所有符合的子数组</li></ul><p>approach2 利用map存储<br>在一次遍历的过程中，记录出现前缀和sum的次数，如果map.containsKey(sum-k)：</p><ul><li>说明前面出现了nums[i]-nums[j]=k的情况，则可以累加这个sum-k出现的次数</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 关键思路， sum(i) sum(j) sum(i-j)之间的关系</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;</span><br><span class="line">                count += map.get(sum - k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/subarray-sum-equals-k/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 560. Subarray Sum Equals K&lt;/a&gt;&lt;br&gt;给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。这题是比较典型的前缀和应用类问题，最粗暴的就是O(n^3)的暴力求解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="prefix sum" scheme="https://dpcfury.github.io/tags/prefix-sum/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode [199]  Binary Tree Right Side View</title>
    <link href="https://dpcfury.github.io/binary-tree-right-side-view.html/"/>
    <id>https://dpcfury.github.io/binary-tree-right-side-view.html/</id>
    <published>2020-04-22T13:40:14.000Z</published>
    <updated>2020-04-22T13:49:14.614Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">Leetcode 199. Binary Tree Right Side View</a><br>求从右侧看一颗二叉树，所能看到的元素列表: 例如下面的二叉树，对应输出为[1, 3, 5]</p></blockquote><pre><code>   1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---</code></pre><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>DFS，先遍历右子树</li><li>BDF，每一层的最后一个元素</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            res.add(queue.getLast().val);</span><br><span class="line">            List&lt;TreeNode&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) temp.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) temp.add(node.right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : temp) queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-right-side-view/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 199. Binary Tree Right Side View&lt;/a&gt;&lt;br&gt;求从右侧看一颗二叉树，所能看到的元素列表: 例如下面的二叉树，对应输出为[1, 3, 5]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;   1            &amp;lt;---
 /   \
2     3         &amp;lt;---
 \     \
  5     4       &amp;lt;---
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
      <category term="dfs" scheme="https://dpcfury.github.io/tags/dfs/"/>
    
      <category term="bfs" scheme="https://dpcfury.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode [1248] Count Number of Nice Subarrays</title>
    <link href="https://dpcfury.github.io/count-number-of-nice-subarrays.html/"/>
    <id>https://dpcfury.github.io/count-number-of-nice-subarrays.html/</id>
    <published>2020-04-21T14:08:36.000Z</published>
    <updated>2020-04-21T14:18:02.145Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">Leetcode 1248. Count Number of Nice Subarrays</a><br>题目要求计算给定数组nums中，满足包含K个奇数元素的子数组的个数，这个题目比较容易想到滑动窗口的思路，关键是对前后偶数元素的计算和边界的控制。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>首先统计出每个奇数元素在数组中的出现位置，并记录在中间数组oddIndex中</li><li>遍历每组K个奇数组合，即oddIndex[i] 与oddIndex[i+k-1],通过计算左右边界与前后奇数元素的间隔，就能得到前后偶数的个数，相乘就能得到组合的子数组个数</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = nums.length;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> oddNum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span>[] oddIndex = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">2</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[i] % <span class="number">2</span> == <span class="number">1</span>) oddIndex[++oddNum] = i;</span><br><span class="line">       &#125;</span><br><span class="line">       oddIndex[<span class="number">0</span>] = -<span class="number">1</span>; <span class="comment">// 左边界</span></span><br><span class="line">       oddIndex[oddNum + <span class="number">1</span>] = len; <span class="comment">// 右边界</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + k &lt;= oddNum + <span class="number">1</span>; i++) &#123;</span><br><span class="line">           count += (oddIndex[i] - oddIndex[i - <span class="number">1</span>]) * (oddIndex[i + k] - oddIndex[i + k - <span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>类似题目：<a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">Leetcode 560. Subarray Sum Equals K</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/count-number-of-nice-subarrays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1248. Count Number of Nice Subarrays&lt;/a&gt;&lt;br&gt;题目要求计算给定数组nums中，满足包含K个奇数元素的子数组的个数，这个题目比较容易想到滑动窗口的思路，关键是对前后偶数元素的计算和边界的控制。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="array" scheme="https://dpcfury.github.io/tags/array/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="sliding window" scheme="https://dpcfury.github.io/tags/sliding-window/"/>
    
  </entry>
  
  <entry>
    <title>并查集基本概念</title>
    <link href="https://dpcfury.github.io/union-find.html/"/>
    <id>https://dpcfury.github.io/union-find.html/</id>
    <published>2020-04-21T12:30:35.000Z</published>
    <updated>2020-04-21T12:45:04.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Union Find</p></blockquote><a id="more"></a><h4 id="什么是并查集？"><a href="#什么是并查集？" class="headerlink" title="什么是并查集？"></a>什么是并查集？</h4><ul><li>并查集可以进行集合合并的操作（并）</li><li>并查集可以查找元素在哪个集合中（查）</li><li>并查集维护的是一堆集合（集）</li></ul><h4 id="并查集如何实现"><a href="#并查集如何实现" class="headerlink" title="并查集如何实现"></a>并查集如何实现</h4><h4 id="并查集能干啥"><a href="#并查集能干啥" class="headerlink" title="并查集能干啥"></a>并查集能干啥</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Union Find&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://dpcfury.github.io/categories/algorithm/"/>
    
    
      <category term="union find" scheme="https://dpcfury.github.io/tags/union-find/"/>
    
      <category term="concept" scheme="https://dpcfury.github.io/tags/concept/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[121] Best Time to Buy and Sell Stock</title>
    <link href="https://dpcfury.github.io/best-time-to-buy-and-sell-stock.html/"/>
    <id>https://dpcfury.github.io/best-time-to-buy-and-sell-stock.html/</id>
    <published>2020-04-20T13:28:10.000Z</published>
    <updated>2020-04-20T14:46:17.794Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">Leetcode 121 Best Time to Buy and Sell Stock</a><br>抛售股票的最原始题，只能抛售一次，问能够获取的最大利润，这里给出的是一种比较直观的方法，没有使用dp进行求解。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>记录当前出现的最小元素，用当前元素减去最小元素，如果收益更大，则更新全局最大利润</li><li>如果当前元素比之前出现的最小元素还小，则更新当前最小元素为当前遍历的元素</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//7,1,5,3,6,4  -&gt; 5</span></span><br><span class="line">        <span class="comment">// 7,6,4,3,1 -&gt;0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProfit = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - min &gt; maxProfit) maxProfit = prices[i] - min;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; min) min = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 121 Best Time to Buy and Sell Stock&lt;/a&gt;&lt;br&gt;抛售股票的最原始题，只能抛售一次，问能够获取的最大利润，这里给出的是一种比较直观的方法，没有使用dp进行求解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[695] Max Area of Island</title>
    <link href="https://dpcfury.github.io/max-area-of-island.html/"/>
    <id>https://dpcfury.github.io/max-area-of-island.html/</id>
    <published>2020-04-20T12:49:19.000Z</published>
    <updated>2020-04-20T12:53:53.364Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="">Leetcode 695. Max Area of Island</a><br>题目和 <strong>Leetcode[200] Num of Islands</strong>属于同一类题目，只是要求得内容为独立小岛最大的面积。将题目定义为dfs类型比backtracking类型更为合适。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>遍历面板，只要遇到1元素，则开始dfs</li><li>dfs过程：<ul><li>如果坐标超标或元素不为1，返回0</li><li>返回 1+ 四个方向dfs结果</li></ul></li><li>dfs完成更新全局Max值</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    max = Math.max(max, dfs(grid, row, col, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col || grid[i][j] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        res += dfs(grid, row, col, i, j + <span class="number">1</span>);</span><br><span class="line">        res += dfs(grid, row, col, i, j - <span class="number">1</span>);</span><br><span class="line">        res += dfs(grid, row, col, i - <span class="number">1</span>, j);</span><br><span class="line">        res += dfs(grid, row, col, i + <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;&quot;&gt;Leetcode 695. Max Area of Island&lt;/a&gt;&lt;br&gt;题目和 &lt;strong&gt;Leetcode[200] Num of Islands&lt;/strong&gt;属于同一类题目，只是要求得内容为独立小岛最大的面积。将题目定义为dfs类型比backtracking类型更为合适。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dfs" scheme="https://dpcfury.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[200] Num of Islands</title>
    <link href="https://dpcfury.github.io/num-of-islands.html/"/>
    <id>https://dpcfury.github.io/num-of-islands.html/</id>
    <published>2020-04-19T16:05:34.000Z</published>
    <updated>2020-04-22T12:43:37.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">Leetcode200 Num of Islands</a><br>题目定义一个二维面板表示的地图，其中‘0’代表海洋，‘1’表示陆地，上下左右相邻的陆地构成一个小岛，问这个地图中独立的小岛数量，很经典的回溯dfs类题目。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>遍历整个面板，如果面板元素grid[i][j]未访问，且是陆地，则可以进行dfs遍历，标记改陆地所相邻的所有陆地，遍历完成，独立小岛数量+1</li><li>可以用boolean数组标记是否访问，也可以将陆地改变为海洋（考虑题目是否允许改动面板）</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length==<span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    traversal(grid, row, col, i, j, visited);</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col || grid[i][j] != <span class="string">'1'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i][j]) &#123;</span><br><span class="line">                visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                traversal(grid, row, col, i - <span class="number">1</span>, j, visited);</span><br><span class="line">                traversal(grid, row, col, i + <span class="number">1</span>, j, visited);</span><br><span class="line">                traversal(grid, row, col, i, j - <span class="number">1</span>, visited);</span><br><span class="line">                traversal(grid, row, col, i, j + <span class="number">1</span>, visited);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>除了DFS+BFS，这题还可以用UnionFind实现，关于并查集的定义和理解，参考<a href="https://juejin.im/post/5d8e66fdf265da5b633cc8db" target="_blank" rel="noopener">https://juejin.im/post/5d8e66fdf265da5b633cc8db</a> ，后续补充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">int</span>[] parent;</span><br><span class="line">        <span class="keyword">int</span>[] rank; <span class="comment">// 表示以 i 为根节点的集合的层数，即树的高度</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> m = grid.length;</span><br><span class="line">            <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        parent[i * n + j] = i * n + j;</span><br><span class="line">                        ++count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rank[i * n + j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] != i) parent[i] = find(parent[i]); <span class="comment">// 路径压缩</span></span><br><span class="line">            <span class="keyword">return</span> parent[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootx = find(x); <span class="comment">//找出x元素位于的集合的根元素</span></span><br><span class="line">            <span class="keyword">int</span> rooty = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123; <span class="comment">//rootx元素所在的集合的层数大于rooty元素所在的集合的层数</span></span><br><span class="line">                    parent[rooty] = rootx; <span class="comment">//rooty集合的根节点父亲指针指向rootx集合的根节点</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">                    parent[rootx] = rooty;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent[rooty] = rootx; <span class="comment">// 层数相同，随意</span></span><br><span class="line">                    rank[rootx] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(grid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        uf.union(r * nc + c, (r-<span class="number">1</span>) * nc + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        uf.union(r * nc + c, (r+<span class="number">1</span>) * nc + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        uf.union(r * nc + c, r * nc + c - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        uf.union(r * nc + c, r * nc + c + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-islands/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode200 Num of Islands&lt;/a&gt;&lt;br&gt;题目定义一个二维面板表示的地图，其中‘0’代表海洋，‘1’表示陆地，上下左右相邻的陆地构成一个小岛，问这个地图中独立的小岛数量，很经典的回溯dfs类题目。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
      <category term="dfs" scheme="https://dpcfury.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[980] Unique Paths III</title>
    <link href="https://dpcfury.github.io/unique-pathIII.html/"/>
    <id>https://dpcfury.github.io/unique-pathIII.html/</id>
    <published>2020-04-19T13:53:16.000Z</published>
    <updated>2020-04-19T14:07:56.734Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/unique-paths-iii/" target="_blank" rel="noopener">Leetcode 980. Unique Paths III</a><br>这题要求从二维面板中，找到所有不同的从起点到终点的遍历路径，要求每条路径正好包含一次每个0元素，结题基本套路还是利用回溯的方法，不同的是需要考虑走过路径的0的个数，而且不能重复。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>基本算法框架还是回溯，但是回溯的时候增加一个变量，就是障碍格子的数量，当搜索路径中已经包含了 <strong> 格子总数</strong> - <strong> 障碍个数</strong> -1 时，并且当前准备搜索的点是终点，说明找到了合法解。dp的解法则是定义了dp[r][c][todo] 则是定义了，在grid[r][c]这个点上，在还有todo个空格灭有搜索情况下，有几条独立的到终点路径，然后利用memorization记录中间结果，减少dfs的次数。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>这里给出个人蹩脚的实现，暂时还未做优化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> startX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numOfObstacle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    startX = i;</span><br><span class="line">                    startY = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == -<span class="number">1</span>) numOfObstacle++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        dfs(grid, row, col, startX, startY, numOfObstacle, visited, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> numOfObstacle, <span class="keyword">boolean</span>[][] visited, LinkedList&lt;<span class="keyword">int</span>[]&gt; path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span> &amp;&amp; path.size() == row * col - numOfObstacle - <span class="number">1</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] index : path) &#123;</span><br><span class="line"><span class="comment">//                grid[index[0]][index[1]] = -1;</span></span><br><span class="line">                System.out.print(<span class="string">"("</span> + index[<span class="number">0</span>] + <span class="string">", "</span> + index[<span class="number">1</span>] + <span class="string">"), "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">"("</span> + i + <span class="string">", "</span> + j + <span class="string">")"</span>);</span><br><span class="line">            path.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            dfs(grid, row, col, i, j + <span class="number">1</span>, numOfObstacle, visited, path);</span><br><span class="line">            dfs(grid, row, col, i, j - <span class="number">1</span>, numOfObstacle, visited, path);</span><br><span class="line">            dfs(grid, row, col, i - <span class="number">1</span>, j, numOfObstacle, visited, path);</span><br><span class="line">            dfs(grid, row, col, i + <span class="number">1</span>, j, numOfObstacle, visited, path);</span><br><span class="line">            visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>优化后：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> startX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numOfObstacle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    startX = i;</span><br><span class="line">                    startY = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == -<span class="number">1</span>) numOfObstacle++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(grid, row, col, startX, startY, row * col - <span class="number">1</span> - numOfObstacle);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> todo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span> &amp;&amp; todo == <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] != <span class="number">3</span> &amp;&amp; grid[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            grid[i][j] = <span class="number">3</span>;</span><br><span class="line">            todo--;</span><br><span class="line">            dfs(grid, row, col, i, j + <span class="number">1</span>, todo);</span><br><span class="line">            dfs(grid, row, col, i, j - <span class="number">1</span>, todo);</span><br><span class="line">            dfs(grid, row, col, i - <span class="number">1</span>, j, todo);</span><br><span class="line">            dfs(grid, row, col, i + <span class="number">1</span>, j, todo);</span><br><span class="line">            grid[i][j] = <span class="number">0</span>;</span><br><span class="line">            todo++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>优化后时间超过 100%，空间超过33%</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/unique-paths-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 980. Unique Paths III&lt;/a&gt;&lt;br&gt;这题要求从二维面板中，找到所有不同的从起点到终点的遍历路径，要求每条路径正好包含一次每个0元素，结题基本套路还是利用回溯的方法，不同的是需要考虑走过路径的0的个数，而且不能重复。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1339] Maximum Product of Splitted Binary Tree</title>
    <link href="https://dpcfury.github.io/maximum-product-of-splitted-binary-tree.html/"/>
    <id>https://dpcfury.github.io/maximum-product-of-splitted-binary-tree.html/</id>
    <published>2020-04-19T08:37:45.000Z</published>
    <updated>2020-04-19T08:45:30.946Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/" target="_blank" rel="noopener">Leetcode 1339. Maximum Product of Splitted Binary Tree</a><br>题目给定一课二叉树，选择一个边进行切分，整棵树变成两部分，要求分开的两个字数乘积最大。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>无论是切分哪条边，整颗树肯定是分为了一颗字子树，以及包含这个边上连父节点的子树，利用dfs的思路，遍历每个节点，都可以计算其子树的和于包含自己的子树和乘积，并更新全局最大。核心是先通过一次遍历求得整个树的整体的综合，减去子树的和，就能得到包含父节点那棵树的和，此外，因为树的规模还不小，乘积大小也较大，考虑double类型，并且最好将子树和进行memorization。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> max = <span class="number">0</span>, totalSum = <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;TreeNode, Double&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        totalSum = sum(root);</span><br><span class="line">        memo.put(<span class="keyword">null</span>, <span class="number">0.0</span>);</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (max % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">double</span> leftSum = memo.get(root.left);</span><br><span class="line">        <span class="keyword">double</span> rightSum = memo.get(root.right);</span><br><span class="line">        <span class="keyword">if</span> ((totalSum - leftSum) * leftSum &gt; (totalSum - rightSum) * rightSum) &#123;</span><br><span class="line">            max = Math.max(max, (totalSum - leftSum) * leftSum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, (totalSum - rightSum) * rightSum);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> leftSum = sum(root.left);</span><br><span class="line">        <span class="keyword">double</span> rightSum = sum(root.right);</span><br><span class="line">        <span class="keyword">double</span> sum = leftSum + rightSum + root.val;</span><br><span class="line">        memo.put(root, sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1339. Maximum Product of Splitted Binary Tree&lt;/a&gt;&lt;br&gt;题目给定一课二叉树，选择一个边进行切分，整棵树变成两部分，要求分开的两个字数乘积最大。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Leetcode[466] Count The Repetitions</title>
    <link href="https://dpcfury.github.io/count-the-repetitions.html/"/>
    <id>https://dpcfury.github.io/count-the-repetitions.html/</id>
    <published>2020-04-19T06:21:14.000Z</published>
    <updated>2020-04-19T06:41:31.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/count-the-repetitions/" target="_blank" rel="noopener">Leetcode 466. Count The Repetitions</a><br>题目大意是：定义S = [s,n] 表示字符串S由字符串s重复n次构成。 例如[“abc”, 3] =”abcabcabc”<br>另一方面，我们定义字符串s1可以从s2得到，如果我们可以通过从s2中移除一些字符得到s1。例如根据定义，“abc”可以从“abdbec”得到，但是“acbbe”则不行。<br>给定两个非空字符串s1和s2（每个最多100个字符），两个整数 0 ≤ n1 ≤ 10^6 和 1 ≤ n2 ≤ 10^6。现在考虑字符串S1和S2，其中S1=[s1,n1] 并且 S2=[s2,n2]。计算满足[S2,M]可以从S1得到的最大整数M。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目意思较为难懂，进过几次阅读后，大致明白了这个意思，也能体会到题目背后的核心是如何可用循环重复字符串进行规律的总结，而不是使用暴力的方法求解，结题思路参考自leetcode disscuss中一个解答，核心是发现规律，利用循环节的概念，将s1 * n1 这种长串中出现的反复规律找出来，减少循环遍历的时间损耗：步骤如下：</p><ul><li>遍历S1，追踪每次匹配结束，s2中最后一个字符的下标</li><li>持续遍历，只直到发现s2中的结束坐标重复出现，则：<ul><li>将S1 分为循环前的部分、循环体、结尾部分<ul><li>计算循环体中循环节的出现次数，需要的s1个数和匹配的s2个数</li><li>编列循环前和循环后的情况，补全可匹配的s2个数</li></ul></li></ul></li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>approach1 原始的brute force解法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxRepetitions1</span><span class="params">(String s1, <span class="keyword">int</span> n1, String s2, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0-&gt;n1次，计算最少的需要多少字符串才能</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            dp[i] = contSubsequence(s2, build(s1, i));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n1] / n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">contSubsequence</span><span class="params">(String s, String t)</span> </span>&#123; <span class="comment">//判断 t中能包含几个s序列</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.length()) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == s.length()) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">build</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) str.append(s);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>approach2 引用的循环节解法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxRepetitions</span><span class="params">(String s1, <span class="keyword">int</span> n1, String s2, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nn1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> nn2 = s2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// records[0][i]标识第i个s1用完s2匹配的位置</span></span><br><span class="line">        <span class="comment">// records[1][i] 标识使用i个s1能匹配的s2个数</span></span><br><span class="line">        <span class="keyword">int</span>[][] records = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][n1+<span class="number">1</span>]; </span><br><span class="line">        Arrays.fill(records[<span class="number">0</span>], -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cycleStart = -<span class="number">1</span>, cycleEnd = -<span class="number">1</span>, cycleCount = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nn1; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(j) == s2.charAt(index2)) &#123;</span><br><span class="line">                    index2++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (index2 == nn2) &#123;</span><br><span class="line">                    index2 = <span class="number">0</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; i; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (records[<span class="number">0</span>][k] == index2) &#123;</span><br><span class="line">                    <span class="comment">// we find the cycle, record start/end/count and then quit the loop</span></span><br><span class="line">                    cycleStart = k;</span><br><span class="line">                    cycleEnd = i;</span><br><span class="line">                    cycleCount = count - records[<span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cycleStart != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            records[<span class="number">0</span>][i] = index2;</span><br><span class="line">            records[<span class="number">1</span>][i] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cycleStart == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count / n2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// calculate cycle</span></span><br><span class="line">        <span class="keyword">int</span> cycleN = (n1 - cycleStart) / (cycleEnd - cycleStart);</span><br><span class="line">        res = cycleN * cycleCount;</span><br><span class="line">        <span class="comment">// snitich pre-cycle and post-cycle parts</span></span><br><span class="line">        res += records[<span class="number">1</span>][n1 - cycleN * (cycleEnd - cycleStart)];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res / n2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/count-the-repetitions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 466. Count The Repetitions&lt;/a&gt;&lt;br&gt;题目大意是：定义S = [s,n] 表示字符串S由字符串s重复n次构成。 例如[“abc”, 3] =”abcabcabc”&lt;br&gt;另一方面，我们定义字符串s1可以从s2得到，如果我们可以通过从s2中移除一些字符得到s1。例如根据定义，“abc”可以从“abdbec”得到，但是“acbbe”则不行。&lt;br&gt;给定两个非空字符串s1和s2（每个最多100个字符），两个整数 0 ≤ n1 ≤ 10^6 和 1 ≤ n2 ≤ 10^6。现在考虑字符串S1和S2，其中S1=[s1,n1] 并且 S2=[s2,n2]。计算满足[S2,M]可以从S1得到的最大整数M。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
      <category term="循环节" scheme="https://dpcfury.github.io/tags/%E5%BE%AA%E7%8E%AF%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[11] Container With Most Water</title>
    <link href="https://dpcfury.github.io/container-with-most-water.html/"/>
    <id>https://dpcfury.github.io/container-with-most-water.html/</id>
    <published>2020-04-18T00:53:37.000Z</published>
    <updated>2020-04-18T01:24:20.818Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">Leetcode 11. Container With Most Water</a><br>题目是经典的双指针问题，给定一个高度的数组，求能够围成的长方形最大面积，很中规中矩，从这题可以延伸到trapping rain waterh那道题。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>直观上肯定是希望长和高都尽量大，容易得到一个面积更大的长方形，那么是不是外圈的更容易是最终解呢，这不一定，可能内圈的长方形高度很高。因此，结题思路其实是设置两个指针，从外往里遍历求解，如果左侧指针的高度小于右侧，则将左侧指针左移，如果右侧指针高度小于左侧，则将右侧指针左移,因为当前搜索空间中，这个面积取决于短的那个高度，所以哪个短，就尝试移动哪个获取更大面积的可能。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = right - left;</span><br><span class="line">            <span class="keyword">int</span> h = Math.min(height[left], height[right]);</span><br><span class="line">            max = Math.max(max, len * h);</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) left++;</span><br><span class="line">            <span class="keyword">else</span> right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/container-with-most-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 11. Container With Most Water&lt;/a&gt;&lt;br&gt;题目是经典的双指针问题，给定一个高度的数组，求能够围成的长方形最大面积，很中规中矩，从这题可以延伸到trapping rain waterh那道题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="two pointers" scheme="https://dpcfury.github.io/tags/two-pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[55] Jump Game</title>
    <link href="https://dpcfury.github.io/jump-game.html/"/>
    <id>https://dpcfury.github.io/jump-game.html/</id>
    <published>2020-04-17T15:08:22.000Z</published>
    <updated>2020-04-17T15:17:39.759Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">Leetcode 55. Jump Game</a><br>经典的动态规划题，解题思路比较容易，按递归式实现即可，基本的算法时间复杂度o(n * 2)，其实可以降低为o(n)，遍历当前的最可达范围，只要能够触及到终点，就可以收敛返回。</p></blockquote><a id="more"></a><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>approach1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; j + nums[j] &gt;= i) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>approach2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> target = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= max) &#123;</span><br><span class="line">            max = Math.max(nums[index] + index, max);</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (max &gt;= target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/jump-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 55. Jump Game&lt;/a&gt;&lt;br&gt;经典的动态规划题，解题思路比较容易，按递归式实现即可，基本的算法时间复杂度o(n * 2)，其实可以降低为o(n)，遍历当前的最可达范围，只要能够触及到终点，就可以收敛返回。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
</feed>
