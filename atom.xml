<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DPC&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/bfa2adcbfd5883f9905426b1399816ee</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dpcfury.github.io/"/>
  <updated>2020-04-06T12:33:47.730Z</updated>
  <id>https://dpcfury.github.io/</id>
  
  <author>
    <name>杜鹏程</name>
    <email>dpcspark@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode[583] Delete Operation for Two Strings</title>
    <link href="https://dpcfury.github.io/delete-operation-for-two-strings.html/"/>
    <id>https://dpcfury.github.io/delete-operation-for-two-strings.html/</id>
    <published>2020-04-06T12:19:30.000Z</published>
    <updated>2020-04-06T12:33:47.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener"> Leetcode 583 Delete Operation for Two Strings</a><br>题目和经典的Edit Distance 属于同一类问题，只是允许的操作变限制为了删除操作，问需要两个单词需要最少的删除操作，能够变为相同的字符串。核心还是如何找到一个问题规模收敛的入口，从而在问题规模缩小的过程中，找到递推的规律，进而推导出表达式，再利用自顶向下或自底向上的方法去实现。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定word1和word2，通过最少的删除操作，使得两个单词最终变为相同的字符串，先从特殊的情况开始考虑，如果某个单词为空串（长度为0），另一个不为空串，则需要的最少操作步骤为不为空的单词长度。从中又可以感受到一点动态规划的味道。<br>继续分析，假设令dp[i][j] 为word1前i个字符串 和word2前j个字符串，变成相同字符串需要的最少删除次数，那么：</p><ul><li>case1:  word1.charAt(i-1) == word2.charAt(j-1)，那么dp[i][j] = dp[i-1][j-1]</li><li>case2:  word1.charAt(i-1) != word2.charAt(j-1)：<ul><li>可能1: dp[i][j] = dp[i-1][j]+1  // 通过word2insert一个字符</li><li>可能2: dp[i][j] = dp[i][j-1] +1 // 通过word1insert一个字符</li></ul></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1 == <span class="keyword">null</span> || word2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/delete-operation-for-two-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; Leetcode 583 Delete Operation for Two Strings&lt;/a&gt;&lt;br&gt;题目和经典的Edit Distance 属于同一类问题，只是允许的操作变限制为了删除操作，问需要两个单词需要最少的删除操作，能够变为相同的字符串。核心还是如何找到一个问题规模收敛的入口，从而在问题规模缩小的过程中，找到递推的规律，进而推导出表达式，再利用自顶向下或自底向上的方法去实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[72] Edit DistanceEdit Distance</title>
    <link href="https://dpcfury.github.io/edit-distance.html/"/>
    <id>https://dpcfury.github.io/edit-distance.html/</id>
    <published>2020-04-06T01:50:05.000Z</published>
    <updated>2020-04-06T02:11:04.651Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">Leetcode 72. Edit Distance</a><br>经典的动态规划题目，求从一个字符串通过三种操作转换为另一个字符串的短编辑记录（最少的转换步骤），允许的操作包括：1. 插入；2. 删除；3. 替换。这题的核心是还是如何找一个收敛的入口，在问题规模缩小过程中，找到递推的规律，再通过自底向上或自顶向下的方式实现即可。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定的word1，word2，在极限情况下，假设word2位空字符串（长度为0），那么word1 转换为word2，需要进行word1.length()次删除操作。假设word1为空字符串（长度为0），需要进行word2.length（）次删除操作。这么一看，是不是有点递推边界的味道。<br>继续往下看，假设令dp[i][j] 为从word1的前i个字符转换为word2前j个字符所需的最短编辑记录，那么如何计算dp[i][j]：</p><ul><li>case1:  word1.charAt(i-1) == word2.charAt(j-1)，那么dp[i][j] = dp[i-1][j-1]</li><li>case2:  word1.charAt(i-1) != word2.charAt(j-1)：<ul><li>可能1: dp[i][j] = dp[i-1][j]+1  // 通过remove</li><li>可能2: dp[i][j] = dp[i][j-1] +1 // 通过insert或replace</li><li>可能3: dp[i][j] = dp[i-1][j-1]+1 //通过insert或replace</li></ul></li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1 == <span class="keyword">null</span> || word2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]), dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/edit-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 72. Edit Distance&lt;/a&gt;&lt;br&gt;经典的动态规划题目，求从一个字符串通过三种操作转换为另一个字符串的短编辑记录（最少的转换步骤），允许的操作包括：1. 插入；2. 删除；3. 替换。这题的核心是还是如何找一个收敛的入口，在问题规模缩小过程中，找到递推的规律，再通过自底向上或自顶向下的方式实现即可。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[46] LFU Cache</title>
    <link href="https://dpcfury.github.io/lfu-cache.html/"/>
    <id>https://dpcfury.github.io/lfu-cache.html/</id>
    <published>2020-04-05T15:53:02.000Z</published>
    <updated>2020-04-05T16:15:19.249Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/lfu-cache/" target="_blank" rel="noopener">Leetcode 46.  LFU Cache</a><br>题目要求实现计算机页面置换中经典的LFU算法，和LRU一字之别，但是含义完全不同，LFU即<br>Least Frequently Used，就是在缓存容量不够，需要置换的时候，替换策略是：将当前时间页面（key）访问次数最少的页面替换，然后将新的缓存更新。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>tip1: 考虑涉及到访问次数的统计</li><li>tip2: 题目要求在O(1)时间完成所有操作</li></ul><p>于是，首先会想到Map，将对应的key和响应的值进行映射，加快get的访问速率；此外，考虑不同访问频率的页面需要在O(1)进行找到和替换，那么需要很快找到对应的访问频率最低元素，这里设计一个<strong>{“frequency”:List<key>}</key></strong>映射。将每个访问频率的key缓存到一个优先队列（LinkedList中），新缓存的在队列尾部，时间久的在队列头部。在进行替换的过程中，首先剔除访问频率最小那个队列中，时间最久的key。<br>    在get访问中，对相应元素key进行访问频率升级，迁移到fre+1 队列中操作需要注意的是，put操作对相同key的更新，也需要进行一次get，从而更新访问频率。</p><p>实现算法如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> fre;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> fre)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.fre = fre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">         * LFUCache obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment">         * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment">         * obj.put(key,value);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> minFre; <span class="comment">// 出现的最小频率</span></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Integer, Item&gt; map; <span class="comment">//key对value索引</span></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; fre; <span class="comment">// key出现频率索引</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">            <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.fre = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 更新频率，返回值</span></span><br><span class="line">            Item item = map.get(key);</span><br><span class="line">            <span class="comment">// 找到频率列表，删除元素</span></span><br><span class="line">            LinkedList&lt;Integer&gt; oldFreList = fre.get(item.fre);</span><br><span class="line">            oldFreList.remove(Integer.valueOf(key));</span><br><span class="line">            <span class="comment">// 对应新的频率列表添加元素</span></span><br><span class="line">            LinkedList&lt;Integer&gt; newFreList = fre.computeIfAbsent(item.fre + <span class="number">1</span>, k -&gt; <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            newFreList.addLast(key);</span><br><span class="line">            item.fre++;</span><br><span class="line">            <span class="comment">//如果freq中频率为minFreq的list为空，minFreq自增1</span></span><br><span class="line">            <span class="keyword">if</span> (fre.get(minFre) == <span class="keyword">null</span> || fre.get(minFre).size() == <span class="number">0</span>) minFre++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> item.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (get(key) != -<span class="number">1</span>) <span class="comment">//更新也算访问一次</span></span><br><span class="line">                    map.get(key).val = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">                LinkedList&lt;Integer&gt; minList = fre.get(minFre);</span><br><span class="line">                <span class="keyword">int</span> k = minList.removeFirst();</span><br><span class="line">                map.remove(k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, <span class="keyword">new</span> Item(value, <span class="number">0</span>));</span><br><span class="line">            LinkedList&lt;Integer&gt; minList = fre.computeIfAbsent(<span class="number">0</span>, k -&gt; <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            minList.addLast(key);</span><br><span class="line">            minFre = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/lfu-cache/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 46.  LFU Cache&lt;/a&gt;&lt;br&gt;题目要求实现计算机页面置换中经典的LFU算法，和LRU一字之别，但是含义完全不同，LFU即&lt;br&gt;Least Frequently Used，就是在缓存容量不够，需要置换的时候，替换策略是：将当前时间页面（key）访问次数最少的页面替换，然后将新的缓存更新。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
      <category term="lfu" scheme="https://dpcfury.github.io/tags/lfu/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[42] Trapping Rain Water</title>
    <link href="https://dpcfury.github.io/trapping-rain-water.html/"/>
    <id>https://dpcfury.github.io/trapping-rain-water.html/</id>
    <published>2020-04-04T01:13:04.000Z</published>
    <updated>2020-04-04T01:21:43.136Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">Leetcode 42. Trapping Rain Water</a><br>题目给定一个整形数组，代表高低相间的柱状体，问下完雨之后，这些柱状体之间的缝隙空间能装载多少水。这里提供自己比较喜欢的一种直观解法，理解非常方便。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>从每个柱体进行考虑，这一格柱体能承载多少水，是由其左侧最高的柱体+ 右侧最高的柱体+本身的柱体高度决定，只要能计算出每个柱体能承载多少水，就能计算出总的盛水量。<br>实现方式：</p><ul><li>从左往右遍历，计算出每个柱体左边最高的柱体，记为leftMax[i]；</li><li>从右往左遍历，计算出每个柱体右侧最高的柱体，记为rightMax[i];</li><li>从迁往后遍历，计算每个柱体盛水量</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span> max1 = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            max1 = Math.max(max1, height[i]);</span><br><span class="line">            leftMax[i] = max1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max2 = height[height.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = height.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            max2 = Math.max(max2, height[j]);</span><br><span class="line">            rightMax[j] = max2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(leftMax[i], rightMax[i]);</span><br><span class="line">            <span class="keyword">if</span> (min &gt; height[i]) num += min - height[i];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/trapping-rain-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 42. Trapping Rain Water&lt;/a&gt;&lt;br&gt;题目给定一个整形数组，代表高低相间的柱状体，问下完雨之后，这些柱状体之间的缝隙空间能装载多少水。这里提供自己比较喜欢的一种直观解法，理解非常方便。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[8]String to Integer (atoi)</title>
    <link href="https://dpcfury.github.io/string-to-integer.html/"/>
    <id>https://dpcfury.github.io/string-to-integer.html/</id>
    <published>2020-04-03T14:41:07.000Z</published>
    <updated>2020-04-03T14:46:43.988Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">Leetcode 8. String to Integer (atoi)</a><br>题目要实现一个 atoi 函数，使其能将字符串转换成整数。确切的说，这种字符的类型五花八门，有很多中形式，除了正负号的判断，还需要判断数字的合法性，数字的长度是否超越32位整数的边界等，属于细节题，不做过多的描述，比较好的方式是不用借助太多的标记为，而是分阶段进行处理，先处理空格，再处理符号，再处理数字。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> negative=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(str.length()&gt;index &amp;&amp; str.charAt(index)==<span class="string">' '</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=str.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(index)==<span class="string">'+'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(index)==<span class="string">'-'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            negative=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index&gt;=str.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Character.isDigit(str.charAt(index))==<span class="keyword">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startIndex=index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> endIndex=startIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex; i&lt;str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)&gt;=<span class="string">'0'</span> &amp;&amp; str.charAt(i)&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">                endIndex++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex; i&lt;endIndex; i++) &#123;</span><br><span class="line">            num=(num*<span class="number">10</span>)+Double.parseDouble(Character.toString(str.charAt(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> (negative)?Integer.MIN_VALUE:Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> negative?(<span class="keyword">int</span>)(-<span class="number">1</span>*num):(<span class="keyword">int</span>)num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/string-to-integer-atoi/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 8. String to Integer (atoi)&lt;/a&gt;&lt;br&gt;题目要实现一个 atoi 函数，使其能将字符串转换成整数。确切的说，这种字符的类型五花八门，有很多中形式，除了正负号的判断，还需要判断数字的合法性，数字的长度是否超越32位整数的边界等，属于细节题，不做过多的描述，比较好的方式是不用借助太多的标记为，而是分阶段进行处理，先处理空格，再处理符号，再处理数字。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>todo-list</title>
    <link href="https://dpcfury.github.io/todo-list.html/"/>
    <id>https://dpcfury.github.io/todo-list.html/</id>
    <published>2020-04-03T07:55:08.000Z</published>
    <updated>2020-04-03T08:07:01.818Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>罗列平时工作学习中需要总结的内容，可以开拓视野的内容。因为来不及实践或总结成博客，暂时记个todo，方便有时间去尝试和整理。</p></blockquote><a id="more"></a><ol><li><p>Spring Boot 微服务应用集成Prometheus + Grafana 实现监控告警(reference :<a href="https://juejin.im/post/5e27acf6e51d4557ea363a65" target="_blank" rel="noopener">https://juejin.im/post/5e27acf6e51d4557ea363a65</a>)</p></li><li><p>python 垃圾回收</p></li><li><p>问题：一次web请求，所创建对象的垃圾回收和session相关的垃圾回收，首先了解拉垃圾对象的判别（核心）</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;罗列平时工作学习中需要总结的内容，可以开拓视野的内容。因为来不及实践或总结成博客，暂时记个todo，方便有时间去尝试和整理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="todo" scheme="https://dpcfury.github.io/categories/todo/"/>
    
    
  </entry>
  
  <entry>
    <title>内存泄漏和内存溢出</title>
    <link href="https://dpcfury.github.io/memory-leak-and-memory-overflow.html/"/>
    <id>https://dpcfury.github.io/memory-leak-and-memory-overflow.html/</id>
    <published>2020-04-03T06:35:50.000Z</published>
    <updated>2020-04-03T07:35:17.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>内存泄漏（Memory Leak）</strong>指的是申请了内存，但是在后续不用的时候没有进行释放，对程序而言这块内存一直处于占用状态。<br><strong>内存溢出（Memory Overflow）</strong>：指的是申请内存时，已经没有足够的内容可供使用；或者，给定一块内存，你却操作这块内存意外的地址空间，这时候就会OOM，即所谓的内存溢出。</p></blockquote><a id="more"></a><h4 id="二者关系"><a href="#二者关系" class="headerlink" title="二者关系"></a>二者关系</h4><p>内存泄漏的堆积最终必然会导致内存溢出，内存溢出就是需要的空间超过了系统所能分配给你的最大空间，此时系统无法满足分配器请求，就会报内存溢出的错误。<br>内存泄漏更倾向于是说，你申请了空间，但是没有在不使用的情况下释放，导致系统无法将这些空间分配给其他程序，也无法被gc进行回收。</p><h4 id="内存泄漏分类"><a href="#内存泄漏分类" class="headerlink" title="内存泄漏分类"></a>内存泄漏分类</h4><ol><li><p><strong>常发性内存泄漏</strong>：造成内存泄漏的代码经常被执行到，每次执行程序都会造成对应代码段的内存泄漏。</p></li><li><p><strong>偶发性内存泄漏</strong>：造成内存泄漏的代码段很少被执行到，只有在特定的环境和条件下执行某种操作才会发生。常发性和偶发性是相对的。在特定条件下，偶发的泄漏可能演化常发性的内存泄漏，所以需要考虑泄漏发生的条件和环境。</p></li><li><p><strong>一次性内存泄漏</strong>：在整个应用程序的生命周期中，造成内存泄漏的代码段只会执行一次，可能是由于算法、程序设计、加载机制上的缺陷，导致总会发生一次内存泄漏。例如在加载阶段的初始化分配内存，但是后续类一直需要使用，因此不使用的内存一直没有被释放。</p></li><li><p><strong>隐式内存泄漏</strong>：程序在执行过程中（例如处理web用户的一次查询请求），由于程序设计问题，不停的在请求分配内存，但是直到请求处理完成才能释放内存。严格来说，这里并不能成为内存泄漏，因为程序如果能吹完成请求会释放所申请的内存。但是对于程序而言，不断申请大量的内内存，并且不及时释放（相对及时），最终还是会导致系统的内存耗尽。因此，把这种泄漏行为成为隐式内存泄漏。</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>内存泄漏多处于程序设计原因，产生内存泄漏不一定会导致系统问题，但是内存泄漏的情况频繁、泄漏的内存较大，就会导致程序内存溢出，严重的会导致机器hang住，只能重启。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;内存泄漏（Memory Leak）&lt;/strong&gt;指的是申请了内存，但是在后续不用的时候没有进行释放，对程序而言这块内存一直处于占用状态。&lt;br&gt;&lt;strong&gt;内存溢出（Memory Overflow）&lt;/strong&gt;：指的是申请内存时，已经没有足够的内容可供使用；或者，给定一块内存，你却操作这块内存意外的地址空间，这时候就会OOM，即所谓的内存溢出。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发" scheme="https://dpcfury.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="内存泄漏" scheme="https://dpcfury.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="内存溢出" scheme="https://dpcfury.github.io/tags/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Mac下安装Mysql-Python</title>
    <link href="https://dpcfury.github.io/mac-mysql-python-installation.html/"/>
    <id>https://dpcfury.github.io/mac-mysql-python-installation.html/</id>
    <published>2020-04-03T03:00:34.000Z</published>
    <updated>2020-04-03T06:35:25.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>历史原因，接受项目的运行和调试基本放在开发测试机上，买了Pycharm之后，希望能借助本地的调试功能避免在开机上测试的时间成本，但是在本地安装依赖的过程中，发现着实遇到不少的坑，这次先说说安装的Mysql-python这个库。</p></blockquote><a id="more"></a><h4 id="Mysql-python"><a href="#Mysql-python" class="headerlink" title="Mysql-python"></a>Mysql-python</h4><p>MySQL-python又叫MySQLdb，是Python连接MySQL最流行的一个驱动，很多框架都也是基于此库进行开发，遗憾的是它只支持 Python2.x，而且安装的时候有很多前置条件，因为它是基于C开发的库，这意味着，你在不同的开发测试环境，可能需要安装额外的上游依赖。</p><p>系统环境：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -V</span><br><span class="line">$ Python 2.7.10</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sw_vers</span><br><span class="line">ProductName:  Mac OS X</span><br><span class="line">ProductVersion: 10.14.6</span><br><span class="line">BuildVersion:   18G103</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>首先使用Pycharm安装失败，然后转为手动到命令行安装，可以报错信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dupengcheng@dpc-MacBook ~ pip install MySQL-python</span><br><span class="line">DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won<span class="string">'t be maintained after that date. A future version of pip will drop support for Python 2.7.</span></span><br><span class="line"><span class="string">Collecting MySQL-python</span></span><br><span class="line"><span class="string">  Downloading https://files.pythonhosted.org/packages/a5/e9/51b544da85a36a68debe7a7091f068d802fc515a3a202652828c73453cad/MySQL-python-1.2.5.zip (108kB)</span></span><br><span class="line"><span class="string">    100% |████████████████████████████████| 112kB 3.1kB/s</span></span><br><span class="line"><span class="string">    Complete output from command python setup.py egg_info:</span></span><br><span class="line"><span class="string">    sh: mysql_config: command not found</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      File "&lt;string&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">      File "/private/var/folders/8h/kmnz1jj95s9g674q6vd1bmv40000gp/T/pip-install-DNT2Pa/MySQL-python/setup.py", line 17, in &lt;module&gt;</span></span><br><span class="line"><span class="string">        metadata, options = get_config()</span></span><br><span class="line"><span class="string">      File "setup_posix.py", line 43, in get_config</span></span><br><span class="line"><span class="string">        libs = mysql_config("libs_r")</span></span><br><span class="line"><span class="string">      File "setup_posix.py", line 25, in mysql_config</span></span><br><span class="line"><span class="string">        raise EnvironmentError("%s not found" % (mysql_config.path,))</span></span><br><span class="line"><span class="string">    EnvironmentError: mysql_config not found</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ----------------------------------------</span></span><br></pre></td></tr></table></figure></p><p>和Java中不同，python的mysql连接驱动依赖了部分c库实现，推测这里的mysql_config也是某个c库提供，于是goole一波，mysql_config 在 Mac 下是由 mysql-connector-c 提供的。</p><blockquote><p>diss 一波，联动的依赖管理和坑，给开发和后续维护埋了多少坑，2.7语言即将不支持，Mysql-Python也过于老旧，这种后续在客户侧升级演进隐藏的成本极高。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install mysql <span class="comment"># 非本地数据库可以不安装</span></span><br><span class="line">$ brew install mysql-connector-c</span><br></pre></td></tr></table></figure><p>安装mysql-connector-c之后，重新pip install<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won<span class="string">'t be maintained after that date. A future version of pip will drop support for Python 2.7.</span></span><br><span class="line"><span class="string">Collecting MySQL-python</span></span><br><span class="line"><span class="string">  Using cached https://files.pythonhosted.org/packages/a5/e9/51b544da85a36a68debe7a7091f068d802fc515a3a202652828c73453cad/MySQL-python-1.2.5.zip</span></span><br><span class="line"><span class="string">    Complete output from command python setup.py egg_info:</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      File "&lt;string&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">      File "/private/var/folders/8h/kmnz1jj95s9g674q6vd1bmv40000gp/T/pip-install-bQBOWl/MySQL-python/setup.py", line 17, in &lt;module&gt;</span></span><br><span class="line"><span class="string">        metadata, options = get_config()</span></span><br><span class="line"><span class="string">      File "setup_posix.py", line 53, in get_config</span></span><br><span class="line"><span class="string">        libraries = [ dequote(i[2:]) for i in libs if i.startswith(compiler_flag("l")) ]</span></span><br><span class="line"><span class="string">      File "setup_posix.py", line 8, in dequote</span></span><br><span class="line"><span class="string">        if s[0] in "\"'</span><span class="string">" and s[0] == s[-1]:</span></span><br><span class="line"><span class="string">    IndexError: string index out of range</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ----------------------------------------</span></span><br></pre></td></tr></table></figure></p><p>修改/usr/local/Cellar/mysql-connector-c/6.1.11/bin/mysql_config<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create options</span></span><br><span class="line">113 libs=<span class="string">"-L<span class="variable">$pkglibdir</span>"</span></span><br><span class="line">114 <span class="comment"># libs="$libs -l "</span></span><br><span class="line">115 libs=<span class="string">"<span class="variable">$libs</span> -lmysqlclient -lssl -lcrypto"</span></span><br></pre></td></tr></table></figure></p><p>再次pip isstall 一次，又出了新问题，提示库缺少，命名已经安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">13 warnings generated.</span><br><span class="line">    cc -bundle -undefined dynamic_lookup -Wl,-F. build/temp.macosx-10.14-intel-2.7/_mysql.o -L/usr/<span class="built_in">local</span>/Cellar/mysql-connector-c/6.1.11/lib -lmysqlclient -lssl -lcrypto -o build/lib.macosx-10.14-intel-2.7/_mysql.so</span><br><span class="line">    ld: library not found <span class="keyword">for</span> -lssl</span><br><span class="line">    clang: error: linker <span class="built_in">command</span> failed with <span class="built_in">exit</span> code 1 (use -v to see invocation)</span><br><span class="line">    error: <span class="built_in">command</span> <span class="string">'cc'</span> failed with <span class="built_in">exit</span> status 1</span><br></pre></td></tr></table></figure></p><p>没法了，继续google解决方案，尝试添加连接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LDFLAGS=<span class="string">"-I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib"</span></span><br></pre></td></tr></table></figure></p><p>再次安装，发现权限问题,加上sudo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo env LDFLAGS=<span class="string">"-I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib"</span> pip install Mysql-python</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collecting Mysql-python</span><br><span class="line">  Downloading https://files.pythonhosted.org/packages/a5/e9/51b544da85a36a68debe7a7091f068d802fc515a3a202652828c73453cad/MySQL-python-1.2.5.zip (108kB)</span><br><span class="line">    100% |████████████████████████████████| 112kB 5.3kB/s</span><br><span class="line">Installing collected packages: Mysql-python</span><br><span class="line">  Running setup.py install <span class="keyword">for</span> Mysql-python ... <span class="keyword">done</span></span><br><span class="line">Successfully installed Mysql-python-1.2.5</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>python在平台无关性上确实不如Java，环境的依赖管理尽管有pip这样的工具，但是实际的对操作系统依赖还是无法避免，在做代码移植上确实会存在问题。此外，遇到这种老版本依赖的升级，相比也会遇到更多的坑，这个在技术规划阶段就需要考虑，用的时候一时爽，后面维护火葬场。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;历史原因，接受项目的运行和调试基本放在开发测试机上，买了Pycharm之后，希望能借助本地的调试功能避免在开机上测试的时间成本，但是在本地安装依赖的过程中，发现着实遇到不少的坑，这次先说说安装的Mysql-python这个库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="django" scheme="https://dpcfury.github.io/categories/django/"/>
    
    
      <category term="开发" scheme="https://dpcfury.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="django" scheme="https://dpcfury.github.io/tags/django/"/>
    
      <category term="python" scheme="https://dpcfury.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[289] Game of Life</title>
    <link href="https://dpcfury.github.io/leetcode-game-of-life.html/"/>
    <id>https://dpcfury.github.io/leetcode-game-of-life.html/</id>
    <published>2020-04-02T14:44:34.000Z</published>
    <updated>2020-04-02T15:45:29.786Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener">Leetcode 289. Game of Life</a><br>题目给定一个二维面板，每个格子中的细胞存活由0，1代表，给定一定的繁衍规律，希望在面板上直接更新细胞的下一次存活状态。题目特别强调的是in-place修改，以及边界控制。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由于不能使用额外的存储空间标记细胞的上一轮状态，所以想到了，有没有社么办法，先在遍历过程中，将值做一个转换，在计算每个细胞的下一个状态时，同时还能保持记录上一轮状态。此时，题目的重点就是：如何提供一种编码方式，将细胞的更新值和上一轮状态保留，后续再进行一次遍历，即获取最终的值。</p><p>分析值变化情况：</p><ul><li>0 -&gt; 1 利用101标记，上一轮状态为0，更新状态为1</li><li>1 -&gt; 0 利用10 标记，上一轮状态为1，更新状态为0</li><li>0 -&gt; 0 不变</li><li>1 -&gt; 1 不变</li></ul><p>再加上八个方向的边界控制，题目的解法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> row = board.length;</span><br><span class="line">       <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">               <span class="keyword">int</span> numOfOne = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">int</span> numOfZero = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                   <span class="keyword">int</span> curX = i + dir[<span class="number">0</span>];</span><br><span class="line">                   <span class="keyword">int</span> curY = j + dir[<span class="number">1</span>];</span><br><span class="line">                   <span class="keyword">if</span> (inArea(curX, curY, row, col)) &#123;</span><br><span class="line">                       <span class="keyword">int</span> value = board[curX][curY];</span><br><span class="line">                       <span class="keyword">if</span> (value == <span class="number">1</span> || value == <span class="number">10</span>) numOfOne++;</span><br><span class="line">                       <span class="keyword">else</span> numOfZero++;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (board[i][j] == <span class="number">0</span> &amp;&amp; numOfOne == <span class="number">3</span>) board[i][j] = <span class="number">101</span>; <span class="comment">// 0-&gt;1</span></span><br><span class="line">               <span class="keyword">if</span> (board[i][j] == <span class="number">1</span> &amp;&amp; (numOfOne &lt; <span class="number">2</span> || numOfOne &gt; <span class="number">3</span>)) board[i][j] = <span class="number">10</span>; <span class="comment">// 1-&gt;0</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">               <span class="keyword">int</span> value = board[i][j];</span><br><span class="line">               <span class="keyword">if</span> (value == <span class="number">101</span>) board[i][j] = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span> (value == <span class="number">10</span>) board[i][j] = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= row) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (y &lt; <span class="number">0</span> || y &gt;= col) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/game-of-life/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 289. Game of Life&lt;/a&gt;&lt;br&gt;题目给定一个二维面板，每个格子中的细胞存活由0，1代表，给定一定的繁衍规律，希望在面板上直接更新细胞的下一次存活状态。题目特别强调的是in-place修改，以及边界控制。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="bit" scheme="https://dpcfury.github.io/tags/bit/"/>
    
  </entry>
  
  <entry>
    <title>django 启动 libmysqlclient_r.so.16找不到</title>
    <link href="https://dpcfury.github.io/django-libmysqlclient-error.html/"/>
    <id>https://dpcfury.github.io/django-libmysqlclient-error.html/</id>
    <published>2020-04-02T05:51:29.000Z</published>
    <updated>2020-04-02T06:03:29.870Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>问题：开发环境由于yum安装的mysql版本太低，卸载后从mysql官网下载rpm进行安装，正常设置mysql之后，在启动Django时，提示libmysqlclient_r.so.16找不到。</p></blockquote><a id="more"></a><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module: libmysqlclient_r.so.16: cannot open shared object file: No such file or directory.</p></blockquote><p>在网上找了不少回答，发现都是扯的很，最后发现的问题是，在通过rpm方式安装mysql时，使用的是mysql-rpm-bundle的版本，当时只安装了mysql-client和mysql-server。</p><p>完整的安装包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- -rw-r--r--  1 root root  285470720 Mar 31 19:53 MySQL-5.6.46-1.el6.x86_64.rpm-bundle.tar</span><br><span class="line">- -rw-r--r--  1 7155 31415  35528000 Sep 29  2019 MySQL-client-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415   6191888 Sep 29  2019 MySQL-devel-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415  98136984 Sep 29  2019 MySQL-embedded-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415  80628348 Sep 29  2019 MySQL-server-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415   3722376 Sep 29  2019 MySQL-shared-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415   3969752 Sep 29  2019 MySQL-shared-compat-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415  57279436 Sep 29  2019 MySQL-test-5.6.46-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>缺少libmysqlclient_r.so.16是因为MySQL-shared-compat-5.6.46-1.el6.x86_64.rpm没有安装，直接安装即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh MySQL-shared-compat-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">warning: MySQL-shared-compat-5.6.46-1.el6.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing...                <span class="comment">########################################### [100%]</span></span><br><span class="line">   1:MySQL-shared-compat    <span class="comment">########################################### [100%]</span></span><br><span class="line"></span><br><span class="line">[root@dpctest upload]<span class="comment"># find / -name libmysqlclient_r.so.16</span></span><br><span class="line">/usr/lib64/libmysqlclient_r.so.16</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;问题：开发环境由于yum安装的mysql版本太低，卸载后从mysql官网下载rpm进行安装，正常设置mysql之后，在启动Django时，提示libmysqlclient_r.so.16找不到。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="django" scheme="https://dpcfury.github.io/categories/django/"/>
    
    
      <category term="开发" scheme="https://dpcfury.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="django" scheme="https://dpcfury.github.io/tags/django/"/>
    
      <category term="mysql" scheme="https://dpcfury.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1111] Maximum Nesting Depth of Two Valid Parentheses Strings</title>
    <link href="https://dpcfury.github.io/Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings.html/"/>
    <id>https://dpcfury.github.io/Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings.html/</id>
    <published>2020-04-01T15:18:21.000Z</published>
    <updated>2020-04-01T15:59:09.464Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/" target="_blank" rel="noopener">Leetcode 1111. Maximum Nesting Depth of Two Valid Parentheses Strings</a><br>题目的描述很长，但是表达的意思我理解就是，怎么均分一下A B两个子括号，这边借用的是交替均分‘（’的方法，这题有点偏trick，👎的比例相对较高，不做过多细节描述。</p></blockquote><a id="more"></a><h4 id="方法一：用栈进行括号匹配"><a href="#方法一：用栈进行括号匹配" class="headerlink" title="方法一：用栈进行括号匹配"></a>方法一：用栈进行括号匹配</h4><p>思路及算法</p><p>要求划分出使得最大嵌套深度最小的分组，我们首先得知道如何计算嵌套深度。我们可以通过栈实现括号匹配来计算：</p><p>维护一个栈 s，从左至右遍历括号字符串中的每一个字符：</p><ul><li><p>如果当前字符是 (，就把 ( 压入栈中，此时这个 ( 的嵌套深度为栈的高度；</p></li><li><p>如果当前字符是 )，此时这个 ) 的嵌套深度为栈的高度，随后再从栈中弹出一个 (。</p></li></ul><p>下面给出了括号序列 (()(())()) 在每一个字符处的嵌套深度：</p><blockquote><p>括号序列   ( ( ) ( ( ) ) ( ) )<br>下标编号   0 1 2 3 4 5 6 7 8 9<br>嵌套深度   1 2 2 2 3 3 2 2 2 1 </p></blockquote><p>知道如何计算嵌套深度，问题就很简单了：只要在遍历过程中，我们保证栈内一半的括号属于序列 A，一半的括号属于序列 B，那么就能保证拆分后最大的嵌套深度最小，是当前最大嵌套深度的一半。要实现这样的对半分配，我们只需要把奇数层的 ( 分配给 A，偶数层的 ( 分配给 B 即可。对于上面的例子，我们将嵌套深度为 1 和 3 的所有括号 (()) 分配给 A，嵌套深度为 2 的所有括号 ()()() 分配给 B。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxDepthAfterSplit(String seq) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[seq.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, depth = <span class="number">0</span>; i &lt; seq.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                res[i] = depth++ &amp; <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = --depth &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：找规律"><a href="#方法二：找规律" class="headerlink" title="方法二：找规律"></a>方法二：找规律</h4><p>思路及算法</p><p>我们还是使用上面的例子 (()(())())，但这里我们把 ( 和 ) 的嵌套深度分成两行：</p><blockquote><p>括号序列   ( ( ) ( ( ) ) ( ) )<br>下标编号   0 1 2 3 4 5 6 7 8 9<br>嵌套深度   1 2 - 2 3 - - 2 - -<br>嵌套深度   - - 2 - - 3 2 - 2 1<br>有没有发现什么规律？</p></blockquote><ul><li><p>左括号 ( 的下标编号与嵌套深度的奇偶性相反，也就是说：</p><ul><li><p>下标编号为奇数的 (，其嵌套深度为偶数，分配给 B；</p></li><li><p>下标编号为偶数的 (，其嵌套深度为奇数，分配给 A。</p></li><li><p>右括号 ) 的下标编号与嵌套深度的奇偶性相同，也就是说：</p></li></ul></li><li><p>下标编号为奇数的 )，其嵌套深度为奇数，分配给 A；</p><ul><li><p>下标编号为偶数的 )，其嵌套深度为偶数，分配给 B。</p></li><li><p>这样以来，我们只需要根据每个位置是哪一种括号以及该位置的下标编号，就能确定将对应的对应的括号分到哪个组了。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1111. Maximum Nesting Depth of Two Valid Parentheses Strings&lt;/a&gt;&lt;br&gt;题目的描述很长，但是表达的意思我理解就是，怎么均分一下A B两个子括号，这边借用的是交替均分‘（’的方法，这题有点偏trick，👎的比例相对较高，不做过多细节描述。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="trick" scheme="https://dpcfury.github.io/tags/trick/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[322] Coin Change</title>
    <link href="https://dpcfury.github.io/leetcode-coin-change.html/"/>
    <id>https://dpcfury.github.io/leetcode-coin-change.html/</id>
    <published>2020-04-01T15:06:32.000Z</published>
    <updated>2020-04-01T15:16:22.315Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">Leetcode 322. Coin Change</a><br>经典的找零问题，遇到此类问题，首先分析是否可以缩小amount的规模，来找到子问题（最优子结构），然后自顶向下分析，推导出递归表达式，再写出对应的自顶向下或者自底向上代码。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>令F(amount) 为拼凑amount需要的最少硬币数量，那么F(amount) = min(F(amout-coin[i]))中来的，得到这样的一个递归后，就可将问题一步步拆解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i &amp;&amp; dp[i - coins[j]] != -<span class="number">1</span>)<span class="comment">//之前能满足</span></span><br><span class="line">                    min = Math.min(dp[i - coins[j]] + <span class="number">1</span>, min);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = min == Integer.MAX_VALUE ? -<span class="number">1</span> : min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/coin-change/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 322. Coin Change&lt;/a&gt;&lt;br&gt;经典的找零问题，遇到此类问题，首先分析是否可以缩小amount的规模，来找到子问题（最优子结构），然后自顶向下分析，推导出递归表达式，再写出对应的自顶向下或者自底向上代码。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot统一异常处理实践</title>
    <link href="https://dpcfury.github.io/spring-boot-exception-handling.html/"/>
    <id>https://dpcfury.github.io/spring-boot-exception-handling.html/</id>
    <published>2020-04-01T11:14:57.000Z</published>
    <updated>2020-04-01T12:09:55.870Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在web开发中，经常需要处理各类异常情况，这种处理逻辑经常会被分散在代码的各个层次，导致异常的处理和业务逻辑混杂，后续重构代价升高，前后端交互成本提高，不利用系统的持续演进。本文针对工作中遇到的不良实践进行总结，试图找寻一种可以解决大部分问题的工程实践方案。</p></blockquote><a id="more"></a><h4 id="核心关注点"><a href="#核心关注点" class="headerlink" title="核心关注点"></a>核心关注点</h4><p>对异常的处理，总结先来，主要有三个核心的关注点：</p><ul><li>在什么时候，什么地方捕获异常（try-catch），什么时候需要抛出（throws）异常</li><li>在DAO、Service还是在Controller层次进行捕获</li><li>抛出一场后，如何处理，如何向前端返回错误</li></ul><h4 id="工作中遇到的反例"><a href="#工作中遇到的反例" class="headerlink" title="工作中遇到的反例"></a>工作中遇到的反例</h4><p>以个人在工作中接触的一个django项目为例，其业务逻辑都集中在view.py文件中，通过装饰器，将返回内容统一转换为json形式进行返回，系统在异常处理存在的问题集中体现在：</p><ul><li>分散在业务各处的返回信息处理</li><li>满大街的try-catch，可能一层套一层</li><li>混乱的返回方式</li></ul><p>后端和前端约定返回结果形式：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message"</span>:<span class="string">"ok"</span>,</span><br><span class="line">    <span class="attr">"data"</span>:[],</span><br><span class="line">    <span class="attr">"success"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>分散的返回处理</strong><br>即返回结果的处理没有统一的入口，可能分散在代码的多个层次中，导致返回信息的组织和业务逻辑交织在一起，代码逻辑非常不清晰，其次，会导致返回信息不对的情况下，排查人力投入明显增加。经常看到返回的结果message对应的从约定的”ok”变成了其他的词，”success”也出现五花八门的返回结果。</p><p><strong>满大街的try-catch</strong><br>在代码的不同层次，你都能找到活多或少的try-cath处理段，过多的try-catch 导致业务代码分割严重，也增加了对应处理逻辑，导致系统的复杂度上升，后续维护重构举步维艰。</p><p><strong>混乱的返回方式</strong><br>在spring-mvc中，返回统一在controller层次，第一层的函数就负责了结果的返回，但是接触到的django项目，它的返回逻辑甚至能在入口跳转6次的函数中，没有统一的处理入口，出了问题需要到处排查，前后端要一起折腾。</p><p><strong>总结</strong><br>当前项目的异常处理方式非常失败，处于xx原因，就不好列举代码了。</p><h4 id="异常处理规范"><a href="#异常处理规范" class="headerlink" title="异常处理规范"></a>异常处理规范</h4><p>为了进行统一的异常处理，一般会约定异常处理规范，这里不仅仅是将结果形式定义了就完事了，还得通过前后端各种工程实践将这个规范践行下去。</p><h4 id="原则一：-不捕获任何异常"><a href="#原则一：-不捕获任何异常" class="headerlink" title="原则一： 不捕获任何异常"></a>原则一： 不捕获任何异常</h4><p>根据大佬们的实践经验，不再对与业务逻辑和数据处理中的异常进行捕获，即将DAO、Service、Controller中所有的异常全部抛出到上层，从而不眠代码中一堆的try-catch，减少维护的难度。</p><h4 id="原则二：统一返回结果集"><a href="#原则二：统一返回结果集" class="headerlink" title="原则二：统一返回结果集"></a>原则二：统一返回结果集</h4><p>这个原则很多开发实践都已经明确，就是按照统一的一个格式进行结果返回，返回结果中应该起码包含请求的处理状态标志，此外用一层数组包装查询的结果。</p><p>而在spring-boot(mvc)架构中，通常会定义一个Java的DTO对象，用来进行统一的结果返回，for example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code; <span class="comment">// 统一协商的状态码</span></span><br><span class="line">    <span class="keyword">private</span> String message; <span class="comment">// 携带的额外提示信息</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;T&gt; data; <span class="comment">// 请求返回的数据集</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ResultBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultBean <span class="title">error</span><span class="params">(<span class="keyword">int</span> code, String message)</span> </span>&#123;</span><br><span class="line">        ResultBean resultBean = <span class="keyword">new</span> ResultBean();</span><br><span class="line">        resultBean.setCode(code);</span><br><span class="line">        resultBean.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> resultBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultBean <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ResultBean resultBean = <span class="keyword">new</span> ResultBean();</span><br><span class="line">        resultBean.setCode(<span class="number">0</span>);</span><br><span class="line">        resultBean.setMessage(<span class="string">"success"</span>);</span><br><span class="line">        <span class="keyword">return</span> resultBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function">ResultBean&lt;V&gt; <span class="title">success</span><span class="params">(Collection&lt;V&gt; data)</span> </span>&#123;</span><br><span class="line">        ResultBean resultBean = <span class="keyword">new</span> ResultBean();</span><br><span class="line">        resultBean.setCode(<span class="number">0</span>);</span><br><span class="line">        resultBean.setMessage(<span class="string">"success"</span>);</span><br><span class="line">        resultBean.setData(data);</span><br><span class="line">        <span class="keyword">return</span> resultBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter / setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而，在成功的情况下，只需要返回ResultBean.success() 或 ResultBean.success(Collection<v> data)需要返回数据按照下面的形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/host/add"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultBean&lt;Goods&gt; <span class="title">getAllHosts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Host&gt; hosts = hostService.findAll();</span><br><span class="line">    <span class="keyword">return</span> ResultBean.success(hosts);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/host/update"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultBean <span class="title">updatehosts</span><span class="params">(Host hosts)</span> </span>&#123;</span><br><span class="line">    hostsService.update(host);</span><br><span class="line">    <span class="keyword">return</span> ResultBean.success();</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></v></p><p>只有查询方法需要调用 ResultBean.success(Collection<v> data) 来返回 N 条数据, 删除, 修改等方法都应该调用 ResultBean.success(), 即在业务代码中只处理正确的功能, 不对异常做任何判断. 也不需要对 update 或 delete 的更新条数做判断. 只要没有抛出异常, 就等价于用户请求处理成功，再加足够的日志即可，且操作成功的提示信息在前端处理, 不要后台返回 “操作成功” 等字段，这种设计在国际化的时候能减轻不少的工作量。</v></p><p>前台接受的json for example：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"success"</span>,</span><br><span class="line">    <span class="string">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"sn"</span>: <span class="string">"xxxx"</span>,</span><br><span class="line">            <span class="string">"hostname"</span>: <span class="string">"xxxxx"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"sn"</span>: <span class="string">"xxxx"</span>,</span><br><span class="line">            <span class="string">"hostname"</span>: <span class="string">"xxxx"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在后端报错情况下，在后端统一调用ResultBean.error(int code, String message), 来将状态码和错误信息返回, 我们约定 code 为 0 表示操作成功, 1 标示系统错误， 2标示 参数错误（协商解决）</li></ul><p>前台收到错误结果后，只要根据对应的错误code进行相应的提示信息弹出即可。</p><h4 id="后端统一异常处理"><a href="#后端统一异常处理" class="headerlink" title="后端统一异常处理"></a>后端统一异常处理</h4><p>这里是最重点的地方，spring-boot（mvc）开发的web应用中，如何进行统一的异常处理呢，spring利用AOP，提供了一种@Advice的处理方式，我们所有的异常只要能保证抛出到controller层次， 就能由统一的Advice进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(RequestExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultBean <span class="title">unknownSn</span><span class="params">(UnknownSntException e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"机器sn不存在"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(<span class="number">1</span>, <span class="string">"sn不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultBean <span class="title">incorrectMac</span><span class="params">(IncorrectMacException e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"mac地址不对"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(-<span class="number">2</span>, <span class="string">"mac地址错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultBean <span class="title">unknownException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"内部错误"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(-<span class="number">99</span>, <span class="string">"系统出现错误，联系管理员处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>不要满大街的try-catch</li><li>统一返回值，集中异常的处理逻辑</li><li>认真对待写的代码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在web开发中，经常需要处理各类异常情况，这种处理逻辑经常会被分散在代码的各个层次，导致异常的处理和业务逻辑混杂，后续重构代价升高，前后端交互成本提高，不利用系统的持续演进。本文针对工作中遇到的不良实践进行总结，试图找寻一种可以解决大部分问题的工程实践方案。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发" scheme="https://dpcfury.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
      <category term="spring-boot" scheme="https://dpcfury.github.io/categories/%E5%BC%80%E5%8F%91/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="https://dpcfury.github.io/tags/spring-boot/"/>
    
      <category term="工程实践" scheme="https://dpcfury.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://dpcfury.github.io/sorting.html/"/>
    <id>https://dpcfury.github.io/sorting.html/</id>
    <published>2020-03-31T14:11:02.000Z</published>
    <updated>2020-03-31T15:54:32.613Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>十大排序算法可以说是每个程序员都必须得掌握的了，为了方便个人复习和总结，把它整理成一篇独立文章，每种算法会有简单的算法思想描述，为了方便大家理解，从网上搜集了动图演示。</p></blockquote><a id="more"></a><ul><li>选择排序</li><li>插入排序</li><li>冒泡排序</li><li>非优化版本</li><li>优化版本</li><li>希尔排序</li><li>归并排序</li><li>递归式归并排序</li><li>非递归式归并排序</li><li>快速排序</li><li>堆排序</li><li>基数排序</li><li>非优化版本</li><li>优化版本</li><li>桶排序</li><li>基数排序</li></ul><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>过程简单描述：</strong> 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为选择排序。</p><p><img src="https://pic1.zhimg.com/v2-f20b8898585b3ca03843d93ce2c35a68_b.gif" alt="选择排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[min]) min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[min];</span><br><span class="line">            nums[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="https://zhuanlan.zhihu.com/p/57088609" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57088609</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;十大排序算法可以说是每个程序员都必须得掌握的了，为了方便个人复习和总结，把它整理成一篇独立文章，每种算法会有简单的算法思想描述，为了方便大家理解，从网上搜集了动图演示。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="sorting" scheme="https://dpcfury.github.io/tags/sorting/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1218] Longest Arithmetic Subsequence of Given Difference</title>
    <link href="https://dpcfury.github.io/longest-arithmetic-subsequence-of-given-difference.html/"/>
    <id>https://dpcfury.github.io/longest-arithmetic-subsequence-of-given-difference.html/</id>
    <published>2020-03-30T15:14:37.000Z</published>
    <updated>2020-03-30T15:20:26.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/" target="_blank" rel="noopener">Leetcode 1218. Longest Arithmetic Subsequence of Given Difference</a><br>题目阅读下来，看到子序列这种问题，立马就会想到动态规划，首先会去想如何缩小问题的规模。从这个差来看，对于每一个遍历的数n而言，如果能知道以 n-difference结尾的子序列长度，就能计算以n为结尾的子序列长度，由于差值不是坐标，可以用HashMap存储dp的中间值。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">       map.put(arr[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (map.containsKey(arr[i] - difference)) &#123;</span><br><span class="line">               map.put(arr[i], map.get(arr[i] - difference) + <span class="number">1</span>);</span><br><span class="line">               max = Math.max(map.get(arr[i]), max);</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               map.put(arr[i], <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1218. Longest Arithmetic Subsequence of Given Difference&lt;/a&gt;&lt;br&gt;题目阅读下来，看到子序列这种问题，立马就会想到动态规划，首先会去想如何缩小问题的规模。从这个差来看，对于每一个遍历的数n而言，如果能知道以 n-difference结尾的子序列长度，就能计算以n为结尾的子序列长度，由于差值不是坐标，可以用HashMap存储dp的中间值。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>力扣中国[62] Joseph Circle Problem</title>
    <link href="https://dpcfury.github.io/joseph-circle-problem.html/"/>
    <id>https://dpcfury.github.io/joseph-circle-problem.html/</id>
    <published>2020-03-30T13:46:19.000Z</published>
    <updated>2020-03-30T14:00:09.357Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指offer Joseph Problem</a><br>题目不用多介绍，经典的约瑟夫环问题，求解的过程主要包含两种。一种是直观的构造循环链表，通过多次多次遍历，求的最终结果，时间复杂度为O(mn),另一种就是通过数学分析，找出递归的规律，然后使用递归或者动归求解。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>令f(n-1,m) 为n-1个人，报数m，最终留下的胜者坐标，那么f(n,m)的的胜者同样是f(n-1,m)胜者，但是其下坐标遍了，那么上一轮中胜者的坐标对应应该是(f(n-1,m)+m) % n</p><p>即关系式为：f(n,m) = (f(n-1,m)+m) % n</p><p>针对0和1个数的情况，胜者坐标都为0<br>因此解法可写为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp = (dp + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>对于这个推到技巧，在知乎看到这么一个总结，感觉比较实用</p></blockquote><p>递归问题分3步走：<br>1、递归收敛：由于m是不变的，所以只能通过n将规模不断缩小<br>2、找出口：当递归收敛到最小单位时，能得到一个出口。即当n=1时，胜者的位置为0<br>3、找规律：分析已知条件，与我们需要结果的关联。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指offer Joseph Problem&lt;/a&gt;&lt;br&gt;题目不用多介绍，经典的约瑟夫环问题，求解的过程主要包含两种。一种是直观的构造循环链表，通过多次多次遍历，求的最终结果，时间复杂度为O(mn),另一种就是通过数学分析，找出递归的规律，然后使用递归或者动归求解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="Math" scheme="https://dpcfury.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1162] As Far from Land as Possible</title>
    <link href="https://dpcfury.github.io/leetcode-as-far-from-land-as-possible.html/"/>
    <id>https://dpcfury.github.io/leetcode-as-far-from-land-as-possible.html/</id>
    <published>2020-03-29T13:44:36.000Z</published>
    <updated>2020-03-29T13:49:56.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">Leetcode 1162. As Far from Land as Possible</a><br>题目的意思需要多读几次，最终的目的就是求离陆地最远的海洋距离。这类题目可以属于一道简单的bfs题目。leetcode中海洋陆地问题的题目很多，大多都是bfs或是dfs题目。这里再简单啰嗦一下bfs的思路。首先我们选取一些特征一致的点作为起始目标，然后从这些目标开始向四周扩散一步，四周的点只要在数组边界之内并且其特征与初始特征不一致，我们就将其变为与起始点同一特征（染色）。同时将这些新染色的点作为起始再向四周扩散一步，执行相同操作，直到全部同化完成。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>先找出所有陆地的坐标，作为bfs的起始条件。</li><li>通过所有的陆地坐标向外bfs。直到找到最后一块海洋为止。这期间所用到的步数即是答案，也即从某个初始点扩散到这块海洋，所需要的最长距离。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">int</span> dist;</span><br><span class="line"></span><br><span class="line">        Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dist) &#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.dist = dist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length;</span><br><span class="line">        <span class="keyword">int</span> maxDistance = -<span class="number">1</span>;</span><br><span class="line">        Queue&lt;Point&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Point(i, j, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有陆地或者全是陆地，直接返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (queue.size() == <span class="number">0</span> || queue.size() == n * n) <span class="keyword">return</span> maxDistance;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Point p = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (p.x &lt; <span class="number">0</span> || p.x &gt; grid.length - <span class="number">1</span> || p.y &lt; <span class="number">0</span> || p.y &gt; grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[p.x][p.y]) &#123;</span><br><span class="line">                visited[p.x][p.y] = <span class="keyword">true</span>;</span><br><span class="line">                maxDistance = Math.max(maxDistance, p.dist);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                    <span class="keyword">int</span> curX = p.x + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> curY = p.y + dir[<span class="number">1</span>];</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Point(curX, curY, p.dist+ <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDistance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/as-far-from-land-as-possible/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1162. As Far from Land as Possible&lt;/a&gt;&lt;br&gt;题目的意思需要多读几次，最终的目的就是求离陆地最远的海洋距离。这类题目可以属于一道简单的bfs题目。leetcode中海洋陆地问题的题目很多，大多都是bfs或是dfs题目。这里再简单啰嗦一下bfs的思路。首先我们选取一些特征一致的点作为起始目标，然后从这些目标开始向四周扩散一步，四周的点只要在数组边界之内并且其特征与初始特征不一致，我们就将其变为与起始点同一特征（染色）。同时将这些新染色的点作为起始再向四周扩散一步，执行相同操作，直到全部同化完成。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="BFS" scheme="https://dpcfury.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[423] Reconstruct Original Digits from English</title>
    <link href="https://dpcfury.github.io/reconstruct-original-digits-from-english.html/"/>
    <id>https://dpcfury.github.io/reconstruct-original-digits-from-english.html/</id>
    <published>2020-03-29T05:49:52.000Z</published>
    <updated>2020-03-29T06:08:49.856Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/reconstruct-original-digits-from-english/" target="_blank" rel="noopener">423. Reconstruct Original Digits from English</a><br>题目的意思第一遍读，以为是和编解码同类型的题目，想用回溯去尝试，后来发现给定的一个条件是input长度小于5000，那就说明可能存在重复的数字，回溯走不通。再看看discuss，发现这题主要是在找规律，即分析每个数字英文所包含的字母和其对应关系，再从input中判断特征字母的出现次数，计算每个数字的出现次数。</p></blockquote><a id="more"></a><p>如果我们用numbers数组存储出现的数字个数，其中下标表示着对应0-9的数字，那么我们会有下面这个结果：</p><table><thead><tr><th>数字</th><th>数字的个数</th></tr></thead><tbody><tr><td>0</td><td>numbers[0] = ‘z’的个数</td></tr><tr><td>2</td><td>numbers[2] = ‘w’的个数</td></tr><tr><td>4</td><td>numbers[4] = ‘u’的个数</td></tr><tr><td>6</td><td>numbers[6] = ‘x’的个数</td></tr><tr><td>8</td><td>numbers[8] = ‘g’的个数</td></tr></tbody></table><p>而其他的数字个数，比如5的个数，因为‘f’的数目由four和five的数目组成，而我们已知four的数目为numbers[4]，所以numbers[5] = ‘f’的个数-number[4]。其他的数字同样处理。<br>最后得到了下面的映射关系：</p><table><thead><tr><th>数字</th><th>数字的个数</th></tr></thead><tbody><tr><td>5</td><td>numbers[5] = ‘f’的个数 - numbers[4]</td></tr><tr><td>3</td><td>numbers[3] = ‘h’的个数 - numbers[8]</td></tr><tr><td>7</td><td>numbers[7] = ‘s’的个数 - numbers[6]</td></tr><tr><td>1</td><td>numbers[1] = ‘o’的个数 - numbers[0] - numbers[2] - numbers[4]</td></tr><tr><td>9</td><td>numbers[9] = ‘i’的个数 - numbers[5] - numbers[6] - numbers[8]</td></tr></tbody></table><p>于是乎，代码写成下面这种格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">originalDigits</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            count.put(c, count.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[<span class="number">8</span>] = count.getOrDefault(<span class="string">'g'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">6</span>] = count.getOrDefault(<span class="string">'x'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">4</span>] = count.getOrDefault(<span class="string">'u'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">2</span>] = count.getOrDefault(<span class="string">'w'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">0</span>] = count.getOrDefault(<span class="string">'z'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">5</span>] = count.getOrDefault(<span class="string">'f'</span>, <span class="number">0</span>) - nums[<span class="number">4</span>];</span><br><span class="line">        nums[<span class="number">3</span>] = count.getOrDefault(<span class="string">'h'</span>, <span class="number">0</span>) - nums[<span class="number">8</span>];</span><br><span class="line">        nums[<span class="number">7</span>] = count.getOrDefault(<span class="string">'s'</span>, <span class="number">0</span>) - nums[<span class="number">6</span>];</span><br><span class="line">        nums[<span class="number">1</span>] = count.getOrDefault(<span class="string">'o'</span>, <span class="number">0</span>) - nums[<span class="number">0</span>] - nums[<span class="number">2</span>] - nums[<span class="number">4</span>];</span><br><span class="line">        nums[<span class="number">9</span>] = count.getOrDefault(<span class="string">'i'</span>, <span class="number">0</span>) - nums[<span class="number">5</span>] - nums[<span class="number">6</span>] - nums[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                str.append((<span class="keyword">char</span>) (<span class="string">'0'</span> + i));</span><br><span class="line">                nums[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>看到discuss中有给出的拓扑排序解法，但是这题给人的感觉更倾向于找规律，因此不再讨论另外的解法。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reconstruct-original-digits-from-english/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;423. Reconstruct Original Digits from English&lt;/a&gt;&lt;br&gt;题目的意思第一遍读，以为是和编解码同类型的题目，想用回溯去尝试，后来发现给定的一个条件是input长度小于5000，那就说明可能存在重复的数字，回溯走不通。再看看discuss，发现这题主要是在找规律，即分析每个数字英文所包含的字母和其对应关系，再从input中判断特征字母的出现次数，计算每个数字的出现次数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[820] Short Encoding of Words</title>
    <link href="https://dpcfury.github.io/leetcode-short-encoding-of-words.html/"/>
    <id>https://dpcfury.github.io/leetcode-short-encoding-of-words.html/</id>
    <published>2020-03-28T12:44:24.000Z</published>
    <updated>2020-03-28T13:03:46.304Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">Leetcode 820. Short Encoding of Words</a><br>题目给出一组字符串数组，计算最短的编码字符串长度。编码的方式就是通过‘#‘号分割，再加一个索引，能够从编码字符串中解码初原始字符串。读一下题目，大致可以知道这题的意思是和后缀有关，因为如果一个单词是其他单词的后缀，它的长度肯定不会被计算入加密字符串。因此，先给字符串数组排个序，让长的字符串在前，短的在后，通过每次比较当前字符串和已构造的加密字符对比，含是否是已有字符串的后缀。</p></blockquote><a id="more"></a><h4 id="approach-1"><a href="#approach-1" class="headerlink" title="approach 1"></a>approach 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="keyword">null</span> | words.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[words.length];</span><br><span class="line">        Arrays.sort(words, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.length() - o1.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) strs[i] = words[i] + <span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = strs[i - <span class="number">1</span>].indexOf(words[i]);</span><br><span class="line">                <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123; <span class="comment">// 看能否匹配到#</span></span><br><span class="line">                    <span class="keyword">if</span> (strs[i - <span class="number">1</span>].charAt(index + words[i].length()) == <span class="string">'#'</span>) &#123;</span><br><span class="line">                        strs[i] = strs[i - <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                strs[i] = strs[i - <span class="number">1</span>] + words[i] + <span class="string">'#'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[words.length - <span class="number">1</span>].length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="approach-2"><a href="#approach-2" class="headerlink" title="approach 2"></a>approach 2</h4><blockquote><p>从leetcode 官网给的solution也可以看出来，既然本质是剔除那些本身是其他单词后缀的单词。提到后缀，其实变相的就是逆前缀，而提到前缀就会想到Trie字典树，字典树的分支就是26个字母分叉，对于不是其他单词后缀的单词，其对应在字典树中一定能从根遍历到叶子结点。因此遍历字符串数组的过程中，可以去构造逆向的前缀树，然后统计能走到叶子结点的字符串长度和即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        TrieNode trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        Map&lt;TrieNode, Integer&gt; nodes = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; ++i) &#123;</span><br><span class="line">            String word = words[i];</span><br><span class="line">            TrieNode cur = trie;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = word.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                cur = cur.get(word.charAt(j));</span><br><span class="line">            nodes.put(cur, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (TrieNode node: nodes.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.count == <span class="number">0</span>) <span class="comment">// 走到叶子结点</span></span><br><span class="line">                ans += words[nodes.get(node)].length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (children[c-<span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            children[c-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> children[c - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/short-encoding-of-words/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 820. Short Encoding of Words&lt;/a&gt;&lt;br&gt;题目给出一组字符串数组，计算最短的编码字符串长度。编码的方式就是通过‘#‘号分割，再加一个索引，能够从编码字符串中解码初原始字符串。读一下题目，大致可以知道这题的意思是和后缀有关，因为如果一个单词是其他单词的后缀，它的长度肯定不会被计算入加密字符串。因此，先给字符串数组排个序，让长的字符串在前，短的在后，通过每次比较当前字符串和已构造的加密字符对比，含是否是已有字符串的后缀。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="tries" scheme="https://dpcfury.github.io/tags/tries/"/>
    
      <category term="suffix" scheme="https://dpcfury.github.io/tags/suffix/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[914] X of a Kind in a Deck of Cards</title>
    <link href="https://dpcfury.github.io/leetcode-x-of-a-kind-in-a-deck.html/"/>
    <id>https://dpcfury.github.io/leetcode-x-of-a-kind-in-a-deck.html/</id>
    <published>2020-03-27T13:17:06.000Z</published>
    <updated>2020-03-27T13:22:16.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/" target="_blank" rel="noopener">Leetcode 914. X of a Kind in a Deck of Cards</a><br>题目的直白含义就是：给出一堆数组，判断是否有一种划分方式，让每个分组内的元素都相同，每个组的元素个数页相同。暴力的解法比较直观，但是背后的含义其实是：对于每一种的牌的数量Ni，如果能够满足按x进行分组，那么Ni % x ==0,那么对于不同种类的牌而言，是否存在x这种划分，就变成，这组牌的数量的最大公约数是否满足大于等于 2，由此变为如何求一组数的最大公约数。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : deck) count.put(i, count.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> g = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (g == -<span class="number">1</span>) &#123;</span><br><span class="line">               g = entry.getValue();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               g = gcd(g, entry.getValue());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> g &gt;= <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> y;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> gcd(y % x, x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 914. X of a Kind in a Deck of Cards&lt;/a&gt;&lt;br&gt;题目的直白含义就是：给出一堆数组，判断是否有一种划分方式，让每个分组内的元素都相同，每个组的元素个数页相同。暴力的解法比较直观，但是背后的含义其实是：对于每一种的牌的数量Ni，如果能够满足按x进行分组，那么Ni % x ==0,那么对于不同种类的牌而言，是否存在x这种划分，就变成，这组牌的数量的最大公约数是否满足大于等于 2，由此变为如何求一组数的最大公约数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="gcd" scheme="https://dpcfury.github.io/tags/gcd/"/>
    
  </entry>
  
</feed>
