<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DPC&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/bfa2adcbfd5883f9905426b1399816ee</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dpcfury.github.io/"/>
  <updated>2020-03-26T14:41:07.426Z</updated>
  <id>https://dpcfury.github.io/</id>
  
  <author>
    <name>杜鹏程</name>
    <email>dpcspark@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode[999] Available Captures for Rook</title>
    <link href="https://dpcfury.github.io/available-captures-for-root.html/"/>
    <id>https://dpcfury.github.io/available-captures-for-root.html/</id>
    <published>2020-03-26T14:37:54.000Z</published>
    <updated>2020-03-26T14:41:07.426Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/available-captures-for-rook/" target="_blank" rel="noopener">999. Available Captures for Rook</a> 题目要求8x8的棋局上，Rook上下左右移动可以补货的黑色卒数量，只要遍历上下左右位置即可。实际题目并没有什么含量，奈何把黑色卒缩写理解成‘B’,稍微折腾了一下，并给题目点了个👎。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> canCapture(board, row, col, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">canCapture</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> up = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (up &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[up][j];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                up--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; col) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[i][right];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[i][left];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> down = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (down &lt; row) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[down][j];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                down++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/available-captures-for-rook/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;999. Available Captures for Rook&lt;/a&gt; 题目要求8x8的棋局上，Rook上下左右移动可以补货的黑色卒数量，只要遍历上下左右位置即可。实际题目并没有什么含量，奈何把黑色卒缩写理解成‘B’,稍微折腾了一下，并给题目点了个👎。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[92] Reverse Linked List II</title>
    <link href="https://dpcfury.github.io/leetcode-reverse-linked-list-II.html/"/>
    <id>https://dpcfury.github.io/leetcode-reverse-linked-list-II.html/</id>
    <published>2020-03-25T13:35:07.000Z</published>
    <updated>2020-03-25T13:41:06.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">Leetcode 92. Reverse Linked List II</a><br>题目要求在一次遍历完成对链表中m-n的元素进行反转，由于是单链表，涉及到这种顺序的饭庄，首先会想到栈，将m-n的元素放入栈中，再记录m-1个元素的位置，通过出栈再重新链接，即可得到反转后的链表。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        ListNode before = newHead;</span><br><span class="line">        ListNode p = newHead;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            before = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count == m) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt;= n &amp;&amp; p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.add(p);</span><br><span class="line">            p = p.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            ListNode node = stack.pop();</span><br><span class="line">            before.next = node;</span><br><span class="line">            before = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        before.next = p;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 92. Reverse Linked List II&lt;/a&gt;&lt;br&gt;题目要求在一次遍历完成对链表中m-n的元素进行反转，由于是单链表，涉及到这种顺序的饭庄，首先会想到栈，将m-n的元素放入栈中，再记录m-1个元素的位置，通过出栈再重新链接，即可得到反转后的链表。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="linkedlist" scheme="https://dpcfury.github.io/tags/linkedlist/"/>
    
      <category term="stack" scheme="https://dpcfury.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[543] Diameter of Binary Tree</title>
    <link href="https://dpcfury.github.io/leetcode-diameter-of-binary-tree.html/"/>
    <id>https://dpcfury.github.io/leetcode-diameter-of-binary-tree.html/</id>
    <published>2020-03-25T11:55:19.000Z</published>
    <updated>2020-03-25T13:49:13.835Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. Diameter of Binary Tree</a><br>题目要求二叉树的最大直径，所谓直径就是这颗树的任意两个叶子结点连接，所能经过的最多节点数。分析这个路径的可能构成情况，可能是存在于左子树、右子树，或者存在于左右子树+根节点。所以对于当前任意节点，这颗树的最大直径，可以分为包含这个节点的路径情况：即左右子树高度+1，不包含的情况，即左子树的最大直径、或右子树的最大直径。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = getDepth(root.left) + getDepth(root.right);</span><br><span class="line">        <span class="keyword">int</span> leftMax = diameterOfBinaryTree(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightMax = diameterOfBinaryTree(root.right);</span><br><span class="line">        <span class="keyword">if</span> (leftMax &gt; max)</span><br><span class="line">            max = leftMax;</span><br><span class="line">        <span class="keyword">if</span> (rightMax &gt; max)</span><br><span class="line">            max = rightMax;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(getDepth(node.left), getDepth(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/diameter-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;543. Diameter of Binary Tree&lt;/a&gt;&lt;br&gt;题目要求二叉树的最大直径，所谓直径就是这颗树的任意两个叶子结点连接，所能经过的最多节点数。分析这个路径的可能构成情况，可能是存在于左子树、右子树，或者存在于左右子树+根节点。所以对于当前任意节点，这颗树的最大直径，可以分为包含这个节点的路径情况：即左右子树高度+1，不包含的情况，即左子树的最大直径、或右子树的最大直径。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[198] House Robber</title>
    <link href="https://dpcfury.github.io/leetcode-house-robber.html/"/>
    <id>https://dpcfury.github.io/leetcode-house-robber.html/</id>
    <published>2020-03-24T14:10:43.000Z</published>
    <updated>2020-03-24T14:16:47.064Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">198. House Robber</a><br>题目描述，给定一组序列，对其中的每一个元素，可以选择拿或者不拿，但是拿了之后，后相邻的下一个元素就不能拿，求能够拿的最大数量。属于特别典型的dp问题，推到出递归式即可。这题在国内还换了种说法，变成了<a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">按摩师</a>，内容完全一样。</p></blockquote><a id="more"></a><h4 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                max[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                max[i] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                max[i] = Math.max(max[i - <span class="number">1</span>], max[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;198. House Robber&lt;/a&gt;&lt;br&gt;题目描述，给定一组序列，对其中的每一个元素，可以选择拿或者不拿，但是拿了之后，后相邻的下一个元素就不能拿，求能够拿的最大数量。属于特别典型的dp问题，推到出递归式即可。这题在国内还换了种说法，变成了&lt;a href=&quot;https://leetcode-cn.com/problems/the-masseuse-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;按摩师&lt;/a&gt;，内容完全一样。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[876] Middle of the Linked List</title>
    <link href="https://dpcfury.github.io/leetcode-middle-of-the-linked-list.html/"/>
    <id>https://dpcfury.github.io/leetcode-middle-of-the-linked-list.html/</id>
    <published>2020-03-23T14:35:01.000Z</published>
    <updated>2020-03-23T14:45:15.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">Leetcode 876. Middle of the Linked List</a><br>题目目的是求一个非空链表中，从中间元素开始往后的截取一半列表。比较直观的就是设立两个元素以相差一倍的速度进行遍历，当跑的快的达到null，或者即将为null，再返回慢的元素或慢元素的下一个位置。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode q = head.next;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q == <span class="keyword">null</span> || q.next == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q == <span class="keyword">null</span> ? p : p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/middle-of-the-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 876. Middle of the Linked List&lt;/a&gt;&lt;br&gt;题目目的是求一个非空链表中，从中间元素开始往后的截取一半列表。比较直观的就是设立两个元素以相差一倍的速度进行遍历，当跑的快的达到null，或者即将为null，再返回慢的元素或慢元素的下一个位置。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="linked list" scheme="https://dpcfury.github.io/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[111] Minimum Depth of Binary Tree</title>
    <link href="https://dpcfury.github.io/leetcode-minimum-depth-of-binary-tree.html/"/>
    <id>https://dpcfury.github.io/leetcode-minimum-depth-of-binary-tree.html/</id>
    <published>2020-03-22T13:46:45.000Z</published>
    <updated>2020-03-22T13:50:32.830Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">Leetcode 111. Minimum Depth of Binary Tree</a><br>题目要求计算二叉树从根节点开始，到叶子阶段的最短距离。解法同样是左右子树递归进行计算，但是要注意为空情况下，子树的最小深度应该设置为无穷大，而不是0。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> minLeft = root.left != <span class="keyword">null</span> ? minDepth(root.left) : Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minRight = root.right != <span class="keyword">null</span> ? minDepth(root.right) : Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> Math.min(minLeft, minRight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 111. Minimum Depth of Binary Tree&lt;/a&gt;&lt;br&gt;题目要求计算二叉树从根节点开始，到叶子阶段的最短距离。解法同样是左右子树递归进行计算，但是要注意为空情况下，子树的最小深度应该设置为无穷大，而不是0。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[110] Balanced Binary Tree</title>
    <link href="https://dpcfury.github.io/leetcode-balanced-binary-tree.html/"/>
    <id>https://dpcfury.github.io/leetcode-balanced-binary-tree.html/</id>
    <published>2020-03-22T13:24:11.000Z</published>
    <updated>2020-03-22T13:27:52.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">Leetcode 110. Balanced Binary Tree</a><br>题目给出一个二叉树，需要判断这颗树是不是平衡二叉树，即对树的每个节点而言，其左右子树高度差不能超过1。第一感觉就是使用递归，从当前节点判断，除了要左右两颗子树都是平衡二叉树之外，还需要一个条件，即左右子树的高度不能像差超过1，因此需要计算树的高度。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isBalanced(root.left) &amp;&amp; isBalanced(root.right))</span><br><span class="line">            <span class="keyword">return</span> Math.abs(heightOfTree(root.left) - heightOfTree(root.right)) &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">heightOfTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ldep = heightOfTree(root.left);</span><br><span class="line">        <span class="keyword">int</span> rdep = heightOfTree(root.right);</span><br><span class="line">        <span class="keyword">if</span> (ldep &gt; rdep) &#123;</span><br><span class="line">            <span class="keyword">return</span> ldep + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rdep + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/balanced-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 110. Balanced Binary Tree&lt;/a&gt;&lt;br&gt;题目给出一个二叉树，需要判断这颗树是不是平衡二叉树，即对树的每个节点而言，其左右子树高度差不能超过1。第一感觉就是使用递归，从当前节点判断，除了要左右两颗子树都是平衡二叉树之外，还需要一个条件，即左右子树的高度不能像差超过1，因此需要计算树的高度。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[200] Number of Islands</title>
    <link href="https://dpcfury.github.io/leetcode-number-of-islands.html/"/>
    <id>https://dpcfury.github.io/leetcode-number-of-islands.html/</id>
    <published>2020-03-22T12:39:04.000Z</published>
    <updated>2020-03-23T14:44:54.002Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">Leetcode 200. Number of Islands</a><br>题目意思：一个二维字符数组，其中‘1’代表的是陆地，上下左右相邻的陆地构成一个岛，求解这幅地图中的独立小岛个数。这题和回溯的相似度很高，但是比回溯要更为简单，直观的解法就是，找到小岛的一块陆地，从上下左右分别去拓展这个小岛，通过一个标记二维数组标记当前的拓展情况，如果已经拓展则进行忽略，当二维字符数组的每个元素都遍历完成，求得小岛数就是最终的答案。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length==<span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    traversal(grid, row, col, i, j, visited);</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col || grid[i][j] != <span class="string">'1'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i][j]) &#123;</span><br><span class="line">                visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                traversal(grid, row, col, i - <span class="number">1</span>, j, visited);</span><br><span class="line">                traversal(grid, row, col, i + <span class="number">1</span>, j, visited);</span><br><span class="line">                traversal(grid, row, col, i, j - <span class="number">1</span>, visited);</span><br><span class="line">                traversal(grid, row, col, i, j + <span class="number">1</span>, visited);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-islands/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 200. Number of Islands&lt;/a&gt;&lt;br&gt;题目意思：一个二维字符数组，其中‘1’代表的是陆地，上下左右相邻的陆地构成一个岛，求解这幅地图中的独立小岛个数。这题和回溯的相似度很高，但是比回溯要更为简单，直观的解法就是，找到小岛的一块陆地，从上下左右分别去拓展这个小岛，通过一个标记二维数组标记当前的拓展情况，如果已经拓展则进行忽略，当二维字符数组的每个元素都遍历完成，求得小岛数就是最终的答案。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[108] Convert Sorted Array to Binary Search Tree</title>
    <link href="https://dpcfury.github.io/convert-sorted-array-to-binary-search-tree.html/"/>
    <id>https://dpcfury.github.io/convert-sorted-array-to-binary-search-tree.html/</id>
    <published>2020-03-22T05:36:55.000Z</published>
    <updated>2020-03-22T07:34:25.558Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">Leetcode 108. Convert Sorted Array to Binary Search Tree</a><br>题目意思：通过一个有序的数组，构建一个高度平衡的二叉搜索树。具体解法比较直观的就是，通过二分法，将数组从中间一份为二，前半部分为左子树，右半部分为右子树，中间元素为树的根，这样递归去构建左右子树技能得到最终的解。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; i) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[m]);</span><br><span class="line">        root.left = sortedArrayToBST(nums, i, m - <span class="number">1</span>);</span><br><span class="line">        root.right = sortedArrayToBST(nums, m + <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 108. Convert Sorted Array to Binary Search Tree&lt;/a&gt;&lt;br&gt;题目意思：通过一个有序的数组，构建一个高度平衡的二叉搜索树。具体解法比较直观的就是，通过二分法，将数组从中间一份为二，前半部分为左子树，右半部分为右子树，中间元素为树的根，这样递归去构建左右子树技能得到最终的解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="BST" scheme="https://dpcfury.github.io/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>letcode[365]Water and Jug Problem</title>
    <link href="https://dpcfury.github.io/leetcode-water-jug-problem.html/"/>
    <id>https://dpcfury.github.io/leetcode-water-jug-problem.html/</id>
    <published>2020-03-21T07:59:14.000Z</published>
    <updated>2020-03-21T08:13:28.442Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">Leetcode 365. Water and Jug Problem</a><br> 题目直面意思，通过两个容器，是否可以计算出指定体积的水，一开始以为什么规律题，折腾了半天，后面看解题思路。这类题目其实属于数学题，即通过机选x,y的最大公约数，并看Z是否能整出这个最大公约数进行判断。</p></blockquote><a id="more"></a><h4 id="参考思路："><a href="#参考思路：" class="headerlink" title="参考思路："></a>参考思路：</h4><p> <a href="https://zhuanlan.zhihu.com/p/68987055" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68987055</a></p><h4 id="问题转换为gcd"><a href="#问题转换为gcd" class="headerlink" title="问题转换为gcd"></a>问题转换为gcd</h4><p> 即如何求两个正整数的最大公约数，思路如下：<a href="https://blog.csdn.net/wujingchangye/article/details/88542193" target="_blank" rel="noopener">https://blog.csdn.net/wujingchangye/article/details/88542193</a></p><blockquote><ol><li>假设有两个数a和b，其中a是不小于b的数，记a被b除的余数为r，则a = b*q + r。</li><li>假设a和b的一个约数为u，那么a和b都能被u整除，则a = su b = tu，s和t都是整数。</li><li>r = a - bq = su - (tu)q = (s - tq)u，所以r也能被u整除</li><li>所以a和b的任一约数同时也是r的约数（每次取余，直到余数为0）。**</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = p % q;</span><br><span class="line">    <span class="keyword">return</span> gcd(q, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目完整解答"><a href="#题目完整解答" class="headerlink" title="题目完整解答"></a>题目完整解答</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x + y &lt; z) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == z || y == z || x + y == z) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> z % gcd(x, y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/water-and-jug-problem/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 365. Water and Jug Problem&lt;/a&gt;&lt;br&gt; 题目直面意思，通过两个容器，是否可以计算出指定体积的水，一开始以为什么规律题，折腾了半天，后面看解题思路。这类题目其实属于数学题，即通过机选x,y的最大公约数，并看Z是否能整出这个最大公约数进行判断。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="math" scheme="https://dpcfury.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode.cn 最小的k个数</title>
    <link href="https://dpcfury.github.io/leetcode-cn-k-smallest-num.html/"/>
    <id>https://dpcfury.github.io/leetcode-cn-k-smallest-num.html/</id>
    <published>2020-03-20T13:50:59.000Z</published>
    <updated>2020-03-20T13:56:25.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/submissions/" target="_blank" rel="noopener">Leetcode中国每日一题</a>取自剑指offer<br>题目意思就是从一个一维数组中，找出k个最小的数，每次看到这个K，最容易想到的就是堆排序，通过构造大顶堆或小顶堆分别来找最小的k个数和最大的k个数。而Java中天生有支持堆排序的数据结构，PriorityQueue，只要指定K容量的堆，通过比较堆顶元素与当前数组遍历元素，如果小于堆顶，则堆顶出列，插入当前遍历元素，遍历完成之后，堆中的K个数即我们要找的最小K个数。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || k &gt; arr.length || k == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() != k) &#123;</span><br><span class="line">                queue.offer(arr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &lt; queue.peek()) &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.offer(arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result[i] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode中国每日一题&lt;/a&gt;取自剑指offer&lt;br&gt;题目意思就是从一个一维数组中，找出k个最小的数，每次看到这个K，最容易想到的就是堆排序，通过构造大顶堆或小顶堆分别来找最小的k个数和最大的k个数。而Java中天生有支持堆排序的数据结构，PriorityQueue，只要指定K容量的堆，通过比较堆顶元素与当前数组遍历元素，如果小于堆顶，则堆顶出列，插入当前遍历元素，遍历完成之后，堆中的K个数即我们要找的最小K个数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="heap sort" scheme="https://dpcfury.github.io/tags/heap-sort/"/>
    
      <category term="priority queye" scheme="https://dpcfury.github.io/tags/priority-queye/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[409]Longest Palindrome</title>
    <link href="https://dpcfury.github.io/leetcode-longest-palindrome.html/"/>
    <id>https://dpcfury.github.io/leetcode-longest-palindrome.html/</id>
    <published>2020-03-19T15:01:25.000Z</published>
    <updated>2020-03-19T15:09:16.367Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/longest-palindrome/" target="_blank" rel="noopener">409. Longrest Palindrome</a><br>给定一个字符串，计算其包含的字符可组成的最长回文字符串，主要是观察下规律，看如何用字符去组织回文字符串，针对单数的字符、双数的字符，应该如何处理。个人给出的代码其实很臃肿，可以优化的地方很多，往上有种bitwise的做法，不是很理解，暂且不放上来。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">int</span> n = count.get(c);</span><br><span class="line">                count.put(c, n + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> once = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : count.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (once) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    once = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> n = entry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) num += n;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (once) &#123;</span><br><span class="line">                        num += (n - <span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        num += n;</span><br><span class="line">                        once=<span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;409. Longrest Palindrome&lt;/a&gt;&lt;br&gt;给定一个字符串，计算其包含的字符可组成的最长回文字符串，主要是观察下规律，看如何用字符去组织回文字符串，针对单数的字符、双数的字符，应该如何处理。个人给出的代码其实很臃肿，可以优化的地方很多，往上有种bitwise的做法，不是很理解，暂且不放上来。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="array" scheme="https://dpcfury.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[100]Same Tree</title>
    <link href="https://dpcfury.github.io/leetcode-same-tree.html/"/>
    <id>https://dpcfury.github.io/leetcode-same-tree.html/</id>
    <published>2020-03-19T13:25:56.000Z</published>
    <updated>2020-03-19T13:30:10.033Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">100. Same Tree</a><br>判断两颗二叉树是否完全相同，即对应位置的结构以及节点的值需要相同，才能判断为相同的书结构，这类问题第一印象就是递归，将问题拆分为左右子树的比较，再加边缘条件的判断，司思路很清晰。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (p.val == q.val) <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/same-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;100. Same Tree&lt;/a&gt;&lt;br&gt;判断两颗二叉树是否完全相同，即对应位置的结构以及节点的值需要相同，才能判断为相同的书结构，这类问题第一印象就是递归，将问题拆分为左右子树的比较，再加边缘条件的判断，司思路很清晰。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="tree" scheme="https://dpcfury.github.io/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[107]Binary Tree Level Order Travesal II</title>
    <link href="https://dpcfury.github.io/leetcode-binary-tree-level-order-travesalII.html/"/>
    <id>https://dpcfury.github.io/leetcode-binary-tree-level-order-travesalII.html/</id>
    <published>2020-03-19T13:03:44.000Z</published>
    <updated>2020-03-19T13:07:36.554Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. Binary Tree Level Order Travesal II</a><br>题目意思就是二叉树的层次遍历换了种说法，从上往下的层次遍历，感觉上变成了从下往上的层次遍历，其实按照从上往下的顺序正常层次遍历，然后对每一层获取的结果列表进行reverse即可。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; layer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                layer.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : layer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            results.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(results);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-level-order-traversal-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;107. Binary Tree Level Order Travesal II&lt;/a&gt;&lt;br&gt;题目意思就是二叉树的层次遍历换了种说法，从上往下的层次遍历，感觉上变成了从下往上的层次遍历，其实按照从上往下的顺序正常层次遍历，然后对每一层获取的结果列表进行reverse即可。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[836] Rectangle Overlap</title>
    <link href="https://dpcfury.github.io/leetcode-rectangl-overlap.html/"/>
    <id>https://dpcfury.github.io/leetcode-rectangl-overlap.html/</id>
    <published>2020-03-18T13:48:28.000Z</published>
    <updated>2020-03-18T13:56:50.068Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/rectangle-overlap/" target="_blank" rel="noopener">836. Rectangle</a><br>给出两个矩形的左下角坐标，以及右上角坐标，判断两个矩形是否重叠，只要从横坐标和纵坐标构成的线段判断是否重叠，再做逻辑与运算，即能判断长方形是否重叠，只要整理好判断条件即可</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = rec1[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y1 = rec1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x2 = rec1[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> y2 = rec1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x11 = rec2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y11 = rec2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x22 = rec2[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> y22 = rec2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> xOverlap = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> yOverlap = <span class="keyword">false</span>;</span><br><span class="line">        xOverlap = (x11 &gt;= x1 &amp;&amp; x11 &lt; x2) || (x22 &gt; x1 &amp;&amp; x22 &lt;= x2) || (x11 &lt;= x1 &amp;&amp; x22 &gt;= x2);</span><br><span class="line">        yOverlap = (y11 &gt;= y1 &amp;&amp; y11 &lt; y2) || (y22 &gt; y1 &amp;&amp; y22 &lt;= y2) || (y11 &lt;= y1 &amp;&amp; y22 &gt;= y2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xOverlap &amp;&amp; yOverlap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实在这种判断条件比较多的情况下，可以看看是否可以用取反进行优化，比如，用判断x轴和y轴不重叠的条件，再取非：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = rec1[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y1 = rec1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x2 = rec1[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> y2 = rec1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x11 = rec2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y11 = rec2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x22 = rec2[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> y22 = rec2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> xOverlap = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> yOverlap = <span class="keyword">false</span>;</span><br><span class="line">        xOverlap = !(x22 &lt;= x1 || x11 &gt;= x2);</span><br><span class="line">        yOverlap = !(y22 &lt;= y1 || y11 &gt;= y2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xOverlap &amp;&amp; yOverlap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/rectangle-overlap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;836. Rectangle&lt;/a&gt;&lt;br&gt;给出两个矩形的左下角坐标，以及右上角坐标，判断两个矩形是否重叠，只要从横坐标和纵坐标构成的线段判断是否重叠，再做逻辑与运算，即能判断长方形是否重叠，只要整理好判断条件即可&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="array" scheme="https://dpcfury.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[112] path-sum</title>
    <link href="https://dpcfury.github.io/leetcode-path-sum.html/"/>
    <id>https://dpcfury.github.io/leetcode-path-sum.html/</id>
    <published>2020-03-17T13:44:21.000Z</published>
    <updated>2020-03-18T13:59:47.987Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">112. Path Sum</a><br> 这题属于Tree类最基本的题目，只要画好图，考虑好递归和边界即可<br><a id="more"></a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum - root.val == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/path-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;112. Path Sum&lt;/a&gt;&lt;br&gt; 这题属于Tree类最基本的题目，只要画好图，考虑好递归和边界即可&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="tree" scheme="https://dpcfury.github.io/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>kolla运行docker服务</title>
    <link href="https://dpcfury.github.io/kolla-start-docker.html/"/>
    <id>https://dpcfury.github.io/kolla-start-docker.html/</id>
    <published>2020-03-11T12:40:18.000Z</published>
    <updated>2020-03-11T12:50:28.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>kolla制作的docker镜像，通过juju部署服务，发现容器在juju中的状态一直是重启状态，检查启动日志，成功运行了进程脚本，于是从镜像入手进行分析。<br><a id="more"></a></p></blockquote><h3 id="kolla运行docker"><a href="#kolla运行docker" class="headerlink" title="kolla运行docker"></a>kolla运行docker</h3><p> 通过kolla启动docekr，运行的是一个启动命令脚本，作为docker的1号进程，而docker判断容器是否运行的依据就是这个启动进程是否存在，即docker中存在的前台和后台概念。<br> 按照这种道理，需要在启动命令中直接进行容器中服务的启动，但是初次之外，还有个trick操作。</p><h3 id="挂起pid-1的进程"><a href="#挂起pid-1的进程" class="headerlink" title="挂起pid=1的进程"></a>挂起pid=1的进程</h3><p> 即在启动命令脚本的最后，加入一行：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p><p> 其原理便是，通过tail和top这种挂起的服务，保持pid=1的进程不会结束，从而实现docker容器的后台运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;kolla制作的docker镜像，通过juju部署服务，发现容器在juju中的状态一直是重启状态，检查启动日志，成功运行了进程脚本，于是从镜像入手进行分析。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="docekr" scheme="https://dpcfury.github.io/categories/docekr/"/>
    
    
      <category term="docker" scheme="https://dpcfury.github.io/tags/docker/"/>
    
      <category term="kolla" scheme="https://dpcfury.github.io/tags/kolla/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[88] Merge Sorted Array</title>
    <link href="https://dpcfury.github.io/leetcode-merge-sorted-array.html/"/>
    <id>https://dpcfury.github.io/leetcode-merge-sorted-array.html/</id>
    <published>2020-03-11T12:28:25.000Z</published>
    <updated>2020-03-11T12:37:45.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. Merge Sorted Array</a><br>记得好像是剑指offer上一个很基础的题目，非常适合休闲和找状态，特别干了一天比较累的情况下刷着玩玩，思路也很简单，就是避免数组内的移动，从后往前安排元素，<br>时间复杂度控制在o(m+n)<br><a id="more"></a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt;= nums2[j]) &#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k] = nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                nums1[k] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;88. Merge Sorted Array&lt;/a&gt;&lt;br&gt;记得好像是剑指offer上一个很基础的题目，非常适合休闲和找状态，特别干了一天比较累的情况下刷着玩玩，思路也很简单，就是避免数组内的移动，从后往前安排元素，&lt;br&gt;时间复杂度控制在o(m+n)&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[67]add binay</title>
    <link href="https://dpcfury.github.io/leetcode-add-binary.html/"/>
    <id>https://dpcfury.github.io/leetcode-add-binary.html/</id>
    <published>2020-03-10T14:28:44.000Z</published>
    <updated>2020-03-10T14:39:31.160Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/add-binary/" target="_blank" rel="noopener">67. Add Binary</a><br>  这题非常中规中矩，组织好逻辑就可以一步到位，就是简单的运算<br>  <a id="more"></a></p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = a.length() - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> j = b.length() - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">boolean</span> carry = <span class="keyword">false</span>;</span><br><span class="line">       StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (a.charAt(i) == <span class="string">'1'</span> &amp;&amp; b.charAt(j) == <span class="string">'1'</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">                   str.append(<span class="string">'1'</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   str.append(<span class="string">'0'</span>);</span><br><span class="line">                   carry = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.charAt(i) == <span class="string">'1'</span> || b.charAt(j) == <span class="string">'1'</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">                   str.append(<span class="string">'0'</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   str.append(<span class="string">'1'</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">char</span> c = carry ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">               str.append(c);</span><br><span class="line">               carry = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           i--;</span><br><span class="line">           j--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (i &lt; <span class="number">0</span> &amp;&amp; j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (carry)</span><br><span class="line">               str.append(<span class="string">'1'</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">           str.append(add(b, j, carry));</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           str.append(add(a, i, carry));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> String <span class="title">add</span><span class="params">(String s, <span class="keyword">int</span> j, <span class="keyword">boolean</span> carry)</span> </span>&#123;</span><br><span class="line">       StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">           <span class="keyword">char</span> c = s.charAt(j);</span><br><span class="line">           <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">               str.append(c == <span class="string">'1'</span> ? <span class="string">'0'</span> : <span class="string">'1'</span>);</span><br><span class="line">               <span class="keyword">if</span> (c == <span class="string">'0'</span>)</span><br><span class="line">                   carry = <span class="keyword">false</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               str.append(c == <span class="string">'1'</span> ? <span class="string">'1'</span> : <span class="string">'0'</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (carry)</span><br><span class="line">           str.append(<span class="string">'1'</span>);</span><br><span class="line">       <span class="keyword">return</span> str.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-binary/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;67. Add Binary&lt;/a&gt;&lt;br&gt;  这题非常中规中矩，组织好逻辑就可以一步到位，就是简单的运算&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[14]longeest common prefix</title>
    <link href="https://dpcfury.github.io/leetcode-longest-common-prefix.html/"/>
    <id>https://dpcfury.github.io/leetcode-longest-common-prefix.html/</id>
    <published>2020-02-29T13:29:02.000Z</published>
    <updated>2020-03-10T13:09:49.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. Longest Common Prefix</a><br>这题比较有意思，我开始给出的算法属于很直接的那种，针对规则编码，其实这个问题可以进行总结和分析，会有更深的收获<br><a id="more"></a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = i &lt; strs[<span class="number">0</span>].length() ? strs[<span class="number">0</span>].charAt(i) : <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == s.length() || s.charAt(i) != c) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                result = result + c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>官方解法</p><h4 id="approach-1-Horizontal-Scan"><a href="#approach-1-Horizontal-Scan" class="headerlink" title="approach 1. Horizontal Scan"></a>approach 1. Horizontal Scan</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    String prefix = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">        <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">            prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (prefix.isEmpty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较形式化的防范，从approach1 的LCP公式衍生而来</p><h4 id="approach-2-Divide-and-Conquer"><a href="#approach-2-Divide-and-Conquer" class="headerlink" title="approach 2. Divide and Conquer"></a>approach 2. Divide and Conquer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;    </span><br><span class="line">        <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span> , strs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        String lcpLeft =   longestCommonPrefix(strs, l , mid);</span><br><span class="line">        String lcpRight =  longestCommonPrefix(strs, mid + <span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">commonPrefix</span><span class="params">(String left,String right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Math.min(left.length(), right.length());       </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( left.charAt(i) != right.charAt(i) )</span><br><span class="line">            <span class="keyword">return</span> left.substring(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.substring(<span class="number">0</span>, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更脱俗的一个解法是，利用binary search的思路，缩小搜索范围</p><h4 id="approach-3-binary-search"><a href="#approach-3-binary-search" class="headerlink" title="approach 3. binary search"></a>approach 3. binary search</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (String str : strs)</span><br><span class="line">        minLen = Math.min(minLen, str.length());</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> high = minLen;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isCommonPrefix(strs, middle))</span><br><span class="line">            low = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, (low + high) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    String str1 = strs[<span class="number">0</span>].substring(<span class="number">0</span>,len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (!strs[i].startsWith(str1))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-prefix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;14. Longest Common Prefix&lt;/a&gt;&lt;br&gt;这题比较有意思，我开始给出的算法属于很直接的那种，针对规则编码，其实这个问题可以进行总结和分析，会有更深的收获&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
  </entry>
  
</feed>
