<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DPC&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/bfa2adcbfd5883f9905426b1399816ee</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dpcfury.github.io/"/>
  <updated>2020-04-20T14:46:17.794Z</updated>
  <id>https://dpcfury.github.io/</id>
  
  <author>
    <name>杜鹏程</name>
    <email>dpcspark@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode[121] Best Time to Buy and Sell Stock</title>
    <link href="https://dpcfury.github.io/best-time-to-buy-and-sell-stock.html/"/>
    <id>https://dpcfury.github.io/best-time-to-buy-and-sell-stock.html/</id>
    <published>2020-04-20T13:28:10.000Z</published>
    <updated>2020-04-20T14:46:17.794Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">Leetcode 121 Best Time to Buy and Sell Stock</a><br>抛售股票的最原始题，只能抛售一次，问能够获取的最大利润，这里给出的是一种比较直观的方法，没有使用dp进行求解。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>记录当前出现的最小元素，用当前元素减去最小元素，如果收益更大，则更新全局最大利润</li><li>如果当前元素比之前出现的最小元素还小，则更新当前最小元素为当前遍历的元素</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//7,1,5,3,6,4  -&gt; 5</span></span><br><span class="line">        <span class="comment">// 7,6,4,3,1 -&gt;0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProfit = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - min &gt; maxProfit) maxProfit = prices[i] - min;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; min) min = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 121 Best Time to Buy and Sell Stock&lt;/a&gt;&lt;br&gt;抛售股票的最原始题，只能抛售一次，问能够获取的最大利润，这里给出的是一种比较直观的方法，没有使用dp进行求解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[695] Max Area of Island</title>
    <link href="https://dpcfury.github.io/max-area-of-island.html/"/>
    <id>https://dpcfury.github.io/max-area-of-island.html/</id>
    <published>2020-04-20T12:49:19.000Z</published>
    <updated>2020-04-20T12:53:53.364Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="">Leetcode 695. Max Area of Island</a><br>题目和 <strong>Leetcode[200] Num of Islands</strong>属于同一类题目，只是要求得内容为独立小岛最大的面积。将题目定义为dfs类型比backtracking类型更为合适。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>遍历面板，只要遇到1元素，则开始dfs</li><li>dfs过程：<ul><li>如果坐标超标或元素不为1，返回0</li><li>返回 1+ 四个方向dfs结果</li></ul></li><li>dfs完成更新全局Max值</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    max = Math.max(max, dfs(grid, row, col, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col || grid[i][j] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        res += dfs(grid, row, col, i, j + <span class="number">1</span>);</span><br><span class="line">        res += dfs(grid, row, col, i, j - <span class="number">1</span>);</span><br><span class="line">        res += dfs(grid, row, col, i - <span class="number">1</span>, j);</span><br><span class="line">        res += dfs(grid, row, col, i + <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;&quot;&gt;Leetcode 695. Max Area of Island&lt;/a&gt;&lt;br&gt;题目和 &lt;strong&gt;Leetcode[200] Num of Islands&lt;/strong&gt;属于同一类题目，只是要求得内容为独立小岛最大的面积。将题目定义为dfs类型比backtracking类型更为合适。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dfs" scheme="https://dpcfury.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[200] Num of Islands</title>
    <link href="https://dpcfury.github.io/num-of-islands.html/"/>
    <id>https://dpcfury.github.io/num-of-islands.html/</id>
    <published>2020-04-19T16:05:34.000Z</published>
    <updated>2020-04-20T15:57:39.238Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">Leetcode200 Num of Islands</a><br>题目定义一个二维面板表示的地图，其中‘0’代表海洋，‘1’表示陆地，上下左右相邻的陆地构成一个小岛，问这个地图中独立的小岛数量，很经典的回溯dfs类题目。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>遍历整个面板，如果面板元素grid[i][j]未访问，且是陆地，则可以进行dfs遍历，标记改陆地所相邻的所有陆地，遍历完成，独立小岛数量+1</li><li>可以用boolean数组标记是否访问，也可以将陆地改变为海洋（考虑题目是否允许改动面板）</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length==<span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    traversal(grid, row, col, i, j, visited);</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col || grid[i][j] != <span class="string">'1'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i][j]) &#123;</span><br><span class="line">                visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                traversal(grid, row, col, i - <span class="number">1</span>, j, visited);</span><br><span class="line">                traversal(grid, row, col, i + <span class="number">1</span>, j, visited);</span><br><span class="line">                traversal(grid, row, col, i, j - <span class="number">1</span>, visited);</span><br><span class="line">                traversal(grid, row, col, i, j + <span class="number">1</span>, visited);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>除了DFS+BFS，这题还可以用UnionFind实现，关于并查集的定义和理解，参考<a href="https://juejin.im/post/5d8e66fdf265da5b633cc8db" target="_blank" rel="noopener">https://juejin.im/post/5d8e66fdf265da5b633cc8db</a> ，后续补充</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-islands/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode200 Num of Islands&lt;/a&gt;&lt;br&gt;题目定义一个二维面板表示的地图，其中‘0’代表海洋，‘1’表示陆地，上下左右相邻的陆地构成一个小岛，问这个地图中独立的小岛数量，很经典的回溯dfs类题目。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
      <category term="dfs" scheme="https://dpcfury.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[980] Unique Paths III</title>
    <link href="https://dpcfury.github.io/unique-pathIII.html/"/>
    <id>https://dpcfury.github.io/unique-pathIII.html/</id>
    <published>2020-04-19T13:53:16.000Z</published>
    <updated>2020-04-19T14:07:56.734Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/unique-paths-iii/" target="_blank" rel="noopener">Leetcode 980. Unique Paths III</a><br>这题要求从二维面板中，找到所有不同的从起点到终点的遍历路径，要求每条路径正好包含一次每个0元素，结题基本套路还是利用回溯的方法，不同的是需要考虑走过路径的0的个数，而且不能重复。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>基本算法框架还是回溯，但是回溯的时候增加一个变量，就是障碍格子的数量，当搜索路径中已经包含了 <strong> 格子总数</strong> - <strong> 障碍个数</strong> -1 时，并且当前准备搜索的点是终点，说明找到了合法解。dp的解法则是定义了dp[r][c][todo] 则是定义了，在grid[r][c]这个点上，在还有todo个空格灭有搜索情况下，有几条独立的到终点路径，然后利用memorization记录中间结果，减少dfs的次数。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>这里给出个人蹩脚的实现，暂时还未做优化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> startX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numOfObstacle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    startX = i;</span><br><span class="line">                    startY = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == -<span class="number">1</span>) numOfObstacle++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        dfs(grid, row, col, startX, startY, numOfObstacle, visited, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> numOfObstacle, <span class="keyword">boolean</span>[][] visited, LinkedList&lt;<span class="keyword">int</span>[]&gt; path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span> &amp;&amp; path.size() == row * col - numOfObstacle - <span class="number">1</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] index : path) &#123;</span><br><span class="line"><span class="comment">//                grid[index[0]][index[1]] = -1;</span></span><br><span class="line">                System.out.print(<span class="string">"("</span> + index[<span class="number">0</span>] + <span class="string">", "</span> + index[<span class="number">1</span>] + <span class="string">"), "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">"("</span> + i + <span class="string">", "</span> + j + <span class="string">")"</span>);</span><br><span class="line">            path.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            dfs(grid, row, col, i, j + <span class="number">1</span>, numOfObstacle, visited, path);</span><br><span class="line">            dfs(grid, row, col, i, j - <span class="number">1</span>, numOfObstacle, visited, path);</span><br><span class="line">            dfs(grid, row, col, i - <span class="number">1</span>, j, numOfObstacle, visited, path);</span><br><span class="line">            dfs(grid, row, col, i + <span class="number">1</span>, j, numOfObstacle, visited, path);</span><br><span class="line">            visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>优化后：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> startX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numOfObstacle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    startX = i;</span><br><span class="line">                    startY = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == -<span class="number">1</span>) numOfObstacle++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(grid, row, col, startX, startY, row * col - <span class="number">1</span> - numOfObstacle);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> todo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span> &amp;&amp; todo == <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] != <span class="number">3</span> &amp;&amp; grid[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            grid[i][j] = <span class="number">3</span>;</span><br><span class="line">            todo--;</span><br><span class="line">            dfs(grid, row, col, i, j + <span class="number">1</span>, todo);</span><br><span class="line">            dfs(grid, row, col, i, j - <span class="number">1</span>, todo);</span><br><span class="line">            dfs(grid, row, col, i - <span class="number">1</span>, j, todo);</span><br><span class="line">            dfs(grid, row, col, i + <span class="number">1</span>, j, todo);</span><br><span class="line">            grid[i][j] = <span class="number">0</span>;</span><br><span class="line">            todo++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>优化后时间超过 100%，空间超过33%</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/unique-paths-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 980. Unique Paths III&lt;/a&gt;&lt;br&gt;这题要求从二维面板中，找到所有不同的从起点到终点的遍历路径，要求每条路径正好包含一次每个0元素，结题基本套路还是利用回溯的方法，不同的是需要考虑走过路径的0的个数，而且不能重复。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1339] Maximum Product of Splitted Binary Tree</title>
    <link href="https://dpcfury.github.io/maximum-product-of-splitted-binary-tree.html/"/>
    <id>https://dpcfury.github.io/maximum-product-of-splitted-binary-tree.html/</id>
    <published>2020-04-19T08:37:45.000Z</published>
    <updated>2020-04-19T08:45:30.946Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/" target="_blank" rel="noopener">Leetcode 1339. Maximum Product of Splitted Binary Tree</a><br>题目给定一课二叉树，选择一个边进行切分，整棵树变成两部分，要求分开的两个字数乘积最大。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>无论是切分哪条边，整颗树肯定是分为了一颗字子树，以及包含这个边上连父节点的子树，利用dfs的思路，遍历每个节点，都可以计算其子树的和于包含自己的子树和乘积，并更新全局最大。核心是先通过一次遍历求得整个树的整体的综合，减去子树的和，就能得到包含父节点那棵树的和，此外，因为树的规模还不小，乘积大小也较大，考虑double类型，并且最好将子树和进行memorization。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> max = <span class="number">0</span>, totalSum = <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;TreeNode, Double&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        totalSum = sum(root);</span><br><span class="line">        memo.put(<span class="keyword">null</span>, <span class="number">0.0</span>);</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (max % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">double</span> leftSum = memo.get(root.left);</span><br><span class="line">        <span class="keyword">double</span> rightSum = memo.get(root.right);</span><br><span class="line">        <span class="keyword">if</span> ((totalSum - leftSum) * leftSum &gt; (totalSum - rightSum) * rightSum) &#123;</span><br><span class="line">            max = Math.max(max, (totalSum - leftSum) * leftSum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, (totalSum - rightSum) * rightSum);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> leftSum = sum(root.left);</span><br><span class="line">        <span class="keyword">double</span> rightSum = sum(root.right);</span><br><span class="line">        <span class="keyword">double</span> sum = leftSum + rightSum + root.val;</span><br><span class="line">        memo.put(root, sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1339. Maximum Product of Splitted Binary Tree&lt;/a&gt;&lt;br&gt;题目给定一课二叉树，选择一个边进行切分，整棵树变成两部分，要求分开的两个字数乘积最大。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Leetcode[466] Count The Repetitions</title>
    <link href="https://dpcfury.github.io/count-the-repetitions.html/"/>
    <id>https://dpcfury.github.io/count-the-repetitions.html/</id>
    <published>2020-04-19T06:21:14.000Z</published>
    <updated>2020-04-19T06:41:31.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/count-the-repetitions/" target="_blank" rel="noopener">Leetcode 466. Count The Repetitions</a><br>题目大意是：定义S = [s,n] 表示字符串S由字符串s重复n次构成。 例如[“abc”, 3] =”abcabcabc”<br>另一方面，我们定义字符串s1可以从s2得到，如果我们可以通过从s2中移除一些字符得到s1。例如根据定义，“abc”可以从“abdbec”得到，但是“acbbe”则不行。<br>给定两个非空字符串s1和s2（每个最多100个字符），两个整数 0 ≤ n1 ≤ 10^6 和 1 ≤ n2 ≤ 10^6。现在考虑字符串S1和S2，其中S1=[s1,n1] 并且 S2=[s2,n2]。计算满足[S2,M]可以从S1得到的最大整数M。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目意思较为难懂，进过几次阅读后，大致明白了这个意思，也能体会到题目背后的核心是如何可用循环重复字符串进行规律的总结，而不是使用暴力的方法求解，结题思路参考自leetcode disscuss中一个解答，核心是发现规律，利用循环节的概念，将s1 * n1 这种长串中出现的反复规律找出来，减少循环遍历的时间损耗：步骤如下：</p><ul><li>遍历S1，追踪每次匹配结束，s2中最后一个字符的下标</li><li>持续遍历，只直到发现s2中的结束坐标重复出现，则：<ul><li>将S1 分为循环前的部分、循环体、结尾部分<ul><li>计算循环体中循环节的出现次数，需要的s1个数和匹配的s2个数</li><li>编列循环前和循环后的情况，补全可匹配的s2个数</li></ul></li></ul></li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>approach1 原始的brute force解法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxRepetitions1</span><span class="params">(String s1, <span class="keyword">int</span> n1, String s2, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0-&gt;n1次，计算最少的需要多少字符串才能</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            dp[i] = contSubsequence(s2, build(s1, i));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n1] / n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">contSubsequence</span><span class="params">(String s, String t)</span> </span>&#123; <span class="comment">//判断 t中能包含几个s序列</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.length()) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == s.length()) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">build</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) str.append(s);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>approach2 引用的循环节解法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxRepetitions</span><span class="params">(String s1, <span class="keyword">int</span> n1, String s2, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nn1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> nn2 = s2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// records[0][i]标识第i个s1用完s2匹配的位置</span></span><br><span class="line">        <span class="comment">// records[1][i] 标识使用i个s1能匹配的s2个数</span></span><br><span class="line">        <span class="keyword">int</span>[][] records = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][n1+<span class="number">1</span>]; </span><br><span class="line">        Arrays.fill(records[<span class="number">0</span>], -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cycleStart = -<span class="number">1</span>, cycleEnd = -<span class="number">1</span>, cycleCount = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nn1; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(j) == s2.charAt(index2)) &#123;</span><br><span class="line">                    index2++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (index2 == nn2) &#123;</span><br><span class="line">                    index2 = <span class="number">0</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; i; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (records[<span class="number">0</span>][k] == index2) &#123;</span><br><span class="line">                    <span class="comment">// we find the cycle, record start/end/count and then quit the loop</span></span><br><span class="line">                    cycleStart = k;</span><br><span class="line">                    cycleEnd = i;</span><br><span class="line">                    cycleCount = count - records[<span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cycleStart != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            records[<span class="number">0</span>][i] = index2;</span><br><span class="line">            records[<span class="number">1</span>][i] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cycleStart == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count / n2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// calculate cycle</span></span><br><span class="line">        <span class="keyword">int</span> cycleN = (n1 - cycleStart) / (cycleEnd - cycleStart);</span><br><span class="line">        res = cycleN * cycleCount;</span><br><span class="line">        <span class="comment">// snitich pre-cycle and post-cycle parts</span></span><br><span class="line">        res += records[<span class="number">1</span>][n1 - cycleN * (cycleEnd - cycleStart)];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res / n2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/count-the-repetitions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 466. Count The Repetitions&lt;/a&gt;&lt;br&gt;题目大意是：定义S = [s,n] 表示字符串S由字符串s重复n次构成。 例如[“abc”, 3] =”abcabcabc”&lt;br&gt;另一方面，我们定义字符串s1可以从s2得到，如果我们可以通过从s2中移除一些字符得到s1。例如根据定义，“abc”可以从“abdbec”得到，但是“acbbe”则不行。&lt;br&gt;给定两个非空字符串s1和s2（每个最多100个字符），两个整数 0 ≤ n1 ≤ 10^6 和 1 ≤ n2 ≤ 10^6。现在考虑字符串S1和S2，其中S1=[s1,n1] 并且 S2=[s2,n2]。计算满足[S2,M]可以从S1得到的最大整数M。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
      <category term="循环节" scheme="https://dpcfury.github.io/tags/%E5%BE%AA%E7%8E%AF%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[11] Container With Most Water</title>
    <link href="https://dpcfury.github.io/container-with-most-water.html/"/>
    <id>https://dpcfury.github.io/container-with-most-water.html/</id>
    <published>2020-04-18T00:53:37.000Z</published>
    <updated>2020-04-18T01:24:20.818Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">Leetcode 11. Container With Most Water</a><br>题目是经典的双指针问题，给定一个高度的数组，求能够围成的长方形最大面积，很中规中矩，从这题可以延伸到trapping rain waterh那道题。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>直观上肯定是希望长和高都尽量大，容易得到一个面积更大的长方形，那么是不是外圈的更容易是最终解呢，这不一定，可能内圈的长方形高度很高。因此，结题思路其实是设置两个指针，从外往里遍历求解，如果左侧指针的高度小于右侧，则将左侧指针左移，如果右侧指针高度小于左侧，则将右侧指针左移,因为当前搜索空间中，这个面积取决于短的那个高度，所以哪个短，就尝试移动哪个获取更大面积的可能。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = right - left;</span><br><span class="line">            <span class="keyword">int</span> h = Math.min(height[left], height[right]);</span><br><span class="line">            max = Math.max(max, len * h);</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) left++;</span><br><span class="line">            <span class="keyword">else</span> right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/container-with-most-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 11. Container With Most Water&lt;/a&gt;&lt;br&gt;题目是经典的双指针问题，给定一个高度的数组，求能够围成的长方形最大面积，很中规中矩，从这题可以延伸到trapping rain waterh那道题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="two pointers" scheme="https://dpcfury.github.io/tags/two-pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[55] Jump Game</title>
    <link href="https://dpcfury.github.io/jump-game.html/"/>
    <id>https://dpcfury.github.io/jump-game.html/</id>
    <published>2020-04-17T15:08:22.000Z</published>
    <updated>2020-04-17T15:17:39.759Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">Leetcode 55. Jump Game</a><br>经典的动态规划题，解题思路比较容易，按递归式实现即可，基本的算法时间复杂度o(n * 2)，其实可以降低为o(n)，遍历当前的最可达范围，只要能够触及到终点，就可以收敛返回。</p></blockquote><a id="more"></a><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>approach1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; j + nums[j] &gt;= i) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>approach2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> target = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= max) &#123;</span><br><span class="line">            max = Math.max(nums[index] + index, max);</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (max &gt;= target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/jump-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 55. Jump Game&lt;/a&gt;&lt;br&gt;经典的动态规划题，解题思路比较容易，按递归式实现即可，基本的算法时间复杂度o(n * 2)，其实可以降低为o(n)，遍历当前的最可达范围，只要能够触及到终点，就可以收敛返回。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[56]. Merge Intervals</title>
    <link href="https://dpcfury.github.io/merge-nitervals.html/"/>
    <id>https://dpcfury.github.io/merge-nitervals.html/</id>
    <published>2020-04-16T13:17:19.000Z</published>
    <updated>2020-04-16T13:24:51.516Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">Leetcode 56. Merge Intervals</a><br>区间合并的题目，题目意思很容易明白，印象中这道题目在校招笔试就出现过，很中规中矩的题目，思路大致就是先对区间按起点排序，再按终点排序，最后遍历和合并区间即可。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>区间排序</li><li>区间遍历，如果当前区间起点小于等于上一个区间的终点，则目前扩展到的最大范围是max（maxEnd， 当前节点的end）</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>当前写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Interval&#123;"</span> +</span><br><span class="line">                    <span class="string">"start="</span> + start +</span><br><span class="line">                    <span class="string">", end="</span> + end +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#125;;</span><br><span class="line">        List&lt;Interval&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            temp.add(<span class="keyword">new</span> Interval(intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.sort(<span class="keyword">new</span> Comparator&lt;Interval&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval o1, Interval o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.start &lt; o2.start) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (o1.start &gt; o2.start) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.end - o2.end;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = temp.get(<span class="number">0</span>).start;</span><br><span class="line">        <span class="keyword">int</span> end = temp.get(<span class="number">0</span>).end;</span><br><span class="line">        <span class="keyword">for</span> (Interval interval : temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval.start &lt;= end) &#123;</span><br><span class="line">                end = Math.max(end, interval.end);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;);</span><br><span class="line">                start = interval.start;</span><br><span class="line">                end = interval.end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;);</span><br><span class="line">        <span class="keyword">int</span>[][] finalRes = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++) finalRes[i] = res.get(i);</span><br><span class="line">        <span class="keyword">return</span> finalRes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>两年前给出的解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.size() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sort by ascending starting point using an anonymous Comparator</span></span><br><span class="line">        intervals.sort((i1, i2) -&gt; Integer.compare(i1.start, i2.start));</span><br><span class="line"></span><br><span class="line">        List&lt;Interval&gt; result = <span class="keyword">new</span> LinkedList&lt;Interval&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = intervals.get(<span class="number">0</span>).start;</span><br><span class="line">        <span class="keyword">int</span> end = intervals.get(<span class="number">0</span>).end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Interval interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval.start &lt;= end) <span class="comment">// Overlapping intervals, move the end if needed</span></span><br><span class="line">                end = Math.max(end, interval.end);</span><br><span class="line">            <span class="keyword">else</span> &#123;                     <span class="comment">// Disjoint intervals, add the previous one and reset bounds</span></span><br><span class="line">                result.add(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">                start = interval.start;</span><br><span class="line">                end = interval.end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the last interval</span></span><br><span class="line">        result.add(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-intervals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 56. Merge Intervals&lt;/a&gt;&lt;br&gt;区间合并的题目，题目意思很容易明白，印象中这道题目在校招笔试就出现过，很中规中矩的题目，思路大致就是先对区间按起点排序，再按终点排序，最后遍历和合并区间即可。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[212] Word Search II</title>
    <link href="https://dpcfury.github.io/word-searchII.html/"/>
    <id>https://dpcfury.github.io/word-searchII.html/</id>
    <published>2020-04-15T14:08:25.000Z</published>
    <updated>2020-04-15T14:15:25.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="noopener">Leetcode 212. Word Search II</a><br>题目要求在二维字符数组中搜索存在的单词，这题从<strong>word search</strong>延伸出来，不过这次不仅是判断是否存在，而是要求得所有可搜索串联的单词，自然而然会想到回溯，但是时间肯定会超时，关键就在于如何进行剪枝。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>思路一：在回溯过程中，对超过单词集最大长度的中间结果，直接停止搜索，但是36个case还有3个没过，仍然超时。<br>思路二：构建单词集的前缀树，对搜索过程中遇到的非已有前缀情况，直接停止搜索，这种剪枝更为合适。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(words));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建前缀字典树</span></span><br><span class="line">        TrieTree root = <span class="keyword">new</span> TrieTree();</span><br><span class="line">        <span class="keyword">for</span> (String s : words)</span><br><span class="line">            root.insert(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] &gt;= <span class="string">'a'</span> &amp;&amp; board[i][j] &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">                    backtracking(board, row, col, i, j, res, <span class="keyword">new</span> StringBuilder(), set, root.root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j, List&lt;String&gt; res,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 StringBuilder stringBuilder, HashSet&lt;String&gt; set, TrieNode cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(stringBuilder.toString()) &amp;&amp; !res.contains(stringBuilder.toString())) &#123;</span><br><span class="line">            res.add(stringBuilder.toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] &gt;= <span class="string">'a'</span> &amp;&amp; board[i][j] &lt;= <span class="string">'z'</span> &amp;&amp; cur.children[board[i][j] - <span class="string">'a'</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TrieNode p = cur.children[board[i][j] - <span class="string">'a'</span>];</span><br><span class="line">            stringBuilder.append(board[i][j]);</span><br><span class="line">            board[i][j] ^= <span class="number">256</span>;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">            flag = backtracking(board, row, col, i, j + <span class="number">1</span>, res, stringBuilder, set, p);</span><br><span class="line">            flag |= backtracking(board, row, col, i, j - <span class="number">1</span>, res, stringBuilder, set, p);</span><br><span class="line">            flag |= backtracking(board, row, col, i - <span class="number">1</span>, j, res, stringBuilder, set, p);</span><br><span class="line">            flag |= backtracking(board, row, col, i + <span class="number">1</span>, j, res, stringBuilder, set, p);</span><br><span class="line">            board[i][j] ^= <span class="number">256</span>;</span><br><span class="line">            stringBuilder.deleteCharAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        TrieNode[] children;</span><br><span class="line">        <span class="keyword">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.c = c;</span><br><span class="line">            children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieTree</span> </span>&#123;</span><br><span class="line">        TrieNode root;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> TrieNode(<span class="string">'#'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            TrieNode cur = root;</span><br><span class="line">            <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.children[chs[i] - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.children[chs[i] - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode(chs[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.children[chs[i] - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/word-search-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 212. Word Search II&lt;/a&gt;&lt;br&gt;题目要求在二维字符数组中搜索存在的单词，这题从&lt;strong&gt;word search&lt;/strong&gt;延伸出来，不过这次不仅是判断是否存在，而是要求得所有可搜索串联的单词，自然而然会想到回溯，但是时间肯定会超时，关键就在于如何进行剪枝。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
      <category term="matrix" scheme="https://dpcfury.github.io/tags/matrix/"/>
    
      <category term="trie" scheme="https://dpcfury.github.io/tags/trie/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[542] 01 Matrix</title>
    <link href="https://dpcfury.github.io/01-matrix.html/"/>
    <id>https://dpcfury.github.io/01-matrix.html/</id>
    <published>2020-04-15T13:58:01.000Z</published>
    <updated>2020-04-15T15:07:47.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="noopener">Leetcode 542. 01 Matrix</a><br>题目给定一个‘0’和‘1’元素组成的矩阵，要求计算每个元素到最近的‘0’元素的距离。看到矩阵以及距离的问题，很容易想到动态规划，这题只要我们找到切入点，就能列出dp表达式，再注意下边界条件即可。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>令dp[i][j]表示matrix[i][j]离‘0’元素的最近距离：<ul><li>情况一： matrix[i][j] == 0: dp[i][j]= 0</li><li>情况二：matrix[i][j] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1],dp[i+1][j],dp[i][j+1])</li></ul></li><li>那么怎么自低向上计算dp[i][j]呢，我们可以分别进行两次遍历，一次从左往右，从上往下，一次从下往上，从右往左，再进行比较即可得到最终结果。</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (inArea(i - <span class="number">1</span>, j, row, col) &amp;&amp; dp[i - <span class="number">1</span>][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (inArea(i, j - <span class="number">1</span>, row, col) &amp;&amp; dp[i][j - <span class="number">1</span>] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        dp[i][j] = Math.min(dp[i][j], dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inArea(i, j + <span class="number">1</span>, row, col) &amp;&amp; dp[i][j + <span class="number">1</span>] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (inArea(i + <span class="number">1</span>, j, row, col) &amp;&amp; dp[i + <span class="number">1</span>][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; row &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; col;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/01-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 542. 01 Matrix&lt;/a&gt;&lt;br&gt;题目给定一个‘0’和‘1’元素组成的矩阵，要求计算每个元素到最近的‘0’元素的距离。看到矩阵以及距离的问题，很容易想到动态规划，这题只要我们找到切入点，就能列出dp表达式，再注意下边界条件即可。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="matrix" scheme="https://dpcfury.github.io/tags/matrix/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[415] Add Strings</title>
    <link href="https://dpcfury.github.io/add-strings.html/"/>
    <id>https://dpcfury.github.io/add-strings.html/</id>
    <published>2020-04-14T15:14:03.000Z</published>
    <updated>2020-04-14T15:50:51.286Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/add-strings/" target="_blank" rel="noopener">Leetcode 415. Add Strings</a><br>题目：给定两个非负的整数（字符串形式），不利用java的BigInteger库，实现两个整数的相加，结果仍以字符串形式表示。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>翻转字符串</li><li>从地位到高位计算，记住进位</li><li>注意边界情况，两数长短不一致的处理</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    num1 = <span class="keyword">new</span> StringBuilder(num1).reverse().toString();</span><br><span class="line">    num2 = <span class="keyword">new</span> StringBuilder(num2).reverse().toString();</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> min = Math.min(num1.length(), num2.length());</span><br><span class="line">    <span class="keyword">while</span> (index &lt; min) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = num1.charAt(index) - <span class="string">'0'</span> + num2.charAt(index) - <span class="string">'0'</span> + carry;</span><br><span class="line">        res.append(sum % <span class="number">10</span>);</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &gt;= num2.length() &amp;&amp; index &lt; num1.length()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = num1.charAt(index) - <span class="string">'0'</span> + carry;</span><br><span class="line">        res.append(sum % <span class="number">10</span>);</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index &gt;= num1.length() &amp;&amp; index &lt; num2.length()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = num2.charAt(index) - <span class="string">'0'</span> + carry;</span><br><span class="line">        res.append(sum % <span class="number">10</span>);</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>) res.append(carry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 415. Add Strings&lt;/a&gt;&lt;br&gt;题目：给定两个非负的整数（字符串形式），不利用java的BigInteger库，实现两个整数的相加，结果仍以字符串形式表示。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="string" scheme="https://dpcfury.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[445] Add Two Numbers II</title>
    <link href="https://dpcfury.github.io/add-two-numsII.html/"/>
    <id>https://dpcfury.github.io/add-two-numsII.html/</id>
    <published>2020-04-14T14:40:22.000Z</published>
    <updated>2020-04-14T14:46:58.527Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">Leetcode 445. Add Two Numbers II</a><br>题目要计算两个链表表示的整数相加，其本质是两个字符串的数字相加，转化为链表的形式即可，可以灵活的利用字符串的翻转，切记直接用整数int或long来存储链表表示的数值容易溢出，转换为字符串是较为合适的方法。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>遍历两组链表，获取数字的字符串形式</li><li>转化为字符串形式的两数相加</li><li>字符串遍历，头插法生成链表</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>目前写的有点啰嗦，时间比较敢写的，后续再优化TODO<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 思路：先整成数字，再去按位生成链表</span></span><br><span class="line">        String numA = generateNum(l1);</span><br><span class="line">        String numB = generateNum(l2);</span><br><span class="line">        String sum = addNum(numA, numB);</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">char</span>[] chs = sum.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            ListNode p = <span class="keyword">new</span> ListNode(chs[i] - <span class="string">'0'</span>);</span><br><span class="line">            p.next = head.next;</span><br><span class="line">            head.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">addNum</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(num1.length(), num2.length());</span><br><span class="line">        <span class="keyword">while</span> (index &lt; min) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num1.charAt(index) - <span class="string">'0'</span> + num2.charAt(index) - <span class="string">'0'</span> + carry;</span><br><span class="line">            res.append(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index &gt;= num2.length() &amp;&amp; index &lt; num1.length()) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num1.charAt(index) - <span class="string">'0'</span> + carry;</span><br><span class="line">            res.append(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (index &gt;= num1.length() &amp;&amp; index &lt; num2.length()) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num2.charAt(index) - <span class="string">'0'</span> + carry;</span><br><span class="line">            res.append(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) res.append(carry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generateNum</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> res.toString();</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.append(p.val);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 445. Add Two Numbers II&lt;/a&gt;&lt;br&gt;题目要计算两个链表表示的整数相加，其本质是两个字符串的数字相加，转化为链表的形式即可，可以灵活的利用字符串的翻转，切记直接用整数int或long来存储链表表示的数值容易溢出，转换为字符串是较为合适的方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="linked-list" scheme="https://dpcfury.github.io/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[355] Design Twitter</title>
    <link href="https://dpcfury.github.io/design-twitter.html/"/>
    <id>https://dpcfury.github.io/design-twitter.html/</id>
    <published>2020-04-13T15:43:06.000Z</published>
    <updated>2020-04-13T15:48:18.905Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/design-twitter/" target="_blank" rel="noopener">Leetcode 355. Design Twitter</a><br>题目要求设计一个简要的Twitter系统，具有基本的几个功能，其实感觉设计题就是着重在如何利用数据结构完成业务，只要做好规划，写好设计框架，再慢慢实现和调试，基本都能cover住。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>抽象出主要的数据结构（User，Post）</li><li>定义好对象的主要动作</li><li>抽象出主要业务的逻辑模型，分步实现</li><li>注意细节，单词瓶拼写，特比是followerId，followeeId 非常相似（坑了半小时不止）</li><li>时间戳因为计算机性能很强，容易没有diff，需要一个全局一致的间隔量来实现更合适</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> interval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">long</span> timeStamp;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Post</span><span class="params">(<span class="keyword">int</span> postId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = postId;</span><br><span class="line">            <span class="keyword">this</span>.timeStamp = System.currentTimeMillis() + Twitter.interval++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Post post = (Post) o;</span><br><span class="line">            <span class="keyword">return</span> id == post.id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(id, timeStamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        LinkedList&lt;Post&gt; posts;</span><br><span class="line">        Map&lt;Integer, Post&gt; index;</span><br><span class="line">        Set&lt;Integer&gt; followers;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getFollowers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(followers);</span><br><span class="line">            <span class="keyword">if</span> (!followers.contains(<span class="keyword">this</span>.id)) &#123;</span><br><span class="line">                res.add(<span class="keyword">this</span>.id);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = userId;</span><br><span class="line">            posts = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            followers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            index = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            followers.add(userId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">psotTweet</span><span class="params">(<span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!index.containsKey(tweetId)) &#123;</span><br><span class="line">                Post post = <span class="keyword">new</span> Post(tweetId);</span><br><span class="line">                posts.addFirst(post);</span><br><span class="line">                index.put(tweetId, post);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取自己的最近10篇tweet</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> List&lt;Post&gt; <span class="title">getNeesFeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            List&lt;Post&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; posts.size() &amp;&amp; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                res.add(posts.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">            followers.add(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">            followers.remove(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                    <span class="string">"id="</span> + id +</span><br><span class="line">                    <span class="string">", followers="</span> + followers +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, User&gt; users;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.users = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compose a new tweet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!users.containsKey(userId)) &#123;</span><br><span class="line">            <span class="comment">// 初始化用户，并创建博客</span></span><br><span class="line">            User user = <span class="keyword">new</span> User(userId);</span><br><span class="line">            users.put(userId, user);</span><br><span class="line">        &#125;</span><br><span class="line">        users.get(userId).psotTweet(tweetId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve the 10 most recent tweet ids in the user's news feed.</span></span><br><span class="line"><span class="comment">     * Each item in the news feed must be posted by users who the user followed or by the user herself.</span></span><br><span class="line"><span class="comment">     * Tweets must be ordered from most recent to least recent.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!users.containsKey(userId)) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            PriorityQueue&lt;Post&gt; tempRes = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Post&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Post o1, Post o2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//                    System.out.println(o1.timeStamp);</span></span><br><span class="line"><span class="comment">//                    System.out.println(o2.timeStamp);</span></span><br><span class="line">                    <span class="keyword">int</span> diff = (<span class="keyword">int</span>) (o1.timeStamp - o2.timeStamp);</span><br><span class="line"><span class="comment">//                    System.out.println("diff" + diff);</span></span><br><span class="line">                    <span class="keyword">return</span> diff;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            User user = users.get(userId);</span><br><span class="line">            List&lt;Post&gt; posts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> followeeId : user.getFollowers()) &#123;</span><br><span class="line">                User followee = users.get(followeeId);</span><br><span class="line">                posts.addAll(followee.getNeesFeed());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Post post : posts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tempRes.size() != <span class="number">10</span>) tempRes.offer(post);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Post min = tempRes.peek();</span><br><span class="line">                    <span class="keyword">if</span> (min.timeStamp &lt; post.timeStamp) &#123;</span><br><span class="line">                        tempRes.poll();</span><br><span class="line">                        tempRes.offer(post);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!tempRes.isEmpty()) &#123;</span><br><span class="line">                Post post = tempRes.poll();</span><br><span class="line">                res.add(post.id);</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.reverse(res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Follower follows a followee. If the operation is invalid, it should be a no-op.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!users.containsKey(followerId)) &#123;</span><br><span class="line">            <span class="comment">// 初始化用户，并创建博客</span></span><br><span class="line">            User user = <span class="keyword">new</span> User(followerId);</span><br><span class="line">            users.put(followerId, user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!users.containsKey(followeeId)) &#123;</span><br><span class="line">            <span class="comment">// 初始化用户，并创建博客</span></span><br><span class="line">            User user = <span class="keyword">new</span> User(followeeId);</span><br><span class="line">            users.put(followeeId, user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        User follower = users.get(followerId);</span><br><span class="line"></span><br><span class="line">        follower.follow(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Follower unfollows a followee. If the operation is invalid, it should be a no-op.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (users.containsKey(followerId) &amp;&amp; users.containsKey(followeeId)) &#123;</span><br><span class="line">            User user = users.get(followerId);</span><br><span class="line">            user.unfollow(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        Twitter twitter = <span class="keyword">new</span> Twitter();</span><br><span class="line">        twitter.postTweet(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        twitter.unfollow(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/design-twitter/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 355. Design Twitter&lt;/a&gt;&lt;br&gt;题目要求设计一个简要的Twitter系统，具有基本的几个功能，其实感觉设计题就是着重在如何利用数据结构完成业务，只要做好规划，写好设计框架，再慢慢实现和调试，基本都能cover住。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="heap" scheme="https://dpcfury.github.io/tags/heap/"/>
    
      <category term="design" scheme="https://dpcfury.github.io/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[106] Construct Binary Tree from Inorder and Postorder Traversal</title>
    <link href="https://dpcfury.github.io/construct-binary-tree-from-inorder-and-postorder-traversal.html/"/>
    <id>https://dpcfury.github.io/construct-binary-tree-from-inorder-and-postorder-traversal.html/</id>
    <published>2020-04-12T04:08:34.000Z</published>
    <updated>2020-04-12T07:30:34.679Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">Leetcode 106. Construct Binary Tree from Inorder and Postorder Traversal</a><br>题目要求：根据一棵树的中序遍历与后序遍历构造二叉树。ps：树中没有重复的元素，属于很基本的二叉树问题。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定二叉树的后序遍历数组和中序遍历数组，可以明确指导后序数组的第一个元素，肯定是当前这颗树的根,随后在中序数组中找到这个根元素，将中序数组就可以切分为左子树和右子树，然后递归去求构造左子树和右子树即可。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder == <span class="keyword">null</span> || postorder == <span class="keyword">null</span> || inorder.length == <span class="number">0</span> || postorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> buildTree(</span><br><span class="line">                    inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>,</span><br><span class="line">                    postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start1 &gt; end1) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[end2]);</span><br><span class="line">        <span class="keyword">int</span> index = start1;</span><br><span class="line">        <span class="keyword">while</span> (inorder[index] != postorder[end2]) index++;</span><br><span class="line">        root.left = buildTree(inorder, start1, index - <span class="number">1</span>, postorder, start2, start2 + index - start1 - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(inorder, index + <span class="number">1</span>, end1, postorder, start2 + index - start1, end2 - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 106. Construct Binary Tree from Inorder and Postorder Traversal&lt;/a&gt;&lt;br&gt;题目要求：根据一棵树的中序遍历与后序遍历构造二叉树。ps：树中没有重复的元素，属于很基本的二叉树问题。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>面试题 16.03. 交点</title>
    <link href="https://dpcfury.github.io/cross-point.html/"/>
    <id>https://dpcfury.github.io/cross-point.html/</id>
    <published>2020-04-12T03:04:31.000Z</published>
    <updated>2020-04-12T03:13:10.555Z</updated>
    
    <content type="html"><![CDATA[<p>题目：给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目是一条完完全全全的数学几何题，需要对线段的函数表示方式非常清楚，并能转化条件，将问题变换成较为清晰的数学求解问题。总的来说，两个线段的交点分为两种情况，第一种是不平行的情况，第二种是平行的情况，需要分别进行考虑，这里引用官网给出的算法实现进行改造，个人想这个问题比较艰难，掉脑细胞严重，容易手足无措。</p><blockquote><p>官网实现：<a href="https://leetcode-cn.com/problems/intersection-lcci/solution/jiao-dian-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-lcci/solution/jiao-dian-by-leetcode-solution/</a></p></blockquote><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 (xk, yk) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">    <span class="comment">// 这里的前提是 (xk, yk) 一定在「直线」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">inside</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> xk, <span class="keyword">int</span> yk)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若与 x 轴平行，只需要判断 x 的部分</span></span><br><span class="line">        <span class="comment">// 若与 y 轴平行，只需要判断 y 的部分</span></span><br><span class="line">        <span class="comment">// 若为普通线段，则都要判断</span></span><br><span class="line">        <span class="keyword">return</span> (x1 == x2 || (Math.min(x1, x2) &lt;= xk &amp;&amp; xk &lt;= Math.max(x1, x2)))</span><br><span class="line">                &amp;&amp; (y1 == y2 || (Math.min(y1, y2) &lt;= yk &amp;&amp; yk &lt;= Math.max(y1, y2)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] update(<span class="keyword">double</span>[] ans, <span class="keyword">double</span> xk, <span class="keyword">double</span> yk) &#123;</span><br><span class="line">        <span class="comment">// 将一个交点与当前 ans 中的结果进行比较</span></span><br><span class="line">        <span class="comment">// 若更优则替换</span></span><br><span class="line">        <span class="keyword">if</span> (ans.length == <span class="number">0</span> || xk &lt; ans[<span class="number">0</span>] || (xk == ans[<span class="number">0</span>] &amp;&amp; yk &lt; ans[<span class="number">1</span>])) &#123;</span><br><span class="line">            ans = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;xk, yk&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] intersection(<span class="keyword">int</span>[] start1, <span class="keyword">int</span>[] end1, <span class="keyword">int</span>[] start2, <span class="keyword">int</span>[] end2) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = start1[<span class="number">0</span>], y1 = start1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x2 = end1[<span class="number">0</span>], y2 = end1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x3 = start2[<span class="number">0</span>], y3 = start2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x4 = end2[<span class="number">0</span>], y4 = end2[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] ans = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 判断 (x1, y1)~(x2, y2) 和 (x3, y3)~(x4, y3) 是否平行</span></span><br><span class="line">        <span class="keyword">if</span> ((y4 - y3) * (x2 - x1) == (y2 - y1) * (x4 - x3)) &#123;</span><br><span class="line">            <span class="comment">// 若平行，则判断 (x3, y3) 是否在「直线」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">            <span class="keyword">if</span> ((y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)) &#123;</span><br><span class="line">                <span class="comment">// 判断 (x3, y3) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x1, y1, x2, y2, x3, y3)) &#123;</span><br><span class="line">                    ans = update(ans, x3, y3);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断 (x4, y4) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x1, y1, x2, y2, x4, y4)) &#123;</span><br><span class="line">                    ans = update(ans, x4, y4);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断 (x1, y1) 是否在「线段」(x3, y3)~(x4, y4) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x3, y3, x4, y4, x1, y1)) &#123;</span><br><span class="line">                    ans = update(ans, x1, y1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断 (x2, y2) 是否在「线段」(x3, y3)~(x4, y4) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x3, y3, x4, y4, x2, y2)) &#123;</span><br><span class="line">                    ans = update(ans, x2, y2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在平行时，其余的所有情况都不会有交点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 联立方程得到 t1 和 t2 的值</span></span><br><span class="line">            <span class="keyword">double</span> t1 = (<span class="keyword">double</span>) (x3 * (y4 - y3) + y1 * (x4 - x3) - y3 * (x4 - x3) - x1 * (y4 - y3)) / ((x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1));</span><br><span class="line">            <span class="keyword">double</span> t2 = (<span class="keyword">double</span>) (x1 * (y2 - y1) + y3 * (x2 - x1) - y1 * (x2 - x1) - x3 * (y2 - y1)) / ((x4 - x3) * (y2 - y1) - (x2 - x1) * (y4 - y3));</span><br><span class="line">            <span class="comment">// 判断 t1 和 t2 是否均在 [0, 1] 之间</span></span><br><span class="line">            <span class="keyword">if</span> (t1 &gt;= <span class="number">0.0</span> &amp;&amp; t1 &lt;= <span class="number">1.0</span> &amp;&amp; t2 &gt;= <span class="number">0.0</span> &amp;&amp; t2 &lt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                ans = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;x1 + t1 * (x2 - x1), y1 + t1 * (y2 - y1)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="math" scheme="https://dpcfury.github.io/tags/math/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[105] Construct Binary Tree from Preorder and Inorder Traversal</title>
    <link href="https://dpcfury.github.io/construct-binary-tree-from-preorder-and-inorder-traversal.html/"/>
    <id>https://dpcfury.github.io/construct-binary-tree-from-preorder-and-inorder-traversal.html/</id>
    <published>2020-04-11T12:50:44.000Z</published>
    <updated>2020-04-11T12:58:03.192Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal</a><br>题目要求：根据一棵树的前序遍历与中序遍历构造二叉树。ps：树中没有重复的元素，属于很基本的二叉树问题。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定二叉树的前序遍历数组和中序遍历数组，可以明确指导前序数组的第一个元素，肯定是当前这颗树的根,随后在中序数组中找到这个根元素，将中序数组就可以切分为左子树和右子树，然后递归去求构造左子树和右子树即可。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> buildTree(</span><br><span class="line">                    preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>,</span><br><span class="line">                    inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start1 &gt; end1) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[start1]);</span><br><span class="line">        <span class="keyword">int</span> index = start2;</span><br><span class="line">        <span class="keyword">while</span> (inorder[index] != preorder[start1]) index++;</span><br><span class="line">        root.left = buildTree(preorder, start1 + <span class="number">1</span>, start1 + index - start2, inorder, start2, index - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preorder, start1 + index - start2 + <span class="number">1</span>, end1, inorder, index + <span class="number">1</span>, end2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal&lt;/a&gt;&lt;br&gt;题目要求：根据一棵树的前序遍历与中序遍历构造二叉树。ps：树中没有重复的元素，属于很基本的二叉树问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[887] Super Egg Drop</title>
    <link href="https://dpcfury.github.io/super-egg-drop.html/"/>
    <id>https://dpcfury.github.io/super-egg-drop.html/</id>
    <published>2020-04-11T05:28:55.000Z</published>
    <updated>2020-04-11T06:03:48.777Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/super-egg-drop/" target="_blank" rel="noopener">Leetcode 887. Super Egg Drop</a><br>题目：K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。<br>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。<br>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。<br>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。<br>你的目标是确切地知道 F 的值是多少。</p></blockquote><p>求：无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？<br><a id="more"></a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目只要推导推导，很快会发现这题是动态规划的味道，令dp[K][N]为给定K个鸡蛋，测量N层楼需要的最少移动次数，可以推导出表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp(K,N)= V <span class="number">1</span>≤X≤<span class="function">N <span class="title">min</span><span class="params">(max(dp(K−<span class="number">1</span>,X−<span class="number">1</span>)</span>,<span class="title">dp</span><span class="params">(K,N−X)</span>))</span></span><br></pre></td></tr></table></figure></p><p>但是问题是，如果通过一个一个遍历的方式，寻找这个满足最少条件的的X，时间复杂度为O(k<em>N</em>N),提交会TLL</p><p>结合官网给出的数学分析，可以将寻找这个X的过程通过二分实现，进而将时间复杂度降低为O(K∗NlogN).</p><p><img src="https://leetcode.com/problems/super-egg-drop/Figures/891/sketch.png" alt="数学分析"></p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) dp[<span class="number">1</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= K; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">                dp[i][j] = j;</span><br><span class="line">                <span class="keyword">int</span> low = <span class="number">1</span>, high = j;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i - <span class="number">1</span>][mid - <span class="number">1</span>] &lt; dp[i][j - mid]) low = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> high = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], Math.max(dp[i - <span class="number">1</span>][high - <span class="number">1</span>], dp[i][j - high]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[K][N];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>题目其实还有O(KN)的实现方式，这个记个TODO，后续跟进</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/super-egg-drop/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 887. Super Egg Drop&lt;/a&gt;&lt;br&gt;题目：K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。&lt;br&gt;每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。&lt;br&gt;你知道存在楼层 F ，满足 0 &amp;lt;= F &amp;lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。&lt;br&gt;每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &amp;lt;= X &amp;lt;= N）。&lt;br&gt;你的目标是确切地知道 F 的值是多少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;求：无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
      <category term="binary search" scheme="https://dpcfury.github.io/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[79] Word Search</title>
    <link href="https://dpcfury.github.io/word-search.html/"/>
    <id>https://dpcfury.github.io/word-search.html/</id>
    <published>2020-04-10T13:13:12.000Z</published>
    <updated>2020-04-10T13:21:37.855Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">Leetcode 79. Word Search</a><br>给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用回溯的方法，递归进行搜索求解，从一个格子（单个字符已经匹配）出发，查看剩余字符是否在上下左右的搜索路径中能够满足。</p><h4 id="approach1-原始写法"><a href="#approach1-原始写法" class="headerlink" title="approach1 原始写法"></a>approach1 原始写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || word == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (word.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">                    <span class="keyword">if</span> (traversal(board, word, <span class="number">0</span>, i, j, directions, visited)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">traversal</span><span class="params">(<span class="keyword">char</span>[][] board, String word,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] directions, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; word.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[i][j] || board[i][j] != word.charAt(index)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">            <span class="keyword">int</span> curX = i + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> curY = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (traversal(board, word, index + <span class="number">1</span>, curX, curY, directions, visited)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="approach2-优化写法"><a href="#approach2-优化写法" class="headerlink" title="approach2 优化写法"></a>approach2 优化写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] w = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;board.length; y++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;board[y].length; x++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exist(board, y, x, w, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> y, <span class="keyword">int</span> x, <span class="keyword">char</span>[] word, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == word.length) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (y&lt;<span class="number">0</span> || x&lt;<span class="number">0</span> || y == board.length || x == board[y].length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[y][x] != word[i]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        board[y][x] ^= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">boolean</span> exist = exist(board, y, x+<span class="number">1</span>, word, i+<span class="number">1</span>)</span><br><span class="line">                || exist(board, y, x-<span class="number">1</span>, word, i+<span class="number">1</span>)</span><br><span class="line">                || exist(board, y+<span class="number">1</span>, x, word, i+<span class="number">1</span>)</span><br><span class="line">                || exist(board, y-<span class="number">1</span>, x, word, i+<span class="number">1</span>);</span><br><span class="line">        board[y][x] ^= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> exist;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/word-search/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 79. Word Search&lt;/a&gt;&lt;br&gt;给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode [151] Reverse Words in a String</title>
    <link href="https://dpcfury.github.io/reverse-words-in-a-string.html/"/>
    <id>https://dpcfury.github.io/reverse-words-in-a-string.html/</id>
    <published>2020-04-10T13:01:09.000Z</published>
    <updated>2020-04-10T13:05:45.797Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener"> Leetcode 151. Reverse Words in a String</a><br>给定一个字符串，逐个翻转字符串中的每个单词。要求是去除前后的空格，并且单词间间隔一个空格，很常规的字符串题目。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>从字符串的尾部开始便利，遇到空格跳过，遇到非空格，开始遍历合法的单词，并利用substring存入到中间结果集中，最后统一处理拼接字符串，记得去除尾部的空格。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(j) != <span class="string">' '</span>) j--;</span><br><span class="line">            res.add(s.substring(j + <span class="number">1</span>, i + <span class="number">1</span>));</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : res) str.append(word).append(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (str.length() != <span class="number">0</span>) str.deleteCharAt(str.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-words-in-a-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; Leetcode 151. Reverse Words in a String&lt;/a&gt;&lt;br&gt;给定一个字符串，逐个翻转字符串中的每个单词。要求是去除前后的空格，并且单词间间隔一个空格，很常规的字符串题目。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="String" scheme="https://dpcfury.github.io/tags/String/"/>
    
  </entry>
  
</feed>
