<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DPC&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/bfa2adcbfd5883f9905426b1399816ee</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dpcfury.github.io/"/>
  <updated>2020-04-17T15:17:39.759Z</updated>
  <id>https://dpcfury.github.io/</id>
  
  <author>
    <name>杜鹏程</name>
    <email>dpcspark@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode[55] Jump Game</title>
    <link href="https://dpcfury.github.io/jump-game.html/"/>
    <id>https://dpcfury.github.io/jump-game.html/</id>
    <published>2020-04-17T15:08:22.000Z</published>
    <updated>2020-04-17T15:17:39.759Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">Leetcode 55. Jump Game</a><br>经典的动态规划题，解题思路比较容易，按递归式实现即可，基本的算法时间复杂度o(n * 2)，其实可以降低为o(n)，遍历当前的最可达范围，只要能够触及到终点，就可以收敛返回。</p></blockquote><a id="more"></a><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>approach1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; j + nums[j] &gt;= i) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>approach2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> target = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= max) &#123;</span><br><span class="line">            max = Math.max(nums[index] + index, max);</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (max &gt;= target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/jump-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 55. Jump Game&lt;/a&gt;&lt;br&gt;经典的动态规划题，解题思路比较容易，按递归式实现即可，基本的算法时间复杂度o(n * 2)，其实可以降低为o(n)，遍历当前的最可达范围，只要能够触及到终点，就可以收敛返回。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[56]. Merge Intervals</title>
    <link href="https://dpcfury.github.io/merge-nitervals.html/"/>
    <id>https://dpcfury.github.io/merge-nitervals.html/</id>
    <published>2020-04-16T13:17:19.000Z</published>
    <updated>2020-04-16T13:24:51.516Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">Leetcode 56. Merge Intervals</a><br>区间合并的题目，题目意思很容易明白，印象中这道题目在校招笔试就出现过，很中规中矩的题目，思路大致就是先对区间按起点排序，再按终点排序，最后遍历和合并区间即可。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>区间排序</li><li>区间遍历，如果当前区间起点小于等于上一个区间的终点，则目前扩展到的最大范围是max（maxEnd， 当前节点的end）</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>当前写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Interval&#123;"</span> +</span><br><span class="line">                    <span class="string">"start="</span> + start +</span><br><span class="line">                    <span class="string">", end="</span> + end +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#125;;</span><br><span class="line">        List&lt;Interval&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            temp.add(<span class="keyword">new</span> Interval(intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.sort(<span class="keyword">new</span> Comparator&lt;Interval&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval o1, Interval o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.start &lt; o2.start) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (o1.start &gt; o2.start) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.end - o2.end;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = temp.get(<span class="number">0</span>).start;</span><br><span class="line">        <span class="keyword">int</span> end = temp.get(<span class="number">0</span>).end;</span><br><span class="line">        <span class="keyword">for</span> (Interval interval : temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval.start &lt;= end) &#123;</span><br><span class="line">                end = Math.max(end, interval.end);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;);</span><br><span class="line">                start = interval.start;</span><br><span class="line">                end = interval.end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;);</span><br><span class="line">        <span class="keyword">int</span>[][] finalRes = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++) finalRes[i] = res.get(i);</span><br><span class="line">        <span class="keyword">return</span> finalRes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>两年前给出的解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.size() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sort by ascending starting point using an anonymous Comparator</span></span><br><span class="line">        intervals.sort((i1, i2) -&gt; Integer.compare(i1.start, i2.start));</span><br><span class="line"></span><br><span class="line">        List&lt;Interval&gt; result = <span class="keyword">new</span> LinkedList&lt;Interval&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = intervals.get(<span class="number">0</span>).start;</span><br><span class="line">        <span class="keyword">int</span> end = intervals.get(<span class="number">0</span>).end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Interval interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval.start &lt;= end) <span class="comment">// Overlapping intervals, move the end if needed</span></span><br><span class="line">                end = Math.max(end, interval.end);</span><br><span class="line">            <span class="keyword">else</span> &#123;                     <span class="comment">// Disjoint intervals, add the previous one and reset bounds</span></span><br><span class="line">                result.add(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">                start = interval.start;</span><br><span class="line">                end = interval.end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the last interval</span></span><br><span class="line">        result.add(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-intervals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 56. Merge Intervals&lt;/a&gt;&lt;br&gt;区间合并的题目，题目意思很容易明白，印象中这道题目在校招笔试就出现过，很中规中矩的题目，思路大致就是先对区间按起点排序，再按终点排序，最后遍历和合并区间即可。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[212] Word Search II</title>
    <link href="https://dpcfury.github.io/word-searchII.html/"/>
    <id>https://dpcfury.github.io/word-searchII.html/</id>
    <published>2020-04-15T14:08:25.000Z</published>
    <updated>2020-04-15T14:15:25.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="noopener">Leetcode 212. Word Search II</a><br>题目要求在二维字符数组中搜索存在的单词，这题从<strong>word search</strong>延伸出来，不过这次不仅是判断是否存在，而是要求得所有可搜索串联的单词，自然而然会想到回溯，但是时间肯定会超时，关键就在于如何进行剪枝。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>思路一：在回溯过程中，对超过单词集最大长度的中间结果，直接停止搜索，但是36个case还有3个没过，仍然超时。<br>思路二：构建单词集的前缀树，对搜索过程中遇到的非已有前缀情况，直接停止搜索，这种剪枝更为合适。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(words));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建前缀字典树</span></span><br><span class="line">        TrieTree root = <span class="keyword">new</span> TrieTree();</span><br><span class="line">        <span class="keyword">for</span> (String s : words)</span><br><span class="line">            root.insert(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] &gt;= <span class="string">'a'</span> &amp;&amp; board[i][j] &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">                    backtracking(board, row, col, i, j, res, <span class="keyword">new</span> StringBuilder(), set, root.root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j, List&lt;String&gt; res,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 StringBuilder stringBuilder, HashSet&lt;String&gt; set, TrieNode cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(stringBuilder.toString()) &amp;&amp; !res.contains(stringBuilder.toString())) &#123;</span><br><span class="line">            res.add(stringBuilder.toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] &gt;= <span class="string">'a'</span> &amp;&amp; board[i][j] &lt;= <span class="string">'z'</span> &amp;&amp; cur.children[board[i][j] - <span class="string">'a'</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TrieNode p = cur.children[board[i][j] - <span class="string">'a'</span>];</span><br><span class="line">            stringBuilder.append(board[i][j]);</span><br><span class="line">            board[i][j] ^= <span class="number">256</span>;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">            flag = backtracking(board, row, col, i, j + <span class="number">1</span>, res, stringBuilder, set, p);</span><br><span class="line">            flag |= backtracking(board, row, col, i, j - <span class="number">1</span>, res, stringBuilder, set, p);</span><br><span class="line">            flag |= backtracking(board, row, col, i - <span class="number">1</span>, j, res, stringBuilder, set, p);</span><br><span class="line">            flag |= backtracking(board, row, col, i + <span class="number">1</span>, j, res, stringBuilder, set, p);</span><br><span class="line">            board[i][j] ^= <span class="number">256</span>;</span><br><span class="line">            stringBuilder.deleteCharAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        TrieNode[] children;</span><br><span class="line">        <span class="keyword">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.c = c;</span><br><span class="line">            children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieTree</span> </span>&#123;</span><br><span class="line">        TrieNode root;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> TrieNode(<span class="string">'#'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            TrieNode cur = root;</span><br><span class="line">            <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.children[chs[i] - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.children[chs[i] - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode(chs[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.children[chs[i] - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/word-search-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 212. Word Search II&lt;/a&gt;&lt;br&gt;题目要求在二维字符数组中搜索存在的单词，这题从&lt;strong&gt;word search&lt;/strong&gt;延伸出来，不过这次不仅是判断是否存在，而是要求得所有可搜索串联的单词，自然而然会想到回溯，但是时间肯定会超时，关键就在于如何进行剪枝。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
      <category term="matrix" scheme="https://dpcfury.github.io/tags/matrix/"/>
    
      <category term="trie" scheme="https://dpcfury.github.io/tags/trie/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[542] 01 Matrix</title>
    <link href="https://dpcfury.github.io/01-matrix.html/"/>
    <id>https://dpcfury.github.io/01-matrix.html/</id>
    <published>2020-04-15T13:58:01.000Z</published>
    <updated>2020-04-15T15:07:47.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="noopener">Leetcode 542. 01 Matrix</a><br>题目给定一个‘0’和‘1’元素组成的矩阵，要求计算每个元素到最近的‘0’元素的距离。看到矩阵以及距离的问题，很容易想到动态规划，这题只要我们找到切入点，就能列出dp表达式，再注意下边界条件即可。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>令dp[i][j]表示matrix[i][j]离‘0’元素的最近距离：<ul><li>情况一： matrix[i][j] == 0: dp[i][j]= 0</li><li>情况二：matrix[i][j] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1],dp[i+1][j],dp[i][j+1])</li></ul></li><li>那么怎么自低向上计算dp[i][j]呢，我们可以分别进行两次遍历，一次从左往右，从上往下，一次从下往上，从右往左，再进行比较即可得到最终结果。</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (inArea(i - <span class="number">1</span>, j, row, col) &amp;&amp; dp[i - <span class="number">1</span>][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (inArea(i, j - <span class="number">1</span>, row, col) &amp;&amp; dp[i][j - <span class="number">1</span>] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        dp[i][j] = Math.min(dp[i][j], dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inArea(i, j + <span class="number">1</span>, row, col) &amp;&amp; dp[i][j + <span class="number">1</span>] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (inArea(i + <span class="number">1</span>, j, row, col) &amp;&amp; dp[i + <span class="number">1</span>][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; row &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; col;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/01-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 542. 01 Matrix&lt;/a&gt;&lt;br&gt;题目给定一个‘0’和‘1’元素组成的矩阵，要求计算每个元素到最近的‘0’元素的距离。看到矩阵以及距离的问题，很容易想到动态规划，这题只要我们找到切入点，就能列出dp表达式，再注意下边界条件即可。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="matrix" scheme="https://dpcfury.github.io/tags/matrix/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[415] Add Strings</title>
    <link href="https://dpcfury.github.io/add-strings.html/"/>
    <id>https://dpcfury.github.io/add-strings.html/</id>
    <published>2020-04-14T15:14:03.000Z</published>
    <updated>2020-04-14T15:50:51.286Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/add-strings/" target="_blank" rel="noopener">Leetcode 415. Add Strings</a><br>题目：给定两个非负的整数（字符串形式），不利用java的BigInteger库，实现两个整数的相加，结果仍以字符串形式表示。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>翻转字符串</li><li>从地位到高位计算，记住进位</li><li>注意边界情况，两数长短不一致的处理</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    num1 = <span class="keyword">new</span> StringBuilder(num1).reverse().toString();</span><br><span class="line">    num2 = <span class="keyword">new</span> StringBuilder(num2).reverse().toString();</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> min = Math.min(num1.length(), num2.length());</span><br><span class="line">    <span class="keyword">while</span> (index &lt; min) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = num1.charAt(index) - <span class="string">'0'</span> + num2.charAt(index) - <span class="string">'0'</span> + carry;</span><br><span class="line">        res.append(sum % <span class="number">10</span>);</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &gt;= num2.length() &amp;&amp; index &lt; num1.length()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = num1.charAt(index) - <span class="string">'0'</span> + carry;</span><br><span class="line">        res.append(sum % <span class="number">10</span>);</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index &gt;= num1.length() &amp;&amp; index &lt; num2.length()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = num2.charAt(index) - <span class="string">'0'</span> + carry;</span><br><span class="line">        res.append(sum % <span class="number">10</span>);</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>) res.append(carry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 415. Add Strings&lt;/a&gt;&lt;br&gt;题目：给定两个非负的整数（字符串形式），不利用java的BigInteger库，实现两个整数的相加，结果仍以字符串形式表示。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="string" scheme="https://dpcfury.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[445] Add Two Numbers II</title>
    <link href="https://dpcfury.github.io/add-two-numsII.html/"/>
    <id>https://dpcfury.github.io/add-two-numsII.html/</id>
    <published>2020-04-14T14:40:22.000Z</published>
    <updated>2020-04-14T14:46:58.527Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">Leetcode 445. Add Two Numbers II</a><br>题目要计算两个链表表示的整数相加，其本质是两个字符串的数字相加，转化为链表的形式即可，可以灵活的利用字符串的翻转，切记直接用整数int或long来存储链表表示的数值容易溢出，转换为字符串是较为合适的方法。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>遍历两组链表，获取数字的字符串形式</li><li>转化为字符串形式的两数相加</li><li>字符串遍历，头插法生成链表</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>目前写的有点啰嗦，时间比较敢写的，后续再优化TODO<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 思路：先整成数字，再去按位生成链表</span></span><br><span class="line">        String numA = generateNum(l1);</span><br><span class="line">        String numB = generateNum(l2);</span><br><span class="line">        String sum = addNum(numA, numB);</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">char</span>[] chs = sum.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            ListNode p = <span class="keyword">new</span> ListNode(chs[i] - <span class="string">'0'</span>);</span><br><span class="line">            p.next = head.next;</span><br><span class="line">            head.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">addNum</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(num1.length(), num2.length());</span><br><span class="line">        <span class="keyword">while</span> (index &lt; min) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num1.charAt(index) - <span class="string">'0'</span> + num2.charAt(index) - <span class="string">'0'</span> + carry;</span><br><span class="line">            res.append(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index &gt;= num2.length() &amp;&amp; index &lt; num1.length()) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num1.charAt(index) - <span class="string">'0'</span> + carry;</span><br><span class="line">            res.append(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (index &gt;= num1.length() &amp;&amp; index &lt; num2.length()) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num2.charAt(index) - <span class="string">'0'</span> + carry;</span><br><span class="line">            res.append(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) res.append(carry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generateNum</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> res.toString();</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.append(p.val);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 445. Add Two Numbers II&lt;/a&gt;&lt;br&gt;题目要计算两个链表表示的整数相加，其本质是两个字符串的数字相加，转化为链表的形式即可，可以灵活的利用字符串的翻转，切记直接用整数int或long来存储链表表示的数值容易溢出，转换为字符串是较为合适的方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="linked-list" scheme="https://dpcfury.github.io/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[355] Design Twitter</title>
    <link href="https://dpcfury.github.io/design-twitter.html/"/>
    <id>https://dpcfury.github.io/design-twitter.html/</id>
    <published>2020-04-13T15:43:06.000Z</published>
    <updated>2020-04-13T15:48:18.905Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/design-twitter/" target="_blank" rel="noopener">Leetcode 355. Design Twitter</a><br>题目要求设计一个简要的Twitter系统，具有基本的几个功能，其实感觉设计题就是着重在如何利用数据结构完成业务，只要做好规划，写好设计框架，再慢慢实现和调试，基本都能cover住。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>抽象出主要的数据结构（User，Post）</li><li>定义好对象的主要动作</li><li>抽象出主要业务的逻辑模型，分步实现</li><li>注意细节，单词瓶拼写，特比是followerId，followeeId 非常相似（坑了半小时不止）</li><li>时间戳因为计算机性能很强，容易没有diff，需要一个全局一致的间隔量来实现更合适</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> interval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">long</span> timeStamp;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Post</span><span class="params">(<span class="keyword">int</span> postId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = postId;</span><br><span class="line">            <span class="keyword">this</span>.timeStamp = System.currentTimeMillis() + Twitter.interval++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Post post = (Post) o;</span><br><span class="line">            <span class="keyword">return</span> id == post.id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(id, timeStamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        LinkedList&lt;Post&gt; posts;</span><br><span class="line">        Map&lt;Integer, Post&gt; index;</span><br><span class="line">        Set&lt;Integer&gt; followers;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getFollowers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(followers);</span><br><span class="line">            <span class="keyword">if</span> (!followers.contains(<span class="keyword">this</span>.id)) &#123;</span><br><span class="line">                res.add(<span class="keyword">this</span>.id);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = userId;</span><br><span class="line">            posts = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            followers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            index = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            followers.add(userId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">psotTweet</span><span class="params">(<span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!index.containsKey(tweetId)) &#123;</span><br><span class="line">                Post post = <span class="keyword">new</span> Post(tweetId);</span><br><span class="line">                posts.addFirst(post);</span><br><span class="line">                index.put(tweetId, post);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取自己的最近10篇tweet</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> List&lt;Post&gt; <span class="title">getNeesFeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            List&lt;Post&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; posts.size() &amp;&amp; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                res.add(posts.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">            followers.add(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">            followers.remove(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                    <span class="string">"id="</span> + id +</span><br><span class="line">                    <span class="string">", followers="</span> + followers +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, User&gt; users;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.users = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compose a new tweet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!users.containsKey(userId)) &#123;</span><br><span class="line">            <span class="comment">// 初始化用户，并创建博客</span></span><br><span class="line">            User user = <span class="keyword">new</span> User(userId);</span><br><span class="line">            users.put(userId, user);</span><br><span class="line">        &#125;</span><br><span class="line">        users.get(userId).psotTweet(tweetId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve the 10 most recent tweet ids in the user's news feed.</span></span><br><span class="line"><span class="comment">     * Each item in the news feed must be posted by users who the user followed or by the user herself.</span></span><br><span class="line"><span class="comment">     * Tweets must be ordered from most recent to least recent.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!users.containsKey(userId)) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            PriorityQueue&lt;Post&gt; tempRes = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Post&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Post o1, Post o2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//                    System.out.println(o1.timeStamp);</span></span><br><span class="line"><span class="comment">//                    System.out.println(o2.timeStamp);</span></span><br><span class="line">                    <span class="keyword">int</span> diff = (<span class="keyword">int</span>) (o1.timeStamp - o2.timeStamp);</span><br><span class="line"><span class="comment">//                    System.out.println("diff" + diff);</span></span><br><span class="line">                    <span class="keyword">return</span> diff;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            User user = users.get(userId);</span><br><span class="line">            List&lt;Post&gt; posts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> followeeId : user.getFollowers()) &#123;</span><br><span class="line">                User followee = users.get(followeeId);</span><br><span class="line">                posts.addAll(followee.getNeesFeed());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Post post : posts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tempRes.size() != <span class="number">10</span>) tempRes.offer(post);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Post min = tempRes.peek();</span><br><span class="line">                    <span class="keyword">if</span> (min.timeStamp &lt; post.timeStamp) &#123;</span><br><span class="line">                        tempRes.poll();</span><br><span class="line">                        tempRes.offer(post);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!tempRes.isEmpty()) &#123;</span><br><span class="line">                Post post = tempRes.poll();</span><br><span class="line">                res.add(post.id);</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.reverse(res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Follower follows a followee. If the operation is invalid, it should be a no-op.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!users.containsKey(followerId)) &#123;</span><br><span class="line">            <span class="comment">// 初始化用户，并创建博客</span></span><br><span class="line">            User user = <span class="keyword">new</span> User(followerId);</span><br><span class="line">            users.put(followerId, user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!users.containsKey(followeeId)) &#123;</span><br><span class="line">            <span class="comment">// 初始化用户，并创建博客</span></span><br><span class="line">            User user = <span class="keyword">new</span> User(followeeId);</span><br><span class="line">            users.put(followeeId, user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        User follower = users.get(followerId);</span><br><span class="line"></span><br><span class="line">        follower.follow(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Follower unfollows a followee. If the operation is invalid, it should be a no-op.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (users.containsKey(followerId) &amp;&amp; users.containsKey(followeeId)) &#123;</span><br><span class="line">            User user = users.get(followerId);</span><br><span class="line">            user.unfollow(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        Twitter twitter = <span class="keyword">new</span> Twitter();</span><br><span class="line">        twitter.postTweet(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        twitter.unfollow(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/design-twitter/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 355. Design Twitter&lt;/a&gt;&lt;br&gt;题目要求设计一个简要的Twitter系统，具有基本的几个功能，其实感觉设计题就是着重在如何利用数据结构完成业务，只要做好规划，写好设计框架，再慢慢实现和调试，基本都能cover住。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="heap" scheme="https://dpcfury.github.io/tags/heap/"/>
    
      <category term="design" scheme="https://dpcfury.github.io/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[106] Construct Binary Tree from Inorder and Postorder Traversal</title>
    <link href="https://dpcfury.github.io/construct-binary-tree-from-inorder-and-postorder-traversal.html/"/>
    <id>https://dpcfury.github.io/construct-binary-tree-from-inorder-and-postorder-traversal.html/</id>
    <published>2020-04-12T04:08:34.000Z</published>
    <updated>2020-04-12T07:30:34.679Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">Leetcode 106. Construct Binary Tree from Inorder and Postorder Traversal</a><br>题目要求：根据一棵树的中序遍历与后序遍历构造二叉树。ps：树中没有重复的元素，属于很基本的二叉树问题。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定二叉树的后序遍历数组和中序遍历数组，可以明确指导后序数组的第一个元素，肯定是当前这颗树的根,随后在中序数组中找到这个根元素，将中序数组就可以切分为左子树和右子树，然后递归去求构造左子树和右子树即可。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder == <span class="keyword">null</span> || postorder == <span class="keyword">null</span> || inorder.length == <span class="number">0</span> || postorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> buildTree(</span><br><span class="line">                    inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>,</span><br><span class="line">                    postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start1 &gt; end1) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[end2]);</span><br><span class="line">        <span class="keyword">int</span> index = start1;</span><br><span class="line">        <span class="keyword">while</span> (inorder[index] != postorder[end2]) index++;</span><br><span class="line">        root.left = buildTree(inorder, start1, index - <span class="number">1</span>, postorder, start2, start2 + index - start1 - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(inorder, index + <span class="number">1</span>, end1, postorder, start2 + index - start1, end2 - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 106. Construct Binary Tree from Inorder and Postorder Traversal&lt;/a&gt;&lt;br&gt;题目要求：根据一棵树的中序遍历与后序遍历构造二叉树。ps：树中没有重复的元素，属于很基本的二叉树问题。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>面试题 16.03. 交点</title>
    <link href="https://dpcfury.github.io/cross-point.html/"/>
    <id>https://dpcfury.github.io/cross-point.html/</id>
    <published>2020-04-12T03:04:31.000Z</published>
    <updated>2020-04-12T03:13:10.555Z</updated>
    
    <content type="html"><![CDATA[<p>题目：给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目是一条完完全全全的数学几何题，需要对线段的函数表示方式非常清楚，并能转化条件，将问题变换成较为清晰的数学求解问题。总的来说，两个线段的交点分为两种情况，第一种是不平行的情况，第二种是平行的情况，需要分别进行考虑，这里引用官网给出的算法实现进行改造，个人想这个问题比较艰难，掉脑细胞严重，容易手足无措。</p><blockquote><p>官网实现：<a href="https://leetcode-cn.com/problems/intersection-lcci/solution/jiao-dian-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-lcci/solution/jiao-dian-by-leetcode-solution/</a></p></blockquote><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 (xk, yk) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">    <span class="comment">// 这里的前提是 (xk, yk) 一定在「直线」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">inside</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> xk, <span class="keyword">int</span> yk)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若与 x 轴平行，只需要判断 x 的部分</span></span><br><span class="line">        <span class="comment">// 若与 y 轴平行，只需要判断 y 的部分</span></span><br><span class="line">        <span class="comment">// 若为普通线段，则都要判断</span></span><br><span class="line">        <span class="keyword">return</span> (x1 == x2 || (Math.min(x1, x2) &lt;= xk &amp;&amp; xk &lt;= Math.max(x1, x2)))</span><br><span class="line">                &amp;&amp; (y1 == y2 || (Math.min(y1, y2) &lt;= yk &amp;&amp; yk &lt;= Math.max(y1, y2)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] update(<span class="keyword">double</span>[] ans, <span class="keyword">double</span> xk, <span class="keyword">double</span> yk) &#123;</span><br><span class="line">        <span class="comment">// 将一个交点与当前 ans 中的结果进行比较</span></span><br><span class="line">        <span class="comment">// 若更优则替换</span></span><br><span class="line">        <span class="keyword">if</span> (ans.length == <span class="number">0</span> || xk &lt; ans[<span class="number">0</span>] || (xk == ans[<span class="number">0</span>] &amp;&amp; yk &lt; ans[<span class="number">1</span>])) &#123;</span><br><span class="line">            ans = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;xk, yk&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] intersection(<span class="keyword">int</span>[] start1, <span class="keyword">int</span>[] end1, <span class="keyword">int</span>[] start2, <span class="keyword">int</span>[] end2) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = start1[<span class="number">0</span>], y1 = start1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x2 = end1[<span class="number">0</span>], y2 = end1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x3 = start2[<span class="number">0</span>], y3 = start2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x4 = end2[<span class="number">0</span>], y4 = end2[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] ans = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 判断 (x1, y1)~(x2, y2) 和 (x3, y3)~(x4, y3) 是否平行</span></span><br><span class="line">        <span class="keyword">if</span> ((y4 - y3) * (x2 - x1) == (y2 - y1) * (x4 - x3)) &#123;</span><br><span class="line">            <span class="comment">// 若平行，则判断 (x3, y3) 是否在「直线」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">            <span class="keyword">if</span> ((y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)) &#123;</span><br><span class="line">                <span class="comment">// 判断 (x3, y3) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x1, y1, x2, y2, x3, y3)) &#123;</span><br><span class="line">                    ans = update(ans, x3, y3);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断 (x4, y4) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x1, y1, x2, y2, x4, y4)) &#123;</span><br><span class="line">                    ans = update(ans, x4, y4);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断 (x1, y1) 是否在「线段」(x3, y3)~(x4, y4) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x3, y3, x4, y4, x1, y1)) &#123;</span><br><span class="line">                    ans = update(ans, x1, y1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断 (x2, y2) 是否在「线段」(x3, y3)~(x4, y4) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x3, y3, x4, y4, x2, y2)) &#123;</span><br><span class="line">                    ans = update(ans, x2, y2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在平行时，其余的所有情况都不会有交点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 联立方程得到 t1 和 t2 的值</span></span><br><span class="line">            <span class="keyword">double</span> t1 = (<span class="keyword">double</span>) (x3 * (y4 - y3) + y1 * (x4 - x3) - y3 * (x4 - x3) - x1 * (y4 - y3)) / ((x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1));</span><br><span class="line">            <span class="keyword">double</span> t2 = (<span class="keyword">double</span>) (x1 * (y2 - y1) + y3 * (x2 - x1) - y1 * (x2 - x1) - x3 * (y2 - y1)) / ((x4 - x3) * (y2 - y1) - (x2 - x1) * (y4 - y3));</span><br><span class="line">            <span class="comment">// 判断 t1 和 t2 是否均在 [0, 1] 之间</span></span><br><span class="line">            <span class="keyword">if</span> (t1 &gt;= <span class="number">0.0</span> &amp;&amp; t1 &lt;= <span class="number">1.0</span> &amp;&amp; t2 &gt;= <span class="number">0.0</span> &amp;&amp; t2 &lt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                ans = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;x1 + t1 * (x2 - x1), y1 + t1 * (y2 - y1)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="math" scheme="https://dpcfury.github.io/tags/math/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[105] Construct Binary Tree from Preorder and Inorder Traversal</title>
    <link href="https://dpcfury.github.io/construct-binary-tree-from-preorder-and-inorder-traversal.html/"/>
    <id>https://dpcfury.github.io/construct-binary-tree-from-preorder-and-inorder-traversal.html/</id>
    <published>2020-04-11T12:50:44.000Z</published>
    <updated>2020-04-11T12:58:03.192Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal</a><br>题目要求：根据一棵树的前序遍历与中序遍历构造二叉树。ps：树中没有重复的元素，属于很基本的二叉树问题。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定二叉树的前序遍历数组和中序遍历数组，可以明确指导前序数组的第一个元素，肯定是当前这颗树的根,随后在中序数组中找到这个根元素，将中序数组就可以切分为左子树和右子树，然后递归去求构造左子树和右子树即可。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> buildTree(</span><br><span class="line">                    preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>,</span><br><span class="line">                    inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start1 &gt; end1) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[start1]);</span><br><span class="line">        <span class="keyword">int</span> index = start2;</span><br><span class="line">        <span class="keyword">while</span> (inorder[index] != preorder[start1]) index++;</span><br><span class="line">        root.left = buildTree(preorder, start1 + <span class="number">1</span>, start1 + index - start2, inorder, start2, index - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preorder, start1 + index - start2 + <span class="number">1</span>, end1, inorder, index + <span class="number">1</span>, end2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal&lt;/a&gt;&lt;br&gt;题目要求：根据一棵树的前序遍历与中序遍历构造二叉树。ps：树中没有重复的元素，属于很基本的二叉树问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[887] Super Egg Drop</title>
    <link href="https://dpcfury.github.io/super-egg-drop.html/"/>
    <id>https://dpcfury.github.io/super-egg-drop.html/</id>
    <published>2020-04-11T05:28:55.000Z</published>
    <updated>2020-04-11T06:03:48.777Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/super-egg-drop/" target="_blank" rel="noopener">Leetcode 887. Super Egg Drop</a><br>题目：K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。<br>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。<br>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。<br>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。<br>你的目标是确切地知道 F 的值是多少。</p></blockquote><p>求：无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？<br><a id="more"></a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目只要推导推导，很快会发现这题是动态规划的味道，令dp[K][N]为给定K个鸡蛋，测量N层楼需要的最少移动次数，可以推导出表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp(K,N)= V <span class="number">1</span>≤X≤<span class="function">N <span class="title">min</span><span class="params">(max(dp(K−<span class="number">1</span>,X−<span class="number">1</span>)</span>,<span class="title">dp</span><span class="params">(K,N−X)</span>))</span></span><br></pre></td></tr></table></figure></p><p>但是问题是，如果通过一个一个遍历的方式，寻找这个满足最少条件的的X，时间复杂度为O(k<em>N</em>N),提交会TLL</p><p>结合官网给出的数学分析，可以将寻找这个X的过程通过二分实现，进而将时间复杂度降低为O(K∗NlogN).</p><p><img src="https://leetcode.com/problems/super-egg-drop/Figures/891/sketch.png" alt="数学分析"></p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) dp[<span class="number">1</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= K; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">                dp[i][j] = j;</span><br><span class="line">                <span class="keyword">int</span> low = <span class="number">1</span>, high = j;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i - <span class="number">1</span>][mid - <span class="number">1</span>] &lt; dp[i][j - mid]) low = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> high = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], Math.max(dp[i - <span class="number">1</span>][high - <span class="number">1</span>], dp[i][j - high]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[K][N];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>题目其实还有O(KN)的实现方式，这个记个TODO，后续跟进</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/super-egg-drop/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 887. Super Egg Drop&lt;/a&gt;&lt;br&gt;题目：K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。&lt;br&gt;每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。&lt;br&gt;你知道存在楼层 F ，满足 0 &amp;lt;= F &amp;lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。&lt;br&gt;每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &amp;lt;= X &amp;lt;= N）。&lt;br&gt;你的目标是确切地知道 F 的值是多少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;求：无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
      <category term="binary search" scheme="https://dpcfury.github.io/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[79] Word Search</title>
    <link href="https://dpcfury.github.io/word-search.html/"/>
    <id>https://dpcfury.github.io/word-search.html/</id>
    <published>2020-04-10T13:13:12.000Z</published>
    <updated>2020-04-10T13:21:37.855Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">Leetcode 79. Word Search</a><br>给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用回溯的方法，递归进行搜索求解，从一个格子（单个字符已经匹配）出发，查看剩余字符是否在上下左右的搜索路径中能够满足。</p><h4 id="approach1-原始写法"><a href="#approach1-原始写法" class="headerlink" title="approach1 原始写法"></a>approach1 原始写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || word == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (word.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">                    <span class="keyword">if</span> (traversal(board, word, <span class="number">0</span>, i, j, directions, visited)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">traversal</span><span class="params">(<span class="keyword">char</span>[][] board, String word,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] directions, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; word.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[i][j] || board[i][j] != word.charAt(index)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">            <span class="keyword">int</span> curX = i + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> curY = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (traversal(board, word, index + <span class="number">1</span>, curX, curY, directions, visited)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="approach2-优化写法"><a href="#approach2-优化写法" class="headerlink" title="approach2 优化写法"></a>approach2 优化写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] w = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;board.length; y++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;board[y].length; x++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exist(board, y, x, w, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> y, <span class="keyword">int</span> x, <span class="keyword">char</span>[] word, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == word.length) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (y&lt;<span class="number">0</span> || x&lt;<span class="number">0</span> || y == board.length || x == board[y].length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[y][x] != word[i]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        board[y][x] ^= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">boolean</span> exist = exist(board, y, x+<span class="number">1</span>, word, i+<span class="number">1</span>)</span><br><span class="line">                || exist(board, y, x-<span class="number">1</span>, word, i+<span class="number">1</span>)</span><br><span class="line">                || exist(board, y+<span class="number">1</span>, x, word, i+<span class="number">1</span>)</span><br><span class="line">                || exist(board, y-<span class="number">1</span>, x, word, i+<span class="number">1</span>);</span><br><span class="line">        board[y][x] ^= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> exist;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/word-search/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 79. Word Search&lt;/a&gt;&lt;br&gt;给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode [151] Reverse Words in a String</title>
    <link href="https://dpcfury.github.io/reverse-words-in-a-string.html/"/>
    <id>https://dpcfury.github.io/reverse-words-in-a-string.html/</id>
    <published>2020-04-10T13:01:09.000Z</published>
    <updated>2020-04-10T13:05:45.797Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener"> Leetcode 151. Reverse Words in a String</a><br>给定一个字符串，逐个翻转字符串中的每个单词。要求是去除前后的空格，并且单词间间隔一个空格，很常规的字符串题目。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>从字符串的尾部开始便利，遇到空格跳过，遇到非空格，开始遍历合法的单词，并利用substring存入到中间结果集中，最后统一处理拼接字符串，记得去除尾部的空格。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(j) != <span class="string">' '</span>) j--;</span><br><span class="line">            res.add(s.substring(j + <span class="number">1</span>, i + <span class="number">1</span>));</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : res) str.append(word).append(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (str.length() != <span class="number">0</span>) str.deleteCharAt(str.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-words-in-a-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; Leetcode 151. Reverse Words in a String&lt;/a&gt;&lt;br&gt;给定一个字符串，逐个翻转字符串中的每个单词。要求是去除前后的空格，并且单词间间隔一个空格，很常规的字符串题目。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="String" scheme="https://dpcfury.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[22] Generate Parentheses</title>
    <link href="https://dpcfury.github.io/generate-parentheses.html/"/>
    <id>https://dpcfury.github.io/generate-parentheses.html/</id>
    <published>2020-04-09T14:34:06.000Z</published>
    <updated>2020-04-09T14:42:47.265Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">Leetcode 22. Generate Parentheses</a><br>这题要求生成指定对数的括号，通常可以直接对应到回溯来做，只要控制好边界，再引入合法括号的判断，基本记得到最终解，如果时间效率优化的话，可以考虑进行剪枝。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用一个temp（StringBuilder）来存放临时的解，如果temp的长度达到了2 * n 并且是合法的括号，那么就把这个临时解存放到结果集中。回溯完成，删除最后一个字符，进行下一轮搜索。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backtracking(res, n, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;String&gt; res, <span class="keyword">int</span> n, StringBuilder str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length() == n * <span class="number">2</span> &amp;&amp; validParent(str.toString())) &#123;</span><br><span class="line">            res.add(str.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.length() &gt; n * <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">char</span>[] pat = &#123;<span class="string">'('</span>, <span class="string">')'</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : pat) &#123;</span><br><span class="line">            backtracking(res, n, str.append(c));</span><br><span class="line">            str.deleteCharAt(str.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validParent</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">'('</span>) stack.add(<span class="string">'C'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) stack.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/generate-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 22. Generate Parentheses&lt;/a&gt;&lt;br&gt;这题要求生成指定对数的括号，通常可以直接对应到回溯来做，只要控制好边界，再引入合法括号的判断，基本记得到最终解，如果时间效率优化的话，可以考虑进行剪枝。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[730] Count Different Palindromic Subsequences</title>
    <link href="https://dpcfury.github.io/count-different-palindromic-subsequences.html/"/>
    <id>https://dpcfury.github.io/count-different-palindromic-subsequences.html/</id>
    <published>2020-04-08T15:11:29.000Z</published>
    <updated>2020-04-08T15:15:18.138Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/count-different-palindromic-subsequences/" target="_blank" rel="noopener">Leetcode 730. Count Different Palindromic Subsequences</a><br>这题是从Longest Palinromic Subsequence延伸而来，同样属于动态规划问题，但是不同的是在递归式的推导上，由于子问题的回文串数量和前后位置的字符串是有关联的，难点在这个规律的发现。</p></blockquote><a id="more"></a><p>TODO </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/count-different-palindromic-subsequences/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 730. Count Different Palindromic Subsequences&lt;/a&gt;&lt;br&gt;这题是从Longest Palinromic Subsequence延伸而来，同样属于动态规划问题，但是不同的是在递归式的推导上，由于子问题的回文串数量和前后位置的字符串是有关联的，难点在这个规律的发现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
      <category term="palindromic" scheme="https://dpcfury.github.io/tags/palindromic/"/>
    
  </entry>
  
  <entry>
    <title>机器人运动范围</title>
    <link href="https://dpcfury.github.io/robot-move-range.html/"/>
    <id>https://dpcfury.github.io/robot-move-range.html/</id>
    <published>2020-04-08T14:24:39.000Z</published>
    <updated>2020-04-08T15:48:47.782Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">力扣中国 面试题13. 机器人的运动范围</a><br>题目：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。请问该机器人能够到达多少个格子？</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目给出的描述和经常遇到的二维矩阵题非常类似，再加上题目限定的1 &lt;= n,m &lt;= 100，基本可以判断这题可以用BFS或者DFS来进行遍历搜索问题的解。需要注意的是注意边界，以及如何求一个整数的数位和。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        Queue&lt;Point&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(<span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Point p = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (inArea(m, n, p.x, p.y) &amp;&amp; !visited[p.x][p.y] &amp;&amp;</span><br><span class="line">                    sumOfDigits(p.x) + sumOfDigits(p.y) &lt;= k) &#123;</span><br><span class="line">                visited[p.x][p.y] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : direction) &#123;</span><br><span class="line">                    <span class="keyword">int</span> curX = p.x + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> curY = p.y + dir[<span class="number">1</span>];</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Point(curX, curY));</span><br><span class="line">                &#125;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumOfDigits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> j &gt;= <span class="number">0</span> &amp;&amp; j &lt; col;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="第二种解法dp"><a href="#第二种解法dp" class="headerlink" title="第二种解法dp"></a>第二种解法dp</h4><p>计算整个平面，那些点能够走到，每个点只能从上或从左边走到，并且本身的数位和小于等于K<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span> || sumOfDigits(i) + sumOfDigits(j) &gt; k) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) visited[i][j] |= visited[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) visited[i][j] |= visited[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (visited[i][j]) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumOfDigits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;力扣中国 面试题13. 机器人的运动范围&lt;/a&gt;&lt;br&gt;题目：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。请问该机器人能够到达多少个格子？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="BFS" scheme="https://dpcfury.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>DNS解析过程</title>
    <link href="https://dpcfury.github.io/dns-resolve.html/"/>
    <id>https://dpcfury.github.io/dns-resolve.html/</id>
    <published>2020-04-08T11:01:48.000Z</published>
    <updated>2020-04-08T11:45:26.494Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在日常的开发和问题排查中，难免会遇到DNS解析的问题，尤其是在云计算中，内部组件因为DNS解析问题导致的问题层出不穷。借此，总计一下基本的DNS原理，以及日常生活中，一次DNS解析的过程。</p></blockquote><a id="more"></a><h4 id="为什么需要DNS解析？"><a href="#为什么需要DNS解析？" class="headerlink" title="为什么需要DNS解析？"></a>为什么需要DNS解析？</h4><p>在互联网通信中，大部分应用基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络层只能识别”192.168.1.24”之类的IP地址，而不能认识域名。而互联网大量的服务是无法全部通过IP给用户提供服务的，用户无法记住这么多的IP地址，并且固定IP地址也不利于互联网服务的高可用实现，域名相对来说用户能够容易记住和使用，<strong>www.baidu.com</strong> 肯定比61.135.169.125这种地址方便访问，那么为了能够使用域名进行互联网访问，就需要一个翻译器（DNS）讲域名翻译为对应的IP地址。</p><h4 id="DNS是什么"><a href="#DNS是什么" class="headerlink" title="DNS是什么"></a>DNS是什么</h4><p>DNS的全称是<strong>（Domain Name System）</strong>，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。通过域名，最终得到该域名对应的IP地址的过程则是域名解析的过程。</p><h4 id="DNS如何解析"><a href="#DNS如何解析" class="headerlink" title="DNS如何解析"></a>DNS如何解析</h4><h5 id="1-递归查询"><a href="#1-递归查询" class="headerlink" title="1. 递归查询"></a>1. 递归查询</h5><p>某天，客户端想要访问XXX网站，但是，客户端并不知道XXX网站的IP地址。于是，展开了如下对话</p><ul><li>客户端：“本地DNS服务器大佬，求问XXX的IP地址是多少？”</li><li>本地DNS服务器：“不好意思，我不知道，但是根域名服务器可能会知道，我替去问他吧”</li><li>本地DNS服务器：“根域名服务器大佬，求问XXX的IP地址是多少？”</li><li>根域名服务器：“不好意思，我不也知道，但是A顶级域名服务器可能会知道，我替你去问他吧”</li><li>根域名服务器：“A顶级域名服务器，求问XXX的IP地址是多少？”</li><li>A顶级域名服务器：“不好意思，我不也知道，但是B域名服务器可能会知道，我替你去问他吧”</li><li>A顶级域名服务器：“B域名服务器，求问XXX的IP地址是多少？”</li><li>B域名服务器：“A顶级域名服务器，查到XXX的IP地址是192.168.168.6”</li><li>A顶级域名服务器：“根域名服务器，查到XXX的IP地址是192.168.168.6”</li><li>根域名服务器：“本地DNS服务器，查到XXX的IP地址是192.168.168.6”</li><li>本地DNS服务器： “客户端，查到XXX的IP地址是192.168.168.6”</li><li>客户端：“谢谢各位大佬，XXX的IP地址是192.168.168.6，我可以和他愉快的通讯了”<br><img src="https://user-gold-cdn.xitu.io/2018/5/27/1639fd992859d5f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="dns 递归查询"></li></ul><h5 id="2-迭代查询"><a href="#2-迭代查询" class="headerlink" title="2. 迭代查询"></a>2. 迭代查询</h5><p>客户端：“本地DNS服务器大佬，求问XXX的IP地址是多少？”</p><ul><li>本地DNS服务器：“不好意思，我不知道，但是根域名服务器可能会知道，你去问他吧”，本地DNS服务器说完，并把根域名服务器地址发给客户端。</li><li>客户端：“根域名服务器大佬，求问XXX的IP地址是多少？”</li><li>根域名服务器：“不好意思，我不也知道，但是A顶级域名服务器可能会知道，你去问他吧”，根域名服务器说完，并把A顶级域名服务器地址发给客户端。</li><li>客户端只能又跑去问A顶级域名服务器了。</li><li>客户端：“A顶级域名服务器大佬，求问XXX的IP地址是多少？”</li><li>A顶级域名服务器：“不好意思，我不也知道，但是B域名服务器可能会知道，你去问他吧”，A顶级域名服务器说完，并把B域名服务器地址发给客户端。</li><li>客户端非常无奈，只能又跑去问B域名服务器了。</li><li>客户端：“B域名服务器大佬，求问XXX的IP地址是多少？”</li><li>B域名服务器：“客户端同学，查到XXX的IP地址是192.168.168.6”。</li><li>客户端：“谢谢B域名服务器大佬，XXX的IP地址是192.168.168.6，我可以和他愉快的通讯了”<br>就这样，客户端在询问了一大圈之后，终于知道了XXX的IP地址了。<br><img src="https://user-gold-cdn.xitu.io/2018/5/27/1639fdb27f876e0d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="dns 迭代查询"></li></ul><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>实际上，在DNS查询过程中，客户端和服务器也都会加入缓存的机制，这样可以减少查询的次数，加快域名解析过程。</p><h4 id="一次请求的DNS解析过程"><a href="#一次请求的DNS解析过程" class="headerlink" title="一次请求的DNS解析过程"></a>一次请求的DNS解析过程</h4><ol><li><p>在浏览器中输入<strong>www.baidu.com</strong> 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 </p></li><li><p>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 </p></li><li><p>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 </p></li><li><p>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p></li><li><p>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(<strong>.com</strong>)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址<strong>qq.com</strong>域服务器，重复上面的动作，进行查询，直至找到<strong>www.baidu.com</strong> </p></li><li><p>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p></li></ol><p><strong>TIP</strong>: 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。<br><img src="https://pic4.zhimg.com/80/7fcd81756bdc8b52ade0531402c43e43_720w.jpg" alt="解析过程"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在日常的开发和问题排查中，难免会遇到DNS解析的问题，尤其是在云计算中，内部组件因为DNS解析问题导致的问题层出不穷。借此，总计一下基本的DNS原理，以及日常生活中，一次DNS解析的过程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="network" scheme="https://dpcfury.github.io/categories/network/"/>
    
    
      <category term="dns" scheme="https://dpcfury.github.io/tags/dns/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1092] Shortest Common Supersequence</title>
    <link href="https://dpcfury.github.io/shortest-common-supersequence.html/"/>
    <id>https://dpcfury.github.io/shortest-common-supersequence.html/</id>
    <published>2020-04-07T15:56:26.000Z</published>
    <updated>2020-04-07T16:05:09.685Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/shortest-common-supersequence/" target="_blank" rel="noopener">Leetcode 1092. Shortest Common Supersequence</a><br>这道题延伸自最短编辑距离问题（Edit Distance），题目唯一描述不同的是，需要求出最终的结果，而不仅仅是最短的长度。结题的思路还是先去找问题的收敛入口，进而找到子问题和最优结构，推导出表达式后，再自定向上求解。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>和普通的do不同，这里需要计算出最终的superSequence结果，乍一看会有点懵，但是其实道理相同，还是<br>先令dp[i][j] 为str1前i个字符和str2的前j个字符串，其最短的superSequence长度；<br>那么表达式为：</p><ul><li>case0: s.charAt[i] == s.charAt[j]，则dp[i][j] = dp[i+1][j-1] +1</li><li>case1: s.charAt[i] != s.charAt[j]，则dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])+1</li></ul><p>然后从后往前，分批便利str1和str2，如果当前两个字符串位置上的字符相同，就把字符添加到结果，如果不同，选择dp[i-1][j] 和dp[i][j-1]中小的那个，添加对应的字符即可。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>approach1 : 最初的写法，空间会超<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestCommonSupersequence1</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = str1.length();</span><br><span class="line">        <span class="keyword">int</span> n = str2.length();</span><br><span class="line">        String[][] dp = <span class="keyword">new</span> String[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = str1.substring(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = str2.substring(<span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c1 = str1.charAt(i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">char</span> c2 = str2.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + c1;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    String s1 = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    String s2 = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    String s3 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    String res = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">if</span> (s1.length() &lt; s2.length()) res = s1 + c2;</span><br><span class="line">                    <span class="keyword">else</span> res = s2 + c1;</span><br><span class="line">                    <span class="keyword">if</span> (s3.length() + <span class="number">2</span> &lt; res.length()) res = s3 + c1 + c2;</span><br><span class="line">                    dp[i][j] = res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>approach2: 优化写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestCommonSupersequence</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = str1.length();</span><br><span class="line">        <span class="keyword">int</span> j = str2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = shortestCS(str1, str2);</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i - <span class="number">1</span>) == str2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                str.append(str1.charAt(i - <span class="number">1</span>));</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &lt; dp[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                str.append(str1.charAt(i - <span class="number">1</span>));</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str.append(str2.charAt(j - <span class="number">1</span>));</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            str.append(str1.charAt(i - <span class="number">1</span>));</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            str.append(str2.charAt(j - <span class="number">1</span>));</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/shortest-common-supersequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1092. Shortest Common Supersequence&lt;/a&gt;&lt;br&gt;这道题延伸自最短编辑距离问题（Edit Distance），题目唯一描述不同的是，需要求出最终的结果，而不仅仅是最短的长度。结题的思路还是先去找问题的收敛入口，进而找到子问题和最优结构，推导出表达式后，再自定向上求解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[48] Rotate Image</title>
    <link href="https://dpcfury.github.io/rotate-image.html/"/>
    <id>https://dpcfury.github.io/rotate-image.html/</id>
    <published>2020-04-07T15:50:07.000Z</published>
    <updated>2020-04-07T16:27:20.753Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/rotate-image/" target="_blank" rel="noopener">Leetcode 48. Rotate Image</a><br>题目要求在原地对二维矩阵中的元素进行顺时针90度的旋转，而且不能借助额外的辅助空间（比如创建一个同等大小的二维数组）。这题通过纸上多画图尝试尝试，就能找到规律，我们所能做的操作只有行和列操作，以及围绕对角线的操作，试着试着这题的答案就可以出来了。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对二维数组的行进行围绕中间轴的上线交换，再围绕对角线对元素进行交换，就能得到最终的结果。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = matrix[i];</span><br><span class="line">            matrix[i] = matrix[n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/rotate-image/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 48. Rotate Image&lt;/a&gt;&lt;br&gt;题目要求在原地对二维矩阵中的元素进行顺时针90度的旋转，而且不能借助额外的辅助空间（比如创建一个同等大小的二维数组）。这题通过纸上多画图尝试尝试，就能找到规律，我们所能做的操作只有行和列操作，以及围绕对角线的操作，试着试着这题的答案就可以出来了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="matrix" scheme="https://dpcfury.github.io/tags/matrix/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[516] Longest Palindromic Subsequence</title>
    <link href="https://dpcfury.github.io/longest-palindromic-subsequence.html/"/>
    <id>https://dpcfury.github.io/longest-palindromic-subsequence.html/</id>
    <published>2020-04-06T14:11:08.000Z</published>
    <updated>2020-04-06T14:33:22.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">Leetcode 516. Longest Palindromic Subsequence</a><br>这题也是经典的动态规划题，同样遵循通用的解体思路，首先是理解题目的意思，然后在寻找问题规模缩小的入口，慢慢推导出子问题和最优结构，从而总结出表达式，然后自底向上实现。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先，回文字符串的特点要理解，对单个字符而言，都是长度为1的回文串；<br>其次，我们能够缩小的范围只有字符中字串的大小，即字串的开始和终止位置；<br>令dp[i][j]为字符串subString(i,j+1)中，包含的回文子穿最大长度；<br>进而，可以发现，计算dp[i][j]的方法如下：</p><ul><li>case0: s.charAt[i] == s.charAt[j]，则dp[i][j] = dp[i+1][j-1] +2</li><li>case1: s.charAt[i] != s.charAt[j]，则dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])</li></ul><p>那么最终的我们求的dp[0][s.length()-1]即为最终的解。</p><p>但是，我们如何自底向上进行求解呢，已知dp[i][i]的初始值为1，我们可以从不同长度的回文串开始着手，<br>首先求长度间隙为1（即dp[i][i]），然后长度间隙为2 … 到长度间隙为n-1。一步一步，慢慢实现自底向上。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>下面给出我个人实现的一种算法，目前并未进行优化，理论上这种时间遍历的消耗可以提前削减<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n - <span class="number">1</span>; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start + len &lt; n; start++) &#123;</span><br><span class="line">                <span class="keyword">int</span> end = start + len;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(start) == s.charAt(end)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (start + <span class="number">1</span> == end) &#123;</span><br><span class="line">                        dp[start][end] = <span class="number">2</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[start][end] = dp[start + <span class="number">1</span>][end - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[start][end] = Math.max(dp[start + <span class="number">1</span>][end], dp[start][end - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 516. Longest Palindromic Subsequence&lt;/a&gt;&lt;br&gt;这题也是经典的动态规划题，同样遵循通用的解体思路，首先是理解题目的意思，然后在寻找问题规模缩小的入口，慢慢推导出子问题和最优结构，从而总结出表达式，然后自底向上实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
</feed>
