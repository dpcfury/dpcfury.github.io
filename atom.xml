<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DPC&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/bfa2adcbfd5883f9905426b1399816ee</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dpcfury.github.io/"/>
  <updated>2020-03-23T14:45:15.623Z</updated>
  <id>https://dpcfury.github.io/</id>
  
  <author>
    <name>杜鹏程</name>
    <email>dpcspark@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode[876] Middle of the Linked List</title>
    <link href="https://dpcfury.github.io/leetcode-middle-of-the-linked-list.html/"/>
    <id>https://dpcfury.github.io/leetcode-middle-of-the-linked-list.html/</id>
    <published>2020-03-23T14:35:01.000Z</published>
    <updated>2020-03-23T14:45:15.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">Leetcode 876. Middle of the Linked List</a><br>题目目的是求一个非空链表中，从中间元素开始往后的截取一半列表。比较直观的就是设立两个元素以相差一倍的速度进行遍历，当跑的快的达到null，或者即将为null，再返回慢的元素或慢元素的下一个位置。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode q = head.next;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q == <span class="keyword">null</span> || q.next == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q == <span class="keyword">null</span> ? p : p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/middle-of-the-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 876. Middle of the Linked List&lt;/a&gt;&lt;br&gt;题目目的是求一个非空链表中，从中间元素开始往后的截取一半列表。比较直观的就是设立两个元素以相差一倍的速度进行遍历，当跑的快的达到null，或者即将为null，再返回慢的元素或慢元素的下一个位置。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="linked list" scheme="https://dpcfury.github.io/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[111] Minimum Depth of Binary Tree</title>
    <link href="https://dpcfury.github.io/leetcode-minimum-depth-of-binary-tree.html/"/>
    <id>https://dpcfury.github.io/leetcode-minimum-depth-of-binary-tree.html/</id>
    <published>2020-03-22T13:46:45.000Z</published>
    <updated>2020-03-22T13:50:32.830Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">Leetcode 111. Minimum Depth of Binary Tree</a><br>题目要求计算二叉树从根节点开始，到叶子阶段的最短距离。解法同样是左右子树递归进行计算，但是要注意为空情况下，子树的最小深度应该设置为无穷大，而不是0。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> minLeft = root.left != <span class="keyword">null</span> ? minDepth(root.left) : Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minRight = root.right != <span class="keyword">null</span> ? minDepth(root.right) : Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> Math.min(minLeft, minRight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 111. Minimum Depth of Binary Tree&lt;/a&gt;&lt;br&gt;题目要求计算二叉树从根节点开始，到叶子阶段的最短距离。解法同样是左右子树递归进行计算，但是要注意为空情况下，子树的最小深度应该设置为无穷大，而不是0。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[110] Balanced Binary Tree</title>
    <link href="https://dpcfury.github.io/leetcode-balanced-binary-tree.html/"/>
    <id>https://dpcfury.github.io/leetcode-balanced-binary-tree.html/</id>
    <published>2020-03-22T13:24:11.000Z</published>
    <updated>2020-03-22T13:27:52.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">Leetcode 110. Balanced Binary Tree</a><br>题目给出一个二叉树，需要判断这颗树是不是平衡二叉树，即对树的每个节点而言，其左右子树高度差不能超过1。第一感觉就是使用递归，从当前节点判断，除了要左右两颗子树都是平衡二叉树之外，还需要一个条件，即左右子树的高度不能像差超过1，因此需要计算树的高度。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isBalanced(root.left) &amp;&amp; isBalanced(root.right))</span><br><span class="line">            <span class="keyword">return</span> Math.abs(heightOfTree(root.left) - heightOfTree(root.right)) &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">heightOfTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ldep = heightOfTree(root.left);</span><br><span class="line">        <span class="keyword">int</span> rdep = heightOfTree(root.right);</span><br><span class="line">        <span class="keyword">if</span> (ldep &gt; rdep) &#123;</span><br><span class="line">            <span class="keyword">return</span> ldep + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rdep + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/balanced-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 110. Balanced Binary Tree&lt;/a&gt;&lt;br&gt;题目给出一个二叉树，需要判断这颗树是不是平衡二叉树，即对树的每个节点而言，其左右子树高度差不能超过1。第一感觉就是使用递归，从当前节点判断，除了要左右两颗子树都是平衡二叉树之外，还需要一个条件，即左右子树的高度不能像差超过1，因此需要计算树的高度。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[200] Number of Islands</title>
    <link href="https://dpcfury.github.io/leetcode-number-of-islands.html/"/>
    <id>https://dpcfury.github.io/leetcode-number-of-islands.html/</id>
    <published>2020-03-22T12:39:04.000Z</published>
    <updated>2020-03-23T14:44:54.002Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">Leetcode 200. Number of Islands</a><br>题目意思：一个二维字符数组，其中‘1’代表的是陆地，上下左右相邻的陆地构成一个岛，求解这幅地图中的独立小岛个数。这题和回溯的相似度很高，但是比回溯要更为简单，直观的解法就是，找到小岛的一块陆地，从上下左右分别去拓展这个小岛，通过一个标记二维数组标记当前的拓展情况，如果已经拓展则进行忽略，当二维字符数组的每个元素都遍历完成，求得小岛数就是最终的答案。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length==<span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    traversal(grid, row, col, i, j, visited);</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col || grid[i][j] != <span class="string">'1'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i][j]) &#123;</span><br><span class="line">                visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                traversal(grid, row, col, i - <span class="number">1</span>, j, visited);</span><br><span class="line">                traversal(grid, row, col, i + <span class="number">1</span>, j, visited);</span><br><span class="line">                traversal(grid, row, col, i, j - <span class="number">1</span>, visited);</span><br><span class="line">                traversal(grid, row, col, i, j + <span class="number">1</span>, visited);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-islands/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 200. Number of Islands&lt;/a&gt;&lt;br&gt;题目意思：一个二维字符数组，其中‘1’代表的是陆地，上下左右相邻的陆地构成一个岛，求解这幅地图中的独立小岛个数。这题和回溯的相似度很高，但是比回溯要更为简单，直观的解法就是，找到小岛的一块陆地，从上下左右分别去拓展这个小岛，通过一个标记二维数组标记当前的拓展情况，如果已经拓展则进行忽略，当二维字符数组的每个元素都遍历完成，求得小岛数就是最终的答案。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[108] Convert Sorted Array to Binary Search Tree</title>
    <link href="https://dpcfury.github.io/convert-sorted-array-to-binary-search-tree.html/"/>
    <id>https://dpcfury.github.io/convert-sorted-array-to-binary-search-tree.html/</id>
    <published>2020-03-22T05:36:55.000Z</published>
    <updated>2020-03-22T07:34:25.558Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">Leetcode 108. Convert Sorted Array to Binary Search Tree</a><br>题目意思：通过一个有序的数组，构建一个高度平衡的二叉搜索树。具体解法比较直观的就是，通过二分法，将数组从中间一份为二，前半部分为左子树，右半部分为右子树，中间元素为树的根，这样递归去构建左右子树技能得到最终的解。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; i) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[m]);</span><br><span class="line">        root.left = sortedArrayToBST(nums, i, m - <span class="number">1</span>);</span><br><span class="line">        root.right = sortedArrayToBST(nums, m + <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 108. Convert Sorted Array to Binary Search Tree&lt;/a&gt;&lt;br&gt;题目意思：通过一个有序的数组，构建一个高度平衡的二叉搜索树。具体解法比较直观的就是，通过二分法，将数组从中间一份为二，前半部分为左子树，右半部分为右子树，中间元素为树的根，这样递归去构建左右子树技能得到最终的解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="BST" scheme="https://dpcfury.github.io/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>letcode[365]Water and Jug Problem</title>
    <link href="https://dpcfury.github.io/leetcode-water-jug-problem.html/"/>
    <id>https://dpcfury.github.io/leetcode-water-jug-problem.html/</id>
    <published>2020-03-21T07:59:14.000Z</published>
    <updated>2020-03-21T08:13:28.442Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">Leetcode 365. Water and Jug Problem</a><br> 题目直面意思，通过两个容器，是否可以计算出指定体积的水，一开始以为什么规律题，折腾了半天，后面看解题思路。这类题目其实属于数学题，即通过机选x,y的最大公约数，并看Z是否能整出这个最大公约数进行判断。</p></blockquote><a id="more"></a><h4 id="参考思路："><a href="#参考思路：" class="headerlink" title="参考思路："></a>参考思路：</h4><p> <a href="https://zhuanlan.zhihu.com/p/68987055" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68987055</a></p><h4 id="问题转换为gcd"><a href="#问题转换为gcd" class="headerlink" title="问题转换为gcd"></a>问题转换为gcd</h4><p> 即如何求两个正整数的最大公约数，思路如下：<a href="https://blog.csdn.net/wujingchangye/article/details/88542193" target="_blank" rel="noopener">https://blog.csdn.net/wujingchangye/article/details/88542193</a></p><blockquote><ol><li>假设有两个数a和b，其中a是不小于b的数，记a被b除的余数为r，则a = b*q + r。</li><li>假设a和b的一个约数为u，那么a和b都能被u整除，则a = su b = tu，s和t都是整数。</li><li>r = a - bq = su - (tu)q = (s - tq)u，所以r也能被u整除</li><li>所以a和b的任一约数同时也是r的约数（每次取余，直到余数为0）。**</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = p % q;</span><br><span class="line">    <span class="keyword">return</span> gcd(q, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目完整解答"><a href="#题目完整解答" class="headerlink" title="题目完整解答"></a>题目完整解答</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x + y &lt; z) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == z || y == z || x + y == z) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> z % gcd(x, y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/water-and-jug-problem/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 365. Water and Jug Problem&lt;/a&gt;&lt;br&gt; 题目直面意思，通过两个容器，是否可以计算出指定体积的水，一开始以为什么规律题，折腾了半天，后面看解题思路。这类题目其实属于数学题，即通过机选x,y的最大公约数，并看Z是否能整出这个最大公约数进行判断。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="math" scheme="https://dpcfury.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode.cn 最小的k个数</title>
    <link href="https://dpcfury.github.io/leetcode-cn-k-smallest-num.html/"/>
    <id>https://dpcfury.github.io/leetcode-cn-k-smallest-num.html/</id>
    <published>2020-03-20T13:50:59.000Z</published>
    <updated>2020-03-20T13:56:25.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/submissions/" target="_blank" rel="noopener">Leetcode中国每日一题</a>取自剑指offer<br>题目意思就是从一个一维数组中，找出k个最小的数，每次看到这个K，最容易想到的就是堆排序，通过构造大顶堆或小顶堆分别来找最小的k个数和最大的k个数。而Java中天生有支持堆排序的数据结构，PriorityQueue，只要指定K容量的堆，通过比较堆顶元素与当前数组遍历元素，如果小于堆顶，则堆顶出列，插入当前遍历元素，遍历完成之后，堆中的K个数即我们要找的最小K个数。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || k &gt; arr.length || k == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() != k) &#123;</span><br><span class="line">                queue.offer(arr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &lt; queue.peek()) &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.offer(arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result[i] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode中国每日一题&lt;/a&gt;取自剑指offer&lt;br&gt;题目意思就是从一个一维数组中，找出k个最小的数，每次看到这个K，最容易想到的就是堆排序，通过构造大顶堆或小顶堆分别来找最小的k个数和最大的k个数。而Java中天生有支持堆排序的数据结构，PriorityQueue，只要指定K容量的堆，通过比较堆顶元素与当前数组遍历元素，如果小于堆顶，则堆顶出列，插入当前遍历元素，遍历完成之后，堆中的K个数即我们要找的最小K个数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="heap sort" scheme="https://dpcfury.github.io/tags/heap-sort/"/>
    
      <category term="priority queye" scheme="https://dpcfury.github.io/tags/priority-queye/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[409]Longest Palindrome</title>
    <link href="https://dpcfury.github.io/leetcode-longest-palindrome.html/"/>
    <id>https://dpcfury.github.io/leetcode-longest-palindrome.html/</id>
    <published>2020-03-19T15:01:25.000Z</published>
    <updated>2020-03-19T15:09:16.367Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/longest-palindrome/" target="_blank" rel="noopener">409. Longrest Palindrome</a><br>给定一个字符串，计算其包含的字符可组成的最长回文字符串，主要是观察下规律，看如何用字符去组织回文字符串，针对单数的字符、双数的字符，应该如何处理。个人给出的代码其实很臃肿，可以优化的地方很多，往上有种bitwise的做法，不是很理解，暂且不放上来。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">int</span> n = count.get(c);</span><br><span class="line">                count.put(c, n + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> once = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : count.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (once) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    once = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> n = entry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) num += n;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (once) &#123;</span><br><span class="line">                        num += (n - <span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        num += n;</span><br><span class="line">                        once=<span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;409. Longrest Palindrome&lt;/a&gt;&lt;br&gt;给定一个字符串，计算其包含的字符可组成的最长回文字符串，主要是观察下规律，看如何用字符去组织回文字符串，针对单数的字符、双数的字符，应该如何处理。个人给出的代码其实很臃肿，可以优化的地方很多，往上有种bitwise的做法，不是很理解，暂且不放上来。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="array" scheme="https://dpcfury.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[100]Same Tree</title>
    <link href="https://dpcfury.github.io/leetcode-same-tree.html/"/>
    <id>https://dpcfury.github.io/leetcode-same-tree.html/</id>
    <published>2020-03-19T13:25:56.000Z</published>
    <updated>2020-03-19T13:30:10.033Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">100. Same Tree</a><br>判断两颗二叉树是否完全相同，即对应位置的结构以及节点的值需要相同，才能判断为相同的书结构，这类问题第一印象就是递归，将问题拆分为左右子树的比较，再加边缘条件的判断，司思路很清晰。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (p.val == q.val) <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/same-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;100. Same Tree&lt;/a&gt;&lt;br&gt;判断两颗二叉树是否完全相同，即对应位置的结构以及节点的值需要相同，才能判断为相同的书结构，这类问题第一印象就是递归，将问题拆分为左右子树的比较，再加边缘条件的判断，司思路很清晰。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="tree" scheme="https://dpcfury.github.io/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[107]Binary Tree Level Order Travesal II</title>
    <link href="https://dpcfury.github.io/leetcode-binary-tree-level-order-travesalII.html/"/>
    <id>https://dpcfury.github.io/leetcode-binary-tree-level-order-travesalII.html/</id>
    <published>2020-03-19T13:03:44.000Z</published>
    <updated>2020-03-19T13:07:36.554Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. Binary Tree Level Order Travesal II</a><br>题目意思就是二叉树的层次遍历换了种说法，从上往下的层次遍历，感觉上变成了从下往上的层次遍历，其实按照从上往下的顺序正常层次遍历，然后对每一层获取的结果列表进行reverse即可。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; layer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                layer.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : layer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            results.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(results);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-level-order-traversal-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;107. Binary Tree Level Order Travesal II&lt;/a&gt;&lt;br&gt;题目意思就是二叉树的层次遍历换了种说法，从上往下的层次遍历，感觉上变成了从下往上的层次遍历，其实按照从上往下的顺序正常层次遍历，然后对每一层获取的结果列表进行reverse即可。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[836] Rectangle Overlap</title>
    <link href="https://dpcfury.github.io/leetcode-rectangl-overlap.html/"/>
    <id>https://dpcfury.github.io/leetcode-rectangl-overlap.html/</id>
    <published>2020-03-18T13:48:28.000Z</published>
    <updated>2020-03-18T13:56:50.068Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/rectangle-overlap/" target="_blank" rel="noopener">836. Rectangle</a><br>给出两个矩形的左下角坐标，以及右上角坐标，判断两个矩形是否重叠，只要从横坐标和纵坐标构成的线段判断是否重叠，再做逻辑与运算，即能判断长方形是否重叠，只要整理好判断条件即可</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = rec1[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y1 = rec1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x2 = rec1[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> y2 = rec1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x11 = rec2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y11 = rec2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x22 = rec2[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> y22 = rec2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> xOverlap = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> yOverlap = <span class="keyword">false</span>;</span><br><span class="line">        xOverlap = (x11 &gt;= x1 &amp;&amp; x11 &lt; x2) || (x22 &gt; x1 &amp;&amp; x22 &lt;= x2) || (x11 &lt;= x1 &amp;&amp; x22 &gt;= x2);</span><br><span class="line">        yOverlap = (y11 &gt;= y1 &amp;&amp; y11 &lt; y2) || (y22 &gt; y1 &amp;&amp; y22 &lt;= y2) || (y11 &lt;= y1 &amp;&amp; y22 &gt;= y2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xOverlap &amp;&amp; yOverlap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实在这种判断条件比较多的情况下，可以看看是否可以用取反进行优化，比如，用判断x轴和y轴不重叠的条件，再取非：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = rec1[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y1 = rec1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x2 = rec1[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> y2 = rec1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x11 = rec2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y11 = rec2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x22 = rec2[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> y22 = rec2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> xOverlap = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> yOverlap = <span class="keyword">false</span>;</span><br><span class="line">        xOverlap = !(x22 &lt;= x1 || x11 &gt;= x2);</span><br><span class="line">        yOverlap = !(y22 &lt;= y1 || y11 &gt;= y2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xOverlap &amp;&amp; yOverlap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/rectangle-overlap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;836. Rectangle&lt;/a&gt;&lt;br&gt;给出两个矩形的左下角坐标，以及右上角坐标，判断两个矩形是否重叠，只要从横坐标和纵坐标构成的线段判断是否重叠，再做逻辑与运算，即能判断长方形是否重叠，只要整理好判断条件即可&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="array" scheme="https://dpcfury.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[112] path-sum</title>
    <link href="https://dpcfury.github.io/leetcode-path-sum.html/"/>
    <id>https://dpcfury.github.io/leetcode-path-sum.html/</id>
    <published>2020-03-17T13:44:21.000Z</published>
    <updated>2020-03-18T13:59:47.987Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">112. Path Sum</a><br> 这题属于Tree类最基本的题目，只要画好图，考虑好递归和边界即可<br><a id="more"></a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum - root.val == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/path-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;112. Path Sum&lt;/a&gt;&lt;br&gt; 这题属于Tree类最基本的题目，只要画好图，考虑好递归和边界即可&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="tree" scheme="https://dpcfury.github.io/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>kolla运行docker服务</title>
    <link href="https://dpcfury.github.io/kolla-start-docker.html/"/>
    <id>https://dpcfury.github.io/kolla-start-docker.html/</id>
    <published>2020-03-11T12:40:18.000Z</published>
    <updated>2020-03-11T12:50:28.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>kolla制作的docker镜像，通过juju部署服务，发现容器在juju中的状态一直是重启状态，检查启动日志，成功运行了进程脚本，于是从镜像入手进行分析。<br><a id="more"></a></p></blockquote><h3 id="kolla运行docker"><a href="#kolla运行docker" class="headerlink" title="kolla运行docker"></a>kolla运行docker</h3><p> 通过kolla启动docekr，运行的是一个启动命令脚本，作为docker的1号进程，而docker判断容器是否运行的依据就是这个启动进程是否存在，即docker中存在的前台和后台概念。<br> 按照这种道理，需要在启动命令中直接进行容器中服务的启动，但是初次之外，还有个trick操作。</p><h3 id="挂起pid-1的进程"><a href="#挂起pid-1的进程" class="headerlink" title="挂起pid=1的进程"></a>挂起pid=1的进程</h3><p> 即在启动命令脚本的最后，加入一行：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p><p> 其原理便是，通过tail和top这种挂起的服务，保持pid=1的进程不会结束，从而实现docker容器的后台运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;kolla制作的docker镜像，通过juju部署服务，发现容器在juju中的状态一直是重启状态，检查启动日志，成功运行了进程脚本，于是从镜像入手进行分析。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="docekr" scheme="https://dpcfury.github.io/categories/docekr/"/>
    
    
      <category term="docker" scheme="https://dpcfury.github.io/tags/docker/"/>
    
      <category term="kolla" scheme="https://dpcfury.github.io/tags/kolla/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[88] Merge Sorted Array</title>
    <link href="https://dpcfury.github.io/leetcode-merge-sorted-array.html/"/>
    <id>https://dpcfury.github.io/leetcode-merge-sorted-array.html/</id>
    <published>2020-03-11T12:28:25.000Z</published>
    <updated>2020-03-11T12:37:45.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. Merge Sorted Array</a><br>记得好像是剑指offer上一个很基础的题目，非常适合休闲和找状态，特别干了一天比较累的情况下刷着玩玩，思路也很简单，就是避免数组内的移动，从后往前安排元素，<br>时间复杂度控制在o(m+n)<br><a id="more"></a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt;= nums2[j]) &#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k] = nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                nums1[k] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;88. Merge Sorted Array&lt;/a&gt;&lt;br&gt;记得好像是剑指offer上一个很基础的题目，非常适合休闲和找状态，特别干了一天比较累的情况下刷着玩玩，思路也很简单，就是避免数组内的移动，从后往前安排元素，&lt;br&gt;时间复杂度控制在o(m+n)&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[67]add binay</title>
    <link href="https://dpcfury.github.io/leetcode-add-binary.html/"/>
    <id>https://dpcfury.github.io/leetcode-add-binary.html/</id>
    <published>2020-03-10T14:28:44.000Z</published>
    <updated>2020-03-10T14:39:31.160Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/add-binary/" target="_blank" rel="noopener">67. Add Binary</a><br>  这题非常中规中矩，组织好逻辑就可以一步到位，就是简单的运算<br>  <a id="more"></a></p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = a.length() - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> j = b.length() - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">boolean</span> carry = <span class="keyword">false</span>;</span><br><span class="line">       StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (a.charAt(i) == <span class="string">'1'</span> &amp;&amp; b.charAt(j) == <span class="string">'1'</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">                   str.append(<span class="string">'1'</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   str.append(<span class="string">'0'</span>);</span><br><span class="line">                   carry = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.charAt(i) == <span class="string">'1'</span> || b.charAt(j) == <span class="string">'1'</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">                   str.append(<span class="string">'0'</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   str.append(<span class="string">'1'</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">char</span> c = carry ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">               str.append(c);</span><br><span class="line">               carry = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           i--;</span><br><span class="line">           j--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (i &lt; <span class="number">0</span> &amp;&amp; j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (carry)</span><br><span class="line">               str.append(<span class="string">'1'</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">           str.append(add(b, j, carry));</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           str.append(add(a, i, carry));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> String <span class="title">add</span><span class="params">(String s, <span class="keyword">int</span> j, <span class="keyword">boolean</span> carry)</span> </span>&#123;</span><br><span class="line">       StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">           <span class="keyword">char</span> c = s.charAt(j);</span><br><span class="line">           <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">               str.append(c == <span class="string">'1'</span> ? <span class="string">'0'</span> : <span class="string">'1'</span>);</span><br><span class="line">               <span class="keyword">if</span> (c == <span class="string">'0'</span>)</span><br><span class="line">                   carry = <span class="keyword">false</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               str.append(c == <span class="string">'1'</span> ? <span class="string">'1'</span> : <span class="string">'0'</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (carry)</span><br><span class="line">           str.append(<span class="string">'1'</span>);</span><br><span class="line">       <span class="keyword">return</span> str.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-binary/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;67. Add Binary&lt;/a&gt;&lt;br&gt;  这题非常中规中矩，组织好逻辑就可以一步到位，就是简单的运算&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[14]longeest common prefix</title>
    <link href="https://dpcfury.github.io/leetcode-longest-common-prefix.html/"/>
    <id>https://dpcfury.github.io/leetcode-longest-common-prefix.html/</id>
    <published>2020-02-29T13:29:02.000Z</published>
    <updated>2020-03-10T13:09:49.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. Longest Common Prefix</a><br>这题比较有意思，我开始给出的算法属于很直接的那种，针对规则编码，其实这个问题可以进行总结和分析，会有更深的收获<br><a id="more"></a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = i &lt; strs[<span class="number">0</span>].length() ? strs[<span class="number">0</span>].charAt(i) : <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == s.length() || s.charAt(i) != c) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                result = result + c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>官方解法</p><h4 id="approach-1-Horizontal-Scan"><a href="#approach-1-Horizontal-Scan" class="headerlink" title="approach 1. Horizontal Scan"></a>approach 1. Horizontal Scan</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    String prefix = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">        <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">            prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (prefix.isEmpty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较形式化的防范，从approach1 的LCP公式衍生而来</p><h4 id="approach-2-Divide-and-Conquer"><a href="#approach-2-Divide-and-Conquer" class="headerlink" title="approach 2. Divide and Conquer"></a>approach 2. Divide and Conquer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;    </span><br><span class="line">        <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span> , strs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        String lcpLeft =   longestCommonPrefix(strs, l , mid);</span><br><span class="line">        String lcpRight =  longestCommonPrefix(strs, mid + <span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">commonPrefix</span><span class="params">(String left,String right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Math.min(left.length(), right.length());       </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( left.charAt(i) != right.charAt(i) )</span><br><span class="line">            <span class="keyword">return</span> left.substring(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.substring(<span class="number">0</span>, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更脱俗的一个解法是，利用binary search的思路，缩小搜索范围</p><h4 id="approach-3-binary-search"><a href="#approach-3-binary-search" class="headerlink" title="approach 3. binary search"></a>approach 3. binary search</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (String str : strs)</span><br><span class="line">        minLen = Math.min(minLen, str.length());</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> high = minLen;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isCommonPrefix(strs, middle))</span><br><span class="line">            low = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, (low + high) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    String str1 = strs[<span class="number">0</span>].substring(<span class="number">0</span>,len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (!strs[i].startsWith(str1))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-prefix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;14. Longest Common Prefix&lt;/a&gt;&lt;br&gt;这题比较有意思，我开始给出的算法属于很直接的那种，针对规则编码，其实这个问题可以进行总结和分析，会有更深的收获&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[38] count and say</title>
    <link href="https://dpcfury.github.io/count_and_say.html/"/>
    <id>https://dpcfury.github.io/count_and_say.html/</id>
    <published>2020-02-29T06:50:22.000Z</published>
    <updated>2020-02-29T07:05:07.957Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. Roman to Integer</a><br> 这道题最重要的还是能读懂，英文意思就是，每一当前n计算得到的结果，取决于之n-1计算得到的记过，所以第一感觉是递归。按照题目的滚则，“1”就是一个1，“2”就是一个2名， “1121”就是两个1，一个2，一个1，这么去报数。<br> <a id="more"></a><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">       String s = countAndSay(n - <span class="number">1</span>) + <span class="string">'*'</span>;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">       String t = <span class="string">""</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (s.charAt(i) == s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               t = t + count + s.charAt(i);</span><br><span class="line">               count = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> t;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/roman-to-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;13. Roman to Integer&lt;/a&gt;&lt;br&gt; 这道题最重要的还是能读懂，英文意思就是，每一当前n计算得到的结果，取决于之n-1计算得到的记过，所以第一感觉是递归。按照题目的滚则，“1”就是一个1，“2”就是一个2名， “1121”就是两个1，一个2，一个1，这么去报数。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[13] roman to integer</title>
    <link href="https://dpcfury.github.io/leetcodekeep.html/"/>
    <id>https://dpcfury.github.io/leetcodekeep.html/</id>
    <published>2020-02-25T14:26:08.000Z</published>
    <updated>2020-02-29T13:20:51.047Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. Roman to Integer</a><br>这道题其实有几个很精妙的解法，下面自己做的是一种很傻瓜式的方式<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; index = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        index.put(<span class="string">"I"</span>, <span class="number">1</span>);</span><br><span class="line">        index.put(<span class="string">"V"</span>, <span class="number">5</span>);</span><br><span class="line">        index.put(<span class="string">"X"</span>, <span class="number">10</span>);</span><br><span class="line">        index.put(<span class="string">"L"</span>, <span class="number">50</span>);</span><br><span class="line">        index.put(<span class="string">"C"</span>, <span class="number">100</span>);</span><br><span class="line">        index.put(<span class="string">"D"</span>, <span class="number">500</span>);</span><br><span class="line">        index.put(<span class="string">"M"</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特殊的组合</span></span><br><span class="line">        index.put(<span class="string">"IV"</span>, <span class="number">4</span>);</span><br><span class="line">        index.put(<span class="string">"IX"</span>, <span class="number">9</span>);</span><br><span class="line">        index.put(<span class="string">"XL"</span>, <span class="number">40</span>);</span><br><span class="line">        index.put(<span class="string">"XC"</span>, <span class="number">90</span>);</span><br><span class="line">        index.put(<span class="string">"CD"</span>, <span class="number">400</span>);</span><br><span class="line">        index.put(<span class="string">"CM"</span>, <span class="number">900</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] numbers = s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span> (numbers.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> index.get(s);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; numbers.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == numbers.length - <span class="number">1</span>) &#123;</span><br><span class="line">                result += index.get(String.valueOf(numbers[i]));</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                System.out.println("当前numbers[i]的值为：" + String.valueOf(numbers[i]));</span></span><br><span class="line">                <span class="keyword">int</span> x = index.get(String.valueOf(numbers[i]));</span><br><span class="line">                <span class="keyword">int</span> y = index.get(String.valueOf(numbers[i + <span class="number">1</span>]));</span><br><span class="line">                <span class="keyword">int</span> xy = index.get(s.substring(i, i + <span class="number">2</span>)) != <span class="keyword">null</span> ? index.get(s.substring(i, i + <span class="number">2</span>)) : <span class="number">0</span>;</span><br><span class="line"><span class="comment">//                System.out.println("当前x的值为：" + x);</span></span><br><span class="line"><span class="comment">//                System.out.println("当前y的值为：" + y);</span></span><br><span class="line"><span class="comment">//                System.out.println("当前xy的值为：" + xy);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (xy &gt; x &amp;&amp; xy &lt; y) &#123;</span><br><span class="line">                    current = xy;</span><br><span class="line">                    result += current;</span><br><span class="line">                    i += <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result += x;</span><br><span class="line">                    current = x;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>再来一个python的解法，其实更简便，就是针对规则对代码结构进行优化，不用做这么多的映射<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">      romanToIntMap = &#123;</span><br><span class="line">          <span class="string">"I"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">"V"</span>: <span class="number">5</span>,</span><br><span class="line">          <span class="string">"X"</span>: <span class="number">10</span>,</span><br><span class="line">          <span class="string">"L"</span>: <span class="number">50</span>,</span><br><span class="line">          <span class="string">"C"</span>: <span class="number">100</span>,</span><br><span class="line">          <span class="string">"D"</span>: <span class="number">500</span>,</span><br><span class="line">          <span class="string">"M"</span>: <span class="number">1000</span></span><br><span class="line">      &#125;</span><br><span class="line">      value = <span class="number">0</span></span><br><span class="line">      tracker = [s[<span class="number">0</span>]]</span><br><span class="line">      <span class="keyword">for</span> c <span class="keyword">in</span> s: </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">"V"</span> <span class="keyword">or</span> c == <span class="string">"X"</span>) <span class="keyword">and</span> (tracker[<span class="number">-1</span>] == <span class="string">"I"</span>):</span><br><span class="line">          value += romanToIntMap[c] - <span class="number">2</span> * romanToIntMap[tracker[<span class="number">-1</span>]]</span><br><span class="line">        <span class="keyword">elif</span> (c == <span class="string">"L"</span> <span class="keyword">or</span> c == <span class="string">"C"</span>) <span class="keyword">and</span> (tracker[<span class="number">-1</span>] == <span class="string">"X"</span>):</span><br><span class="line">          value += romanToIntMap[c] - <span class="number">2</span> * romanToIntMap[tracker[<span class="number">-1</span>]]</span><br><span class="line">        <span class="keyword">elif</span> (c == <span class="string">"D"</span> <span class="keyword">or</span> c == <span class="string">"M"</span>) <span class="keyword">and</span> (tracker[<span class="number">-1</span>] == <span class="string">"C"</span>):</span><br><span class="line">          value += romanToIntMap[c] - <span class="number">2</span> * romanToIntMap[tracker[<span class="number">-1</span>]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          value += romanToIntMap[c]</span><br><span class="line">        tracker.append(c)</span><br><span class="line">      <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/roman-to-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;13. Roman to Integer&lt;/a&gt;&lt;br&gt;这道题其实有几个很精妙的解法，下面自己做的是一种很傻瓜式的方式&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>curtin装机流</title>
    <link href="https://dpcfury.github.io/null.html/"/>
    <id>https://dpcfury.github.io/null.html/</id>
    <published>2020-01-25T03:13:14.000Z</published>
    <updated>2020-01-25T03:13:14.663Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python多线程同步</title>
    <link href="https://dpcfury.github.io/python_concurrent_lock.html/"/>
    <id>https://dpcfury.github.io/python_concurrent_lock.html/</id>
    <published>2019-12-29T14:12:04.000Z</published>
    <updated>2020-01-01T07:48:01.220Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>背景</strong>: 项目中有个需求，在某一个api请求的处理逻辑中，将收到的数据信息写入文件，每次写入一条。在并发情况下存在文件读写覆盖问题，因此需要对写操作进行互斥。</p></blockquote><a id="more"></a><h2 id="1-问题复现"><a href="#1-问题复现" class="headerlink" title="1.问题复现"></a>1.问题复现</h2><h3 id="1-1-复现工具："><a href="#1-1-复现工具：" class="headerlink" title="1.1 复现工具："></a>1.1 复现工具：</h3><ul><li>apache jmeter（推荐）</li><li>postman runer<h3 id="1-2-复现方法"><a href="#1-2-复现方法" class="headerlink" title="1.2 复现方法"></a>1.2 复现方法</h3></li><li>同一时间段发送100次请求<ul><li>例如：10秒中之内发送100次请求</li></ul></li><li>瞬时发送100次请求<ul><li>例如：无延迟发送100次请求<br>请求处理完成，统计文件中的数据条数</li></ul></li></ul><h3 id="1-3-复现结果"><a href="#1-3-复现结果" class="headerlink" title="1.3 复现结果"></a>1.3 复现结果</h3><p>为方便统计，简单用一个python脚本做为统计：</p><h4 id="1-3-1-统计脚本"><a href="#1-3-1-统计脚本" class="headerlink" title="1.3.1 统计脚本"></a>1.3.1 统计脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding:utf-8 -*-</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'example_file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        items = f.readlines()</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">"数据条数:&#123;num&#125;"</span>.format(num=len(items)))</span><br></pre></td></tr></table></figure><h4 id="1-3-2-结果"><a href="#1-3-2-结果" class="headerlink" title="1.3.2 结果"></a>1.3.2 结果</h4><p>conslusion：数据条数均小于100</p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><p>在并发情况下，文件是作为一种竞争资源进行访问，因此对文件的写操作需要放在临界区，进入临界区的线程才有资格对文件进行实际的写操作。提供互斥访问文件方式，提供临界区的方式在众多变成语言中都提供了锁的方式，下面看看python中有哪些具体的实现方式能够满足需求。</p><h3 id="2-1-threading-lock"><a href="#2-1-threading-lock" class="headerlink" title="2.1 threading.lock"></a>2.1 threading.lock</h3><h4 id="2-1-1-原理"><a href="#2-1-1-原理" class="headerlink" title="2.1.1 原理"></a>2.1.1 原理</h4><p>python提供的线程间同步机制，在访问临界区资源的过程中，通过加锁的方式实现互斥访问，没有获取锁的线程将被阻塞，直至当前获取锁的线程完成机器信息写入、释放锁。</p><h4 id="2-1-2-实现方式"><a href="#2-1-2-实现方式" class="headerlink" title="2.1.2 实现方式"></a>2.1.2 实现方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">mutex = threading.Lock()</span><br><span class="line">file_path = <span class="string">"example_file"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, request)</span>:</span> <span class="comment"># 请求处理方法</span></span><br><span class="line">    body = json.loeads(request.body)</span><br><span class="line">    register_item(body)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_item</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> mutex:</span><br><span class="line">        <span class="keyword">with</span> open(file_path, <span class="string">'a'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(json.dumps(item))</span><br><span class="line">            f.write(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><h4 id="2-1-3-缺陷"><a href="#2-1-3-缺陷" class="headerlink" title="2.1.3 缺陷"></a>2.1.3 缺陷</h4><p>在单纯的多线程情况下，这种互斥加锁的访问方式能够解决同步的问题，缺点这种互斥是阻塞的，并发请求过大的情况下，会造成过多的线程处于阻塞状态，系统的多线程模型可能会出现意想不到的错误提示。<br></p><p>此外，项目的运行方式并不是简单的多线程，而是多进程+多线程模式，threading.Locak()只能在一个进程孵化的子线程之间实现资源的互斥访问，但是对不同进程之间并不能够做约束，所以无法满足项目实际需求。</p><h3 id="2-2-fcntl-flock"><a href="#2-2-fcntl-flock" class="headerlink" title="2.2 fcntl.flock"></a>2.2 fcntl.flock</h3><h4 id="2-2-1-原理"><a href="#2-2-1-原理" class="headerlink" title="2.2.1 原理"></a>2.2.1 原理</h4><p>当涉及到多个进程向同一个文件write(或者read)的情况，如果几个进程同时都对这个文件进行写操作，那么文件的内容就会变得非常混乱，这个时候文件锁就派上用场了，python中的文件锁，可以保证同时只有一个进程写文件，目前使用的是fcntl这个库，它实际上为 Unix上的ioctl，flock和fcntl 函数提供了一个接口。python通过调用fcntl.flock()函数对文件加锁。</p><p>常用锁类型</p><ul><li>LOCK_SH： 表示要创建一个共享锁，在任意时间内，一个文件的共享锁可以被多个进程拥有</li><li>LOCK_EX： 表示创建一个排他锁，在任意时间内，一个文件的排他锁只能被一个进程拥有</li></ul><p>操作注意点</p><ol><li>对于文件的 close() 操作会使文件锁失效；</li><li>同理，进程结束后文件锁失效；</li><li>flock() 的 LOCK_EX是“劝告锁”，系统内核不会强制检查锁的状态，需要在代码中进行文件操作的地方显式检查才能生效。（一个进程中使用了acquire显示检查，另一个进程没有进行flock检查，可以直接读写文件）</li></ol><h4 id="2-2-2-实现方式"><a href="#2-2-2-实现方式" class="headerlink" title="2.2.2 实现方式"></a>2.2.2 实现方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fcntl</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">"example_file"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        body = json.loads(request.body)</span><br><span class="line">        register_item(body)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_item</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(file_path, <span class="string">'a'</span>) <span class="keyword">as</span> f: <span class="comment"># 文件关闭，锁也自动释放</span></span><br><span class="line">        fcntl.flock(f.fileno(), fcntl.LOCK_EX)  <span class="comment"># fileno 获取的是打开文件的文件描述符</span></span><br><span class="line">        f.write(json.dumps(item))</span><br><span class="line">        f.write(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><h2 id="3-结论"><a href="#3-结论" class="headerlink" title="3. 结论"></a>3. 结论</h2><p>并发情况下对文件的读写操作，需要结合项目实际的需求，多线程和多进程的运行方式入手，划出临界区，选择合适的并发控制方案。此外，可以了解jmeter 工具做个并发测试，能够更深入理解其中的过程，包括处理的时间，线程池的工作方式。<br>TODO ：</p><ul><li>GIL 了解</li><li>multiprocessing 了解</li><li>对比Java中的加锁方式</li><li>对比python中的线程池和Java中的线程池</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;: 项目中有个需求，在某一个api请求的处理逻辑中，将收到的数据信息写入文件，每次写入一条。在并发情况下存在文件读写覆盖问题，因此需要对写操作进行互斥。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="python多线程" scheme="https://dpcfury.github.io/tags/python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
