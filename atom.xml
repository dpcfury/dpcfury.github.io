<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DPC&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/bfa2adcbfd5883f9905426b1399816ee</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dpcfury.github.io/"/>
  <updated>2020-03-31T15:49:31.466Z</updated>
  <id>https://dpcfury.github.io/</id>
  
  <author>
    <name>杜鹏程</name>
    <email>dpcspark@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序</title>
    <link href="https://dpcfury.github.io/sorting.html/"/>
    <id>https://dpcfury.github.io/sorting.html/</id>
    <published>2020-03-31T14:11:02.000Z</published>
    <updated>2020-03-31T15:49:31.466Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>十大排序算法可以说是每个程序员都必须得掌握的了，为了方便个人复习和总结，把它整理成一篇独立文章，每种算法会有简单的算法思想描述，为了方便大家理解，从网上搜集了动图演示。</p></blockquote><a id="more"></a><ul><li>选择排序</li><li>插入排序</li><li>冒泡排序</li><li>非优化版本</li><li>优化版本</li><li>希尔排序</li><li>归并排序</li><li>递归式归并排序</li><li>非递归式归并排序</li><li>快速排序</li><li>堆排序</li><li>基数排序</li><li>非优化版本</li><li>优化版本</li><li>桶排序</li><li>基数排序</li></ul><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>过程简单描述：</strong> 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为选择排序。</p><p><img src="https://pic1.zhimg.com/v2-f20b8898585b3ca03843d93ce2c35a68_b.gif" alt="选择排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[min]) min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[min];</span><br><span class="line">            nums[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="https://zhuanlan.zhihu.com/p/57088609" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57088609</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;十大排序算法可以说是每个程序员都必须得掌握的了，为了方便个人复习和总结，把它整理成一篇独立文章，每种算法会有简单的算法思想描述，为了方便大家理解，从网上搜集了动图演示。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="sorting" scheme="https://dpcfury.github.io/tags/sorting/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1218] Longest Arithmetic Subsequence of Given Difference</title>
    <link href="https://dpcfury.github.io/longest-arithmetic-subsequence-of-given-difference.html/"/>
    <id>https://dpcfury.github.io/longest-arithmetic-subsequence-of-given-difference.html/</id>
    <published>2020-03-30T15:14:37.000Z</published>
    <updated>2020-03-30T15:20:26.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/" target="_blank" rel="noopener">Leetcode 1218. Longest Arithmetic Subsequence of Given Difference</a><br>题目阅读下来，看到子序列这种问题，立马就会想到动态规划，首先会去想如何缩小问题的规模。从这个差来看，对于每一个遍历的数n而言，如果能知道以 n-difference结尾的子序列长度，就能计算以n为结尾的子序列长度，由于差值不是坐标，可以用HashMap存储dp的中间值。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">       map.put(arr[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (map.containsKey(arr[i] - difference)) &#123;</span><br><span class="line">               map.put(arr[i], map.get(arr[i] - difference) + <span class="number">1</span>);</span><br><span class="line">               max = Math.max(map.get(arr[i]), max);</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               map.put(arr[i], <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1218. Longest Arithmetic Subsequence of Given Difference&lt;/a&gt;&lt;br&gt;题目阅读下来，看到子序列这种问题，立马就会想到动态规划，首先会去想如何缩小问题的规模。从这个差来看，对于每一个遍历的数n而言，如果能知道以 n-difference结尾的子序列长度，就能计算以n为结尾的子序列长度，由于差值不是坐标，可以用HashMap存储dp的中间值。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>力扣中国[62] Joseph Circle Problem</title>
    <link href="https://dpcfury.github.io/joseph-circle-problem.html/"/>
    <id>https://dpcfury.github.io/joseph-circle-problem.html/</id>
    <published>2020-03-30T13:46:19.000Z</published>
    <updated>2020-03-30T14:00:09.357Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指offer Joseph Problem</a><br>题目不用多介绍，经典的约瑟夫环问题，求解的过程主要包含两种。一种是直观的构造循环链表，通过多次多次遍历，求的最终结果，时间复杂度为O(mn),另一种就是通过数学分析，找出递归的规律，然后使用递归或者动归求解。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>令f(n-1,m) 为n-1个人，报数m，最终留下的胜者坐标，那么f(n,m)的的胜者同样是f(n-1,m)胜者，但是其下坐标遍了，那么上一轮中胜者的坐标对应应该是(f(n-1,m)+m) % n</p><p>即关系式为：f(n,m) = (f(n-1,m)+m) % n</p><p>针对0和1个数的情况，胜者坐标都为0<br>因此解法可写为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp = (dp + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>对于这个推到技巧，在知乎看到这么一个总结，感觉比较实用</p></blockquote><p>递归问题分3步走：<br>1、递归收敛：由于m是不变的，所以只能通过n将规模不断缩小<br>2、找出口：当递归收敛到最小单位时，能得到一个出口。即当n=1时，胜者的位置为0<br>3、找规律：分析已知条件，与我们需要结果的关联。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指offer Joseph Problem&lt;/a&gt;&lt;br&gt;题目不用多介绍，经典的约瑟夫环问题，求解的过程主要包含两种。一种是直观的构造循环链表，通过多次多次遍历，求的最终结果，时间复杂度为O(mn),另一种就是通过数学分析，找出递归的规律，然后使用递归或者动归求解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="Math" scheme="https://dpcfury.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1162] As Far from Land as Possible</title>
    <link href="https://dpcfury.github.io/leetcode-as-far-from-land-as-possible.html/"/>
    <id>https://dpcfury.github.io/leetcode-as-far-from-land-as-possible.html/</id>
    <published>2020-03-29T13:44:36.000Z</published>
    <updated>2020-03-29T13:49:56.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">Leetcode 1162. As Far from Land as Possible</a><br>题目的意思需要多读几次，最终的目的就是求离陆地最远的海洋距离。这类题目可以属于一道简单的bfs题目。leetcode中海洋陆地问题的题目很多，大多都是bfs或是dfs题目。这里再简单啰嗦一下bfs的思路。首先我们选取一些特征一致的点作为起始目标，然后从这些目标开始向四周扩散一步，四周的点只要在数组边界之内并且其特征与初始特征不一致，我们就将其变为与起始点同一特征（染色）。同时将这些新染色的点作为起始再向四周扩散一步，执行相同操作，直到全部同化完成。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>先找出所有陆地的坐标，作为bfs的起始条件。</li><li>通过所有的陆地坐标向外bfs。直到找到最后一块海洋为止。这期间所用到的步数即是答案，也即从某个初始点扩散到这块海洋，所需要的最长距离。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">int</span> dist;</span><br><span class="line"></span><br><span class="line">        Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dist) &#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.dist = dist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length;</span><br><span class="line">        <span class="keyword">int</span> maxDistance = -<span class="number">1</span>;</span><br><span class="line">        Queue&lt;Point&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Point(i, j, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有陆地或者全是陆地，直接返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (queue.size() == <span class="number">0</span> || queue.size() == n * n) <span class="keyword">return</span> maxDistance;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Point p = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (p.x &lt; <span class="number">0</span> || p.x &gt; grid.length - <span class="number">1</span> || p.y &lt; <span class="number">0</span> || p.y &gt; grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[p.x][p.y]) &#123;</span><br><span class="line">                visited[p.x][p.y] = <span class="keyword">true</span>;</span><br><span class="line">                maxDistance = Math.max(maxDistance, p.dist);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                    <span class="keyword">int</span> curX = p.x + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> curY = p.y + dir[<span class="number">1</span>];</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Point(curX, curY, p.dist+ <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDistance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/as-far-from-land-as-possible/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1162. As Far from Land as Possible&lt;/a&gt;&lt;br&gt;题目的意思需要多读几次，最终的目的就是求离陆地最远的海洋距离。这类题目可以属于一道简单的bfs题目。leetcode中海洋陆地问题的题目很多，大多都是bfs或是dfs题目。这里再简单啰嗦一下bfs的思路。首先我们选取一些特征一致的点作为起始目标，然后从这些目标开始向四周扩散一步，四周的点只要在数组边界之内并且其特征与初始特征不一致，我们就将其变为与起始点同一特征（染色）。同时将这些新染色的点作为起始再向四周扩散一步，执行相同操作，直到全部同化完成。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="BFS" scheme="https://dpcfury.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[423] Reconstruct Original Digits from English</title>
    <link href="https://dpcfury.github.io/reconstruct-original-digits-from-english.html/"/>
    <id>https://dpcfury.github.io/reconstruct-original-digits-from-english.html/</id>
    <published>2020-03-29T05:49:52.000Z</published>
    <updated>2020-03-29T06:08:49.856Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/reconstruct-original-digits-from-english/" target="_blank" rel="noopener">423. Reconstruct Original Digits from English</a><br>题目的意思第一遍读，以为是和编解码同类型的题目，想用回溯去尝试，后来发现给定的一个条件是input长度小于5000，那就说明可能存在重复的数字，回溯走不通。再看看discuss，发现这题主要是在找规律，即分析每个数字英文所包含的字母和其对应关系，再从input中判断特征字母的出现次数，计算每个数字的出现次数。</p></blockquote><a id="more"></a><p>如果我们用numbers数组存储出现的数字个数，其中下标表示着对应0-9的数字，那么我们会有下面这个结果：</p><table><thead><tr><th>数字</th><th>数字的个数</th></tr></thead><tbody><tr><td>0</td><td>numbers[0] = ‘z’的个数</td></tr><tr><td>2</td><td>numbers[2] = ‘w’的个数</td></tr><tr><td>4</td><td>numbers[4] = ‘u’的个数</td></tr><tr><td>6</td><td>numbers[6] = ‘x’的个数</td></tr><tr><td>8</td><td>numbers[8] = ‘g’的个数</td></tr></tbody></table><p>而其他的数字个数，比如5的个数，因为‘f’的数目由four和five的数目组成，而我们已知four的数目为numbers[4]，所以numbers[5] = ‘f’的个数-number[4]。其他的数字同样处理。<br>最后得到了下面的映射关系：</p><table><thead><tr><th>数字</th><th>数字的个数</th></tr></thead><tbody><tr><td>5</td><td>numbers[5] = ‘f’的个数 - numbers[4]</td></tr><tr><td>3</td><td>numbers[3] = ‘h’的个数 - numbers[8]</td></tr><tr><td>7</td><td>numbers[7] = ‘s’的个数 - numbers[6]</td></tr><tr><td>1</td><td>numbers[1] = ‘o’的个数 - numbers[0] - numbers[2] - numbers[4]</td></tr><tr><td>9</td><td>numbers[9] = ‘i’的个数 - numbers[5] - numbers[6] - numbers[8]</td></tr></tbody></table><p>于是乎，代码写成下面这种格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">originalDigits</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            count.put(c, count.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[<span class="number">8</span>] = count.getOrDefault(<span class="string">'g'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">6</span>] = count.getOrDefault(<span class="string">'x'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">4</span>] = count.getOrDefault(<span class="string">'u'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">2</span>] = count.getOrDefault(<span class="string">'w'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">0</span>] = count.getOrDefault(<span class="string">'z'</span>, <span class="number">0</span>);</span><br><span class="line">        nums[<span class="number">5</span>] = count.getOrDefault(<span class="string">'f'</span>, <span class="number">0</span>) - nums[<span class="number">4</span>];</span><br><span class="line">        nums[<span class="number">3</span>] = count.getOrDefault(<span class="string">'h'</span>, <span class="number">0</span>) - nums[<span class="number">8</span>];</span><br><span class="line">        nums[<span class="number">7</span>] = count.getOrDefault(<span class="string">'s'</span>, <span class="number">0</span>) - nums[<span class="number">6</span>];</span><br><span class="line">        nums[<span class="number">1</span>] = count.getOrDefault(<span class="string">'o'</span>, <span class="number">0</span>) - nums[<span class="number">0</span>] - nums[<span class="number">2</span>] - nums[<span class="number">4</span>];</span><br><span class="line">        nums[<span class="number">9</span>] = count.getOrDefault(<span class="string">'i'</span>, <span class="number">0</span>) - nums[<span class="number">5</span>] - nums[<span class="number">6</span>] - nums[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                str.append((<span class="keyword">char</span>) (<span class="string">'0'</span> + i));</span><br><span class="line">                nums[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>看到discuss中有给出的拓扑排序解法，但是这题给人的感觉更倾向于找规律，因此不再讨论另外的解法。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reconstruct-original-digits-from-english/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;423. Reconstruct Original Digits from English&lt;/a&gt;&lt;br&gt;题目的意思第一遍读，以为是和编解码同类型的题目，想用回溯去尝试，后来发现给定的一个条件是input长度小于5000，那就说明可能存在重复的数字，回溯走不通。再看看discuss，发现这题主要是在找规律，即分析每个数字英文所包含的字母和其对应关系，再从input中判断特征字母的出现次数，计算每个数字的出现次数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[820] Short Encoding of Words</title>
    <link href="https://dpcfury.github.io/leetcode-short-encoding-of-words.html/"/>
    <id>https://dpcfury.github.io/leetcode-short-encoding-of-words.html/</id>
    <published>2020-03-28T12:44:24.000Z</published>
    <updated>2020-03-28T13:03:46.304Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">Leetcode 820. Short Encoding of Words</a><br>题目给出一组字符串数组，计算最短的编码字符串长度。编码的方式就是通过‘#‘号分割，再加一个索引，能够从编码字符串中解码初原始字符串。读一下题目，大致可以知道这题的意思是和后缀有关，因为如果一个单词是其他单词的后缀，它的长度肯定不会被计算入加密字符串。因此，先给字符串数组排个序，让长的字符串在前，短的在后，通过每次比较当前字符串和已构造的加密字符对比，含是否是已有字符串的后缀。</p></blockquote><a id="more"></a><h4 id="approach-1"><a href="#approach-1" class="headerlink" title="approach 1"></a>approach 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="keyword">null</span> | words.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[words.length];</span><br><span class="line">        Arrays.sort(words, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.length() - o1.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) strs[i] = words[i] + <span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = strs[i - <span class="number">1</span>].indexOf(words[i]);</span><br><span class="line">                <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123; <span class="comment">// 看能否匹配到#</span></span><br><span class="line">                    <span class="keyword">if</span> (strs[i - <span class="number">1</span>].charAt(index + words[i].length()) == <span class="string">'#'</span>) &#123;</span><br><span class="line">                        strs[i] = strs[i - <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                strs[i] = strs[i - <span class="number">1</span>] + words[i] + <span class="string">'#'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[words.length - <span class="number">1</span>].length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="approach-2"><a href="#approach-2" class="headerlink" title="approach 2"></a>approach 2</h4><blockquote><p>从leetcode 官网给的solution也可以看出来，既然本质是剔除那些本身是其他单词后缀的单词。提到后缀，其实变相的就是逆前缀，而提到前缀就会想到Trie字典树，字典树的分支就是26个字母分叉，对于不是其他单词后缀的单词，其对应在字典树中一定能从根遍历到叶子结点。因此遍历字符串数组的过程中，可以去构造逆向的前缀树，然后统计能走到叶子结点的字符串长度和即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        TrieNode trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        Map&lt;TrieNode, Integer&gt; nodes = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; ++i) &#123;</span><br><span class="line">            String word = words[i];</span><br><span class="line">            TrieNode cur = trie;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = word.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                cur = cur.get(word.charAt(j));</span><br><span class="line">            nodes.put(cur, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (TrieNode node: nodes.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.count == <span class="number">0</span>) <span class="comment">// 走到叶子结点</span></span><br><span class="line">                ans += words[nodes.get(node)].length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (children[c-<span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            children[c-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> children[c - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/short-encoding-of-words/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 820. Short Encoding of Words&lt;/a&gt;&lt;br&gt;题目给出一组字符串数组，计算最短的编码字符串长度。编码的方式就是通过‘#‘号分割，再加一个索引，能够从编码字符串中解码初原始字符串。读一下题目，大致可以知道这题的意思是和后缀有关，因为如果一个单词是其他单词的后缀，它的长度肯定不会被计算入加密字符串。因此，先给字符串数组排个序，让长的字符串在前，短的在后，通过每次比较当前字符串和已构造的加密字符对比，含是否是已有字符串的后缀。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="tries" scheme="https://dpcfury.github.io/tags/tries/"/>
    
      <category term="suffix" scheme="https://dpcfury.github.io/tags/suffix/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[914] X of a Kind in a Deck of Cards</title>
    <link href="https://dpcfury.github.io/leetcode-x-of-a-kind-in-a-deck.html/"/>
    <id>https://dpcfury.github.io/leetcode-x-of-a-kind-in-a-deck.html/</id>
    <published>2020-03-27T13:17:06.000Z</published>
    <updated>2020-03-27T13:22:16.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/" target="_blank" rel="noopener">Leetcode 914. X of a Kind in a Deck of Cards</a><br>题目的直白含义就是：给出一堆数组，判断是否有一种划分方式，让每个分组内的元素都相同，每个组的元素个数页相同。暴力的解法比较直观，但是背后的含义其实是：对于每一种的牌的数量Ni，如果能够满足按x进行分组，那么Ni % x ==0,那么对于不同种类的牌而言，是否存在x这种划分，就变成，这组牌的数量的最大公约数是否满足大于等于 2，由此变为如何求一组数的最大公约数。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : deck) count.put(i, count.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> g = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (g == -<span class="number">1</span>) &#123;</span><br><span class="line">               g = entry.getValue();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               g = gcd(g, entry.getValue());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> g &gt;= <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> y;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> gcd(y % x, x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 914. X of a Kind in a Deck of Cards&lt;/a&gt;&lt;br&gt;题目的直白含义就是：给出一堆数组，判断是否有一种划分方式，让每个分组内的元素都相同，每个组的元素个数页相同。暴力的解法比较直观，但是背后的含义其实是：对于每一种的牌的数量Ni，如果能够满足按x进行分组，那么Ni % x ==0,那么对于不同种类的牌而言，是否存在x这种划分，就变成，这组牌的数量的最大公约数是否满足大于等于 2，由此变为如何求一组数的最大公约数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="gcd" scheme="https://dpcfury.github.io/tags/gcd/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[168] Excel Sheet Column Title</title>
    <link href="https://dpcfury.github.io/leetcode-excel-sheet-column-title.html/"/>
    <id>https://dpcfury.github.io/leetcode-excel-sheet-column-title.html/</id>
    <published>2020-03-27T11:38:32.000Z</published>
    <updated>2020-03-28T15:43:15.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">Leetcode 168. Excel Sheet Column Title</a><br>题目求数字到Excel sheet编号的转换，其实本质就是进制的转换，但是需要注意的是，这边的A是代表1，z代表的是26，如果直接取余数，会发现结果查一位，这里有个技巧就是，每次将初数-1操作,可以看成逻辑上将A从0开始算。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">int</span> num = n % <span class="number">26</span>;</span><br><span class="line">            str.append((<span class="keyword">char</span>) (num + <span class="number">65</span>));</span><br><span class="line">            n = n / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/excel-sheet-column-title/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 168. Excel Sheet Column Title&lt;/a&gt;&lt;br&gt;题目求数字到Excel sheet编号的转换，其实本质就是进制的转换，但是需要注意的是，这边的A是代表1，z代表的是26，如果直接取余数，会发现结果查一位，这里有个技巧就是，每次将初数-1操作,可以看成逻辑上将A从0开始算。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[999] Available Captures for Rook</title>
    <link href="https://dpcfury.github.io/available-captures-for-root.html/"/>
    <id>https://dpcfury.github.io/available-captures-for-root.html/</id>
    <published>2020-03-26T14:37:54.000Z</published>
    <updated>2020-03-26T14:41:07.426Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/available-captures-for-rook/" target="_blank" rel="noopener">999. Available Captures for Rook</a> 题目要求8x8的棋局上，Rook上下左右移动可以补货的黑色卒数量，只要遍历上下左右位置即可。实际题目并没有什么含量，奈何把黑色卒缩写理解成‘B’,稍微折腾了一下，并给题目点了个👎。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> canCapture(board, row, col, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">canCapture</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> up = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (up &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[up][j];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                up--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; col) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[i][right];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[i][left];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> down = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (down &lt; row) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[down][j];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                down++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/available-captures-for-rook/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;999. Available Captures for Rook&lt;/a&gt; 题目要求8x8的棋局上，Rook上下左右移动可以补货的黑色卒数量，只要遍历上下左右位置即可。实际题目并没有什么含量，奈何把黑色卒缩写理解成‘B’,稍微折腾了一下，并给题目点了个👎。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[92] Reverse Linked List II</title>
    <link href="https://dpcfury.github.io/leetcode-reverse-linked-list-II.html/"/>
    <id>https://dpcfury.github.io/leetcode-reverse-linked-list-II.html/</id>
    <published>2020-03-25T13:35:07.000Z</published>
    <updated>2020-03-25T13:41:06.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">Leetcode 92. Reverse Linked List II</a><br>题目要求在一次遍历完成对链表中m-n的元素进行反转，由于是单链表，涉及到这种顺序的饭庄，首先会想到栈，将m-n的元素放入栈中，再记录m-1个元素的位置，通过出栈再重新链接，即可得到反转后的链表。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        ListNode before = newHead;</span><br><span class="line">        ListNode p = newHead;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            before = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count == m) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt;= n &amp;&amp; p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.add(p);</span><br><span class="line">            p = p.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            ListNode node = stack.pop();</span><br><span class="line">            before.next = node;</span><br><span class="line">            before = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        before.next = p;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 92. Reverse Linked List II&lt;/a&gt;&lt;br&gt;题目要求在一次遍历完成对链表中m-n的元素进行反转，由于是单链表，涉及到这种顺序的饭庄，首先会想到栈，将m-n的元素放入栈中，再记录m-1个元素的位置，通过出栈再重新链接，即可得到反转后的链表。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="linkedlist" scheme="https://dpcfury.github.io/tags/linkedlist/"/>
    
      <category term="stack" scheme="https://dpcfury.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[543] Diameter of Binary Tree</title>
    <link href="https://dpcfury.github.io/leetcode-diameter-of-binary-tree.html/"/>
    <id>https://dpcfury.github.io/leetcode-diameter-of-binary-tree.html/</id>
    <published>2020-03-25T11:55:19.000Z</published>
    <updated>2020-03-25T13:49:13.835Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. Diameter of Binary Tree</a><br>题目要求二叉树的最大直径，所谓直径就是这颗树的任意两个叶子结点连接，所能经过的最多节点数。分析这个路径的可能构成情况，可能是存在于左子树、右子树，或者存在于左右子树+根节点。所以对于当前任意节点，这颗树的最大直径，可以分为包含这个节点的路径情况：即左右子树高度+1，不包含的情况，即左子树的最大直径、或右子树的最大直径。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = getDepth(root.left) + getDepth(root.right);</span><br><span class="line">        <span class="keyword">int</span> leftMax = diameterOfBinaryTree(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightMax = diameterOfBinaryTree(root.right);</span><br><span class="line">        <span class="keyword">if</span> (leftMax &gt; max)</span><br><span class="line">            max = leftMax;</span><br><span class="line">        <span class="keyword">if</span> (rightMax &gt; max)</span><br><span class="line">            max = rightMax;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(getDepth(node.left), getDepth(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/diameter-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;543. Diameter of Binary Tree&lt;/a&gt;&lt;br&gt;题目要求二叉树的最大直径，所谓直径就是这颗树的任意两个叶子结点连接，所能经过的最多节点数。分析这个路径的可能构成情况，可能是存在于左子树、右子树，或者存在于左右子树+根节点。所以对于当前任意节点，这颗树的最大直径，可以分为包含这个节点的路径情况：即左右子树高度+1，不包含的情况，即左子树的最大直径、或右子树的最大直径。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[198] House Robber</title>
    <link href="https://dpcfury.github.io/leetcode-house-robber.html/"/>
    <id>https://dpcfury.github.io/leetcode-house-robber.html/</id>
    <published>2020-03-24T14:10:43.000Z</published>
    <updated>2020-03-24T14:16:47.064Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">198. House Robber</a><br>题目描述，给定一组序列，对其中的每一个元素，可以选择拿或者不拿，但是拿了之后，后相邻的下一个元素就不能拿，求能够拿的最大数量。属于特别典型的dp问题，推到出递归式即可。这题在国内还换了种说法，变成了<a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">按摩师</a>，内容完全一样。</p></blockquote><a id="more"></a><h4 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                max[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                max[i] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                max[i] = Math.max(max[i - <span class="number">1</span>], max[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;198. House Robber&lt;/a&gt;&lt;br&gt;题目描述，给定一组序列，对其中的每一个元素，可以选择拿或者不拿，但是拿了之后，后相邻的下一个元素就不能拿，求能够拿的最大数量。属于特别典型的dp问题，推到出递归式即可。这题在国内还换了种说法，变成了&lt;a href=&quot;https://leetcode-cn.com/problems/the-masseuse-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;按摩师&lt;/a&gt;，内容完全一样。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[876] Middle of the Linked List</title>
    <link href="https://dpcfury.github.io/leetcode-middle-of-the-linked-list.html/"/>
    <id>https://dpcfury.github.io/leetcode-middle-of-the-linked-list.html/</id>
    <published>2020-03-23T14:35:01.000Z</published>
    <updated>2020-03-23T14:45:15.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">Leetcode 876. Middle of the Linked List</a><br>题目目的是求一个非空链表中，从中间元素开始往后的截取一半列表。比较直观的就是设立两个元素以相差一倍的速度进行遍历，当跑的快的达到null，或者即将为null，再返回慢的元素或慢元素的下一个位置。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode q = head.next;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q == <span class="keyword">null</span> || q.next == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q == <span class="keyword">null</span> ? p : p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/middle-of-the-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 876. Middle of the Linked List&lt;/a&gt;&lt;br&gt;题目目的是求一个非空链表中，从中间元素开始往后的截取一半列表。比较直观的就是设立两个元素以相差一倍的速度进行遍历，当跑的快的达到null，或者即将为null，再返回慢的元素或慢元素的下一个位置。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="linked list" scheme="https://dpcfury.github.io/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[111] Minimum Depth of Binary Tree</title>
    <link href="https://dpcfury.github.io/leetcode-minimum-depth-of-binary-tree.html/"/>
    <id>https://dpcfury.github.io/leetcode-minimum-depth-of-binary-tree.html/</id>
    <published>2020-03-22T13:46:45.000Z</published>
    <updated>2020-03-22T13:50:32.830Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">Leetcode 111. Minimum Depth of Binary Tree</a><br>题目要求计算二叉树从根节点开始，到叶子阶段的最短距离。解法同样是左右子树递归进行计算，但是要注意为空情况下，子树的最小深度应该设置为无穷大，而不是0。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> minLeft = root.left != <span class="keyword">null</span> ? minDepth(root.left) : Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minRight = root.right != <span class="keyword">null</span> ? minDepth(root.right) : Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> Math.min(minLeft, minRight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 111. Minimum Depth of Binary Tree&lt;/a&gt;&lt;br&gt;题目要求计算二叉树从根节点开始，到叶子阶段的最短距离。解法同样是左右子树递归进行计算，但是要注意为空情况下，子树的最小深度应该设置为无穷大，而不是0。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[110] Balanced Binary Tree</title>
    <link href="https://dpcfury.github.io/leetcode-balanced-binary-tree.html/"/>
    <id>https://dpcfury.github.io/leetcode-balanced-binary-tree.html/</id>
    <published>2020-03-22T13:24:11.000Z</published>
    <updated>2020-03-22T13:27:52.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">Leetcode 110. Balanced Binary Tree</a><br>题目给出一个二叉树，需要判断这颗树是不是平衡二叉树，即对树的每个节点而言，其左右子树高度差不能超过1。第一感觉就是使用递归，从当前节点判断，除了要左右两颗子树都是平衡二叉树之外，还需要一个条件，即左右子树的高度不能像差超过1，因此需要计算树的高度。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isBalanced(root.left) &amp;&amp; isBalanced(root.right))</span><br><span class="line">            <span class="keyword">return</span> Math.abs(heightOfTree(root.left) - heightOfTree(root.right)) &lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">heightOfTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ldep = heightOfTree(root.left);</span><br><span class="line">        <span class="keyword">int</span> rdep = heightOfTree(root.right);</span><br><span class="line">        <span class="keyword">if</span> (ldep &gt; rdep) &#123;</span><br><span class="line">            <span class="keyword">return</span> ldep + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rdep + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/balanced-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 110. Balanced Binary Tree&lt;/a&gt;&lt;br&gt;题目给出一个二叉树，需要判断这颗树是不是平衡二叉树，即对树的每个节点而言，其左右子树高度差不能超过1。第一感觉就是使用递归，从当前节点判断，除了要左右两颗子树都是平衡二叉树之外，还需要一个条件，即左右子树的高度不能像差超过1，因此需要计算树的高度。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[200] Number of Islands</title>
    <link href="https://dpcfury.github.io/leetcode-number-of-islands.html/"/>
    <id>https://dpcfury.github.io/leetcode-number-of-islands.html/</id>
    <published>2020-03-22T12:39:04.000Z</published>
    <updated>2020-03-23T14:44:54.002Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">Leetcode 200. Number of Islands</a><br>题目意思：一个二维字符数组，其中‘1’代表的是陆地，上下左右相邻的陆地构成一个岛，求解这幅地图中的独立小岛个数。这题和回溯的相似度很高，但是比回溯要更为简单，直观的解法就是，找到小岛的一块陆地，从上下左右分别去拓展这个小岛，通过一个标记二维数组标记当前的拓展情况，如果已经拓展则进行忽略，当二维字符数组的每个元素都遍历完成，求得小岛数就是最终的答案。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length==<span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    traversal(grid, row, col, i, j, visited);</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col || grid[i][j] != <span class="string">'1'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i][j]) &#123;</span><br><span class="line">                visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                traversal(grid, row, col, i - <span class="number">1</span>, j, visited);</span><br><span class="line">                traversal(grid, row, col, i + <span class="number">1</span>, j, visited);</span><br><span class="line">                traversal(grid, row, col, i, j - <span class="number">1</span>, visited);</span><br><span class="line">                traversal(grid, row, col, i, j + <span class="number">1</span>, visited);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-islands/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 200. Number of Islands&lt;/a&gt;&lt;br&gt;题目意思：一个二维字符数组，其中‘1’代表的是陆地，上下左右相邻的陆地构成一个岛，求解这幅地图中的独立小岛个数。这题和回溯的相似度很高，但是比回溯要更为简单，直观的解法就是，找到小岛的一块陆地，从上下左右分别去拓展这个小岛，通过一个标记二维数组标记当前的拓展情况，如果已经拓展则进行忽略，当二维字符数组的每个元素都遍历完成，求得小岛数就是最终的答案。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[108] Convert Sorted Array to Binary Search Tree</title>
    <link href="https://dpcfury.github.io/convert-sorted-array-to-binary-search-tree.html/"/>
    <id>https://dpcfury.github.io/convert-sorted-array-to-binary-search-tree.html/</id>
    <published>2020-03-22T05:36:55.000Z</published>
    <updated>2020-03-22T07:34:25.558Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">Leetcode 108. Convert Sorted Array to Binary Search Tree</a><br>题目意思：通过一个有序的数组，构建一个高度平衡的二叉搜索树。具体解法比较直观的就是，通过二分法，将数组从中间一份为二，前半部分为左子树，右半部分为右子树，中间元素为树的根，这样递归去构建左右子树技能得到最终的解。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; i) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[m]);</span><br><span class="line">        root.left = sortedArrayToBST(nums, i, m - <span class="number">1</span>);</span><br><span class="line">        root.right = sortedArrayToBST(nums, m + <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 108. Convert Sorted Array to Binary Search Tree&lt;/a&gt;&lt;br&gt;题目意思：通过一个有序的数组，构建一个高度平衡的二叉搜索树。具体解法比较直观的就是，通过二分法，将数组从中间一份为二，前半部分为左子树，右半部分为右子树，中间元素为树的根，这样递归去构建左右子树技能得到最终的解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="BST" scheme="https://dpcfury.github.io/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>letcode[365]Water and Jug Problem</title>
    <link href="https://dpcfury.github.io/leetcode-water-jug-problem.html/"/>
    <id>https://dpcfury.github.io/leetcode-water-jug-problem.html/</id>
    <published>2020-03-21T07:59:14.000Z</published>
    <updated>2020-03-21T08:13:28.442Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">Leetcode 365. Water and Jug Problem</a><br> 题目直面意思，通过两个容器，是否可以计算出指定体积的水，一开始以为什么规律题，折腾了半天，后面看解题思路。这类题目其实属于数学题，即通过机选x,y的最大公约数，并看Z是否能整出这个最大公约数进行判断。</p></blockquote><a id="more"></a><h4 id="参考思路："><a href="#参考思路：" class="headerlink" title="参考思路："></a>参考思路：</h4><p> <a href="https://zhuanlan.zhihu.com/p/68987055" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68987055</a></p><h4 id="问题转换为gcd"><a href="#问题转换为gcd" class="headerlink" title="问题转换为gcd"></a>问题转换为gcd</h4><p> 即如何求两个正整数的最大公约数，思路如下：<a href="https://blog.csdn.net/wujingchangye/article/details/88542193" target="_blank" rel="noopener">https://blog.csdn.net/wujingchangye/article/details/88542193</a></p><blockquote><ol><li>假设有两个数a和b，其中a是不小于b的数，记a被b除的余数为r，则a = b*q + r。</li><li>假设a和b的一个约数为u，那么a和b都能被u整除，则a = su b = tu，s和t都是整数。</li><li>r = a - bq = su - (tu)q = (s - tq)u，所以r也能被u整除</li><li>所以a和b的任一约数同时也是r的约数（每次取余，直到余数为0）。**</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = p % q;</span><br><span class="line">    <span class="keyword">return</span> gcd(q, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目完整解答"><a href="#题目完整解答" class="headerlink" title="题目完整解答"></a>题目完整解答</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x + y &lt; z) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == z || y == z || x + y == z) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> z % gcd(x, y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/water-and-jug-problem/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 365. Water and Jug Problem&lt;/a&gt;&lt;br&gt; 题目直面意思，通过两个容器，是否可以计算出指定体积的水，一开始以为什么规律题，折腾了半天，后面看解题思路。这类题目其实属于数学题，即通过机选x,y的最大公约数，并看Z是否能整出这个最大公约数进行判断。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="math" scheme="https://dpcfury.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode.cn 最小的k个数</title>
    <link href="https://dpcfury.github.io/leetcode-cn-k-smallest-num.html/"/>
    <id>https://dpcfury.github.io/leetcode-cn-k-smallest-num.html/</id>
    <published>2020-03-20T13:50:59.000Z</published>
    <updated>2020-03-20T13:56:25.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/submissions/" target="_blank" rel="noopener">Leetcode中国每日一题</a>取自剑指offer<br>题目意思就是从一个一维数组中，找出k个最小的数，每次看到这个K，最容易想到的就是堆排序，通过构造大顶堆或小顶堆分别来找最小的k个数和最大的k个数。而Java中天生有支持堆排序的数据结构，PriorityQueue，只要指定K容量的堆，通过比较堆顶元素与当前数组遍历元素，如果小于堆顶，则堆顶出列，插入当前遍历元素，遍历完成之后，堆中的K个数即我们要找的最小K个数。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || k &gt; arr.length || k == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() != k) &#123;</span><br><span class="line">                queue.offer(arr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &lt; queue.peek()) &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.offer(arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result[i] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode中国每日一题&lt;/a&gt;取自剑指offer&lt;br&gt;题目意思就是从一个一维数组中，找出k个最小的数，每次看到这个K，最容易想到的就是堆排序，通过构造大顶堆或小顶堆分别来找最小的k个数和最大的k个数。而Java中天生有支持堆排序的数据结构，PriorityQueue，只要指定K容量的堆，通过比较堆顶元素与当前数组遍历元素，如果小于堆顶，则堆顶出列，插入当前遍历元素，遍历完成之后，堆中的K个数即我们要找的最小K个数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="heap sort" scheme="https://dpcfury.github.io/tags/heap-sort/"/>
    
      <category term="priority queye" scheme="https://dpcfury.github.io/tags/priority-queye/"/>
    
  </entry>
  
  <entry>
    <title>leetcode[409]Longest Palindrome</title>
    <link href="https://dpcfury.github.io/leetcode-longest-palindrome.html/"/>
    <id>https://dpcfury.github.io/leetcode-longest-palindrome.html/</id>
    <published>2020-03-19T15:01:25.000Z</published>
    <updated>2020-03-19T15:09:16.367Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/longest-palindrome/" target="_blank" rel="noopener">409. Longrest Palindrome</a><br>给定一个字符串，计算其包含的字符可组成的最长回文字符串，主要是观察下规律，看如何用字符去组织回文字符串，针对单数的字符、双数的字符，应该如何处理。个人给出的代码其实很臃肿，可以优化的地方很多，往上有种bitwise的做法，不是很理解，暂且不放上来。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">int</span> n = count.get(c);</span><br><span class="line">                count.put(c, n + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> once = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : count.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (once) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    once = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> n = entry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) num += n;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (once) &#123;</span><br><span class="line">                        num += (n - <span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        num += n;</span><br><span class="line">                        once=<span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;409. Longrest Palindrome&lt;/a&gt;&lt;br&gt;给定一个字符串，计算其包含的字符可组成的最长回文字符串，主要是观察下规律，看如何用字符去组织回文字符串，针对单数的字符、双数的字符，应该如何处理。个人给出的代码其实很臃肿，可以优化的地方很多，往上有种bitwise的做法，不是很理解，暂且不放上来。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="easy" scheme="https://dpcfury.github.io/tags/easy/"/>
    
      <category term="array" scheme="https://dpcfury.github.io/tags/array/"/>
    
  </entry>
  
</feed>
