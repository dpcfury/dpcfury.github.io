<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DPC&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/bfa2adcbfd5883f9905426b1399816ee</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dpcfury.github.io/"/>
  <updated>2020-04-12T04:13:19.310Z</updated>
  <id>https://dpcfury.github.io/</id>
  
  <author>
    <name>杜鹏程</name>
    <email>dpcspark@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode[] Construct Binary Tree from Inorder and Postorder Traversal</title>
    <link href="https://dpcfury.github.io/construct-binary-tree-from-inorder-and-postorder-traversal.html/"/>
    <id>https://dpcfury.github.io/construct-binary-tree-from-inorder-and-postorder-traversal.html/</id>
    <published>2020-04-12T04:08:34.000Z</published>
    <updated>2020-04-12T04:13:19.310Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">Leetcode 106. Construct Binary Tree from Inorder and Postorder Traversal</a><br>题目要求：根据一棵树的中序遍历与后序遍历构造二叉树。ps：树中没有重复的元素，属于很基本的二叉树问题。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定二叉树的后序遍历数组和中序遍历数组，可以明确指导后序数组的第一个元素，肯定是当前这颗树的根,随后在中序数组中找到这个根元素，将中序数组就可以切分为左子树和右子树，然后递归去求构造左子树和右子树即可。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder == <span class="keyword">null</span> || postorder == <span class="keyword">null</span> || inorder.length == <span class="number">0</span> || postorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> buildTree(</span><br><span class="line">                    inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>,</span><br><span class="line">                    postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start1 &gt; end1) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[end2]);</span><br><span class="line">        <span class="keyword">int</span> index = start1;</span><br><span class="line">        <span class="keyword">while</span> (inorder[index] != postorder[end2]) index++;</span><br><span class="line">        root.left = buildTree(inorder, start1, index - <span class="number">1</span>, postorder, start2, start2 + index - start1 - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(inorder, index + <span class="number">1</span>, end1, postorder, start2 + index - start1, end2 - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 106. Construct Binary Tree from Inorder and Postorder Traversal&lt;/a&gt;&lt;br&gt;题目要求：根据一棵树的中序遍历与后序遍历构造二叉树。ps：树中没有重复的元素，属于很基本的二叉树问题。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>面试题 16.03. 交点</title>
    <link href="https://dpcfury.github.io/cross-point.html/"/>
    <id>https://dpcfury.github.io/cross-point.html/</id>
    <published>2020-04-12T03:04:31.000Z</published>
    <updated>2020-04-12T03:13:10.555Z</updated>
    
    <content type="html"><![CDATA[<p>题目：给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目是一条完完全全全的数学几何题，需要对线段的函数表示方式非常清楚，并能转化条件，将问题变换成较为清晰的数学求解问题。总的来说，两个线段的交点分为两种情况，第一种是不平行的情况，第二种是平行的情况，需要分别进行考虑，这里引用官网给出的算法实现进行改造，个人想这个问题比较艰难，掉脑细胞严重，容易手足无措。</p><blockquote><p>官网实现：<a href="https://leetcode-cn.com/problems/intersection-lcci/solution/jiao-dian-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-lcci/solution/jiao-dian-by-leetcode-solution/</a></p></blockquote><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 (xk, yk) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">    <span class="comment">// 这里的前提是 (xk, yk) 一定在「直线」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">inside</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> xk, <span class="keyword">int</span> yk)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若与 x 轴平行，只需要判断 x 的部分</span></span><br><span class="line">        <span class="comment">// 若与 y 轴平行，只需要判断 y 的部分</span></span><br><span class="line">        <span class="comment">// 若为普通线段，则都要判断</span></span><br><span class="line">        <span class="keyword">return</span> (x1 == x2 || (Math.min(x1, x2) &lt;= xk &amp;&amp; xk &lt;= Math.max(x1, x2)))</span><br><span class="line">                &amp;&amp; (y1 == y2 || (Math.min(y1, y2) &lt;= yk &amp;&amp; yk &lt;= Math.max(y1, y2)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] update(<span class="keyword">double</span>[] ans, <span class="keyword">double</span> xk, <span class="keyword">double</span> yk) &#123;</span><br><span class="line">        <span class="comment">// 将一个交点与当前 ans 中的结果进行比较</span></span><br><span class="line">        <span class="comment">// 若更优则替换</span></span><br><span class="line">        <span class="keyword">if</span> (ans.length == <span class="number">0</span> || xk &lt; ans[<span class="number">0</span>] || (xk == ans[<span class="number">0</span>] &amp;&amp; yk &lt; ans[<span class="number">1</span>])) &#123;</span><br><span class="line">            ans = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;xk, yk&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] intersection(<span class="keyword">int</span>[] start1, <span class="keyword">int</span>[] end1, <span class="keyword">int</span>[] start2, <span class="keyword">int</span>[] end2) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = start1[<span class="number">0</span>], y1 = start1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x2 = end1[<span class="number">0</span>], y2 = end1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x3 = start2[<span class="number">0</span>], y3 = start2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x4 = end2[<span class="number">0</span>], y4 = end2[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] ans = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 判断 (x1, y1)~(x2, y2) 和 (x3, y3)~(x4, y3) 是否平行</span></span><br><span class="line">        <span class="keyword">if</span> ((y4 - y3) * (x2 - x1) == (y2 - y1) * (x4 - x3)) &#123;</span><br><span class="line">            <span class="comment">// 若平行，则判断 (x3, y3) 是否在「直线」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">            <span class="keyword">if</span> ((y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)) &#123;</span><br><span class="line">                <span class="comment">// 判断 (x3, y3) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x1, y1, x2, y2, x3, y3)) &#123;</span><br><span class="line">                    ans = update(ans, x3, y3);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断 (x4, y4) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x1, y1, x2, y2, x4, y4)) &#123;</span><br><span class="line">                    ans = update(ans, x4, y4);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断 (x1, y1) 是否在「线段」(x3, y3)~(x4, y4) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x3, y3, x4, y4, x1, y1)) &#123;</span><br><span class="line">                    ans = update(ans, x1, y1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断 (x2, y2) 是否在「线段」(x3, y3)~(x4, y4) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x3, y3, x4, y4, x2, y2)) &#123;</span><br><span class="line">                    ans = update(ans, x2, y2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在平行时，其余的所有情况都不会有交点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 联立方程得到 t1 和 t2 的值</span></span><br><span class="line">            <span class="keyword">double</span> t1 = (<span class="keyword">double</span>) (x3 * (y4 - y3) + y1 * (x4 - x3) - y3 * (x4 - x3) - x1 * (y4 - y3)) / ((x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1));</span><br><span class="line">            <span class="keyword">double</span> t2 = (<span class="keyword">double</span>) (x1 * (y2 - y1) + y3 * (x2 - x1) - y1 * (x2 - x1) - x3 * (y2 - y1)) / ((x4 - x3) * (y2 - y1) - (x2 - x1) * (y4 - y3));</span><br><span class="line">            <span class="comment">// 判断 t1 和 t2 是否均在 [0, 1] 之间</span></span><br><span class="line">            <span class="keyword">if</span> (t1 &gt;= <span class="number">0.0</span> &amp;&amp; t1 &lt;= <span class="number">1.0</span> &amp;&amp; t2 &gt;= <span class="number">0.0</span> &amp;&amp; t2 &lt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                ans = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;x1 + t1 * (x2 - x1), y1 + t1 * (y2 - y1)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="math" scheme="https://dpcfury.github.io/tags/math/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[105] Construct Binary Tree from Preorder and Inorder Traversal</title>
    <link href="https://dpcfury.github.io/construct-binary-tree-from-preorder-and-inorder-traversal.html/"/>
    <id>https://dpcfury.github.io/construct-binary-tree-from-preorder-and-inorder-traversal.html/</id>
    <published>2020-04-11T12:50:44.000Z</published>
    <updated>2020-04-11T12:58:03.192Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal</a><br>题目要求：根据一棵树的前序遍历与中序遍历构造二叉树。ps：树中没有重复的元素，属于很基本的二叉树问题。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定二叉树的前序遍历数组和中序遍历数组，可以明确指导前序数组的第一个元素，肯定是当前这颗树的根,随后在中序数组中找到这个根元素，将中序数组就可以切分为左子树和右子树，然后递归去求构造左子树和右子树即可。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> buildTree(</span><br><span class="line">                    preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>,</span><br><span class="line">                    inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start1 &gt; end1) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[start1]);</span><br><span class="line">        <span class="keyword">int</span> index = start2;</span><br><span class="line">        <span class="keyword">while</span> (inorder[index] != preorder[start1]) index++;</span><br><span class="line">        root.left = buildTree(preorder, start1 + <span class="number">1</span>, start1 + index - start2, inorder, start2, index - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preorder, start1 + index - start2 + <span class="number">1</span>, end1, inorder, index + <span class="number">1</span>, end2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal&lt;/a&gt;&lt;br&gt;题目要求：根据一棵树的前序遍历与中序遍历构造二叉树。ps：树中没有重复的元素，属于很基本的二叉树问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="binary tree" scheme="https://dpcfury.github.io/tags/binary-tree/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[887] Super Egg Drop</title>
    <link href="https://dpcfury.github.io/super-egg-drop.html/"/>
    <id>https://dpcfury.github.io/super-egg-drop.html/</id>
    <published>2020-04-11T05:28:55.000Z</published>
    <updated>2020-04-11T06:03:48.777Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/super-egg-drop/" target="_blank" rel="noopener">Leetcode 887. Super Egg Drop</a><br>题目：K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。<br>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。<br>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。<br>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。<br>你的目标是确切地知道 F 的值是多少。</p></blockquote><p>求：无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？<br><a id="more"></a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目只要推导推导，很快会发现这题是动态规划的味道，令dp[K][N]为给定K个鸡蛋，测量N层楼需要的最少移动次数，可以推导出表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp(K,N)= V <span class="number">1</span>≤X≤<span class="function">N <span class="title">min</span><span class="params">(max(dp(K−<span class="number">1</span>,X−<span class="number">1</span>)</span>,<span class="title">dp</span><span class="params">(K,N−X)</span>))</span></span><br></pre></td></tr></table></figure></p><p>但是问题是，如果通过一个一个遍历的方式，寻找这个满足最少条件的的X，时间复杂度为O(k<em>N</em>N),提交会TLL</p><p>结合官网给出的数学分析，可以将寻找这个X的过程通过二分实现，进而将时间复杂度降低为O(K∗NlogN).</p><p><img src="https://leetcode.com/problems/super-egg-drop/Figures/891/sketch.png" alt="数学分析"></p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) dp[<span class="number">1</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= K; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">                dp[i][j] = j;</span><br><span class="line">                <span class="keyword">int</span> low = <span class="number">1</span>, high = j;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i - <span class="number">1</span>][mid - <span class="number">1</span>] &lt; dp[i][j - mid]) low = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> high = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], Math.max(dp[i - <span class="number">1</span>][high - <span class="number">1</span>], dp[i][j - high]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[K][N];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>题目其实还有O(KN)的实现方式，这个记个TODO，后续跟进</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/super-egg-drop/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 887. Super Egg Drop&lt;/a&gt;&lt;br&gt;题目：K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。&lt;br&gt;每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。&lt;br&gt;你知道存在楼层 F ，满足 0 &amp;lt;= F &amp;lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。&lt;br&gt;每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &amp;lt;= X &amp;lt;= N）。&lt;br&gt;你的目标是确切地知道 F 的值是多少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;求：无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
      <category term="binary search" scheme="https://dpcfury.github.io/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[79] Word Search</title>
    <link href="https://dpcfury.github.io/word-search.html/"/>
    <id>https://dpcfury.github.io/word-search.html/</id>
    <published>2020-04-10T13:13:12.000Z</published>
    <updated>2020-04-10T13:21:37.855Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">Leetcode 79. Word Search</a><br>给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用回溯的方法，递归进行搜索求解，从一个格子（单个字符已经匹配）出发，查看剩余字符是否在上下左右的搜索路径中能够满足。</p><h4 id="approach1-原始写法"><a href="#approach1-原始写法" class="headerlink" title="approach1 原始写法"></a>approach1 原始写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || word == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (word.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">                    <span class="keyword">if</span> (traversal(board, word, <span class="number">0</span>, i, j, directions, visited)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">traversal</span><span class="params">(<span class="keyword">char</span>[][] board, String word,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] directions, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; word.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[i][j] || board[i][j] != word.charAt(index)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">            <span class="keyword">int</span> curX = i + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> curY = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (traversal(board, word, index + <span class="number">1</span>, curX, curY, directions, visited)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="approach2-优化写法"><a href="#approach2-优化写法" class="headerlink" title="approach2 优化写法"></a>approach2 优化写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] w = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;board.length; y++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;board[y].length; x++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exist(board, y, x, w, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> y, <span class="keyword">int</span> x, <span class="keyword">char</span>[] word, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == word.length) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (y&lt;<span class="number">0</span> || x&lt;<span class="number">0</span> || y == board.length || x == board[y].length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[y][x] != word[i]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        board[y][x] ^= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">boolean</span> exist = exist(board, y, x+<span class="number">1</span>, word, i+<span class="number">1</span>)</span><br><span class="line">                || exist(board, y, x-<span class="number">1</span>, word, i+<span class="number">1</span>)</span><br><span class="line">                || exist(board, y+<span class="number">1</span>, x, word, i+<span class="number">1</span>)</span><br><span class="line">                || exist(board, y-<span class="number">1</span>, x, word, i+<span class="number">1</span>);</span><br><span class="line">        board[y][x] ^= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> exist;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/word-search/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 79. Word Search&lt;/a&gt;&lt;br&gt;给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode [151] Reverse Words in a String</title>
    <link href="https://dpcfury.github.io/reverse-words-in-a-string.html/"/>
    <id>https://dpcfury.github.io/reverse-words-in-a-string.html/</id>
    <published>2020-04-10T13:01:09.000Z</published>
    <updated>2020-04-10T13:05:45.797Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener"> Leetcode 151. Reverse Words in a String</a><br>给定一个字符串，逐个翻转字符串中的每个单词。要求是去除前后的空格，并且单词间间隔一个空格，很常规的字符串题目。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>从字符串的尾部开始便利，遇到空格跳过，遇到非空格，开始遍历合法的单词，并利用substring存入到中间结果集中，最后统一处理拼接字符串，记得去除尾部的空格。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(j) != <span class="string">' '</span>) j--;</span><br><span class="line">            res.add(s.substring(j + <span class="number">1</span>, i + <span class="number">1</span>));</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : res) str.append(word).append(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (str.length() != <span class="number">0</span>) str.deleteCharAt(str.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-words-in-a-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; Leetcode 151. Reverse Words in a String&lt;/a&gt;&lt;br&gt;给定一个字符串，逐个翻转字符串中的每个单词。要求是去除前后的空格，并且单词间间隔一个空格，很常规的字符串题目。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="String" scheme="https://dpcfury.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[22] Generate Parentheses</title>
    <link href="https://dpcfury.github.io/generate-parentheses.html/"/>
    <id>https://dpcfury.github.io/generate-parentheses.html/</id>
    <published>2020-04-09T14:34:06.000Z</published>
    <updated>2020-04-09T14:42:47.265Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">Leetcode 22. Generate Parentheses</a><br>这题要求生成指定对数的括号，通常可以直接对应到回溯来做，只要控制好边界，再引入合法括号的判断，基本记得到最终解，如果时间效率优化的话，可以考虑进行剪枝。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用一个temp（StringBuilder）来存放临时的解，如果temp的长度达到了2 * n 并且是合法的括号，那么就把这个临时解存放到结果集中。回溯完成，删除最后一个字符，进行下一轮搜索。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backtracking(res, n, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;String&gt; res, <span class="keyword">int</span> n, StringBuilder str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length() == n * <span class="number">2</span> &amp;&amp; validParent(str.toString())) &#123;</span><br><span class="line">            res.add(str.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.length() &gt; n * <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">char</span>[] pat = &#123;<span class="string">'('</span>, <span class="string">')'</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : pat) &#123;</span><br><span class="line">            backtracking(res, n, str.append(c));</span><br><span class="line">            str.deleteCharAt(str.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validParent</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">'('</span>) stack.add(<span class="string">'C'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) stack.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/generate-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 22. Generate Parentheses&lt;/a&gt;&lt;br&gt;这题要求生成指定对数的括号，通常可以直接对应到回溯来做，只要控制好边界，再引入合法括号的判断，基本记得到最终解，如果时间效率优化的话，可以考虑进行剪枝。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="backtracking" scheme="https://dpcfury.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[730] Count Different Palindromic Subsequences</title>
    <link href="https://dpcfury.github.io/count-different-palindromic-subsequences.html/"/>
    <id>https://dpcfury.github.io/count-different-palindromic-subsequences.html/</id>
    <published>2020-04-08T15:11:29.000Z</published>
    <updated>2020-04-08T15:15:18.138Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/count-different-palindromic-subsequences/" target="_blank" rel="noopener">Leetcode 730. Count Different Palindromic Subsequences</a><br>这题是从Longest Palinromic Subsequence延伸而来，同样属于动态规划问题，但是不同的是在递归式的推导上，由于子问题的回文串数量和前后位置的字符串是有关联的，难点在这个规律的发现。</p></blockquote><a id="more"></a><p>TODO </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/count-different-palindromic-subsequences/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 730. Count Different Palindromic Subsequences&lt;/a&gt;&lt;br&gt;这题是从Longest Palinromic Subsequence延伸而来，同样属于动态规划问题，但是不同的是在递归式的推导上，由于子问题的回文串数量和前后位置的字符串是有关联的，难点在这个规律的发现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
      <category term="palindromic" scheme="https://dpcfury.github.io/tags/palindromic/"/>
    
  </entry>
  
  <entry>
    <title>机器人运动范围</title>
    <link href="https://dpcfury.github.io/robot-move-range.html/"/>
    <id>https://dpcfury.github.io/robot-move-range.html/</id>
    <published>2020-04-08T14:24:39.000Z</published>
    <updated>2020-04-08T15:48:47.782Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">力扣中国 面试题13. 机器人的运动范围</a><br>题目：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。请问该机器人能够到达多少个格子？</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目给出的描述和经常遇到的二维矩阵题非常类似，再加上题目限定的1 &lt;= n,m &lt;= 100，基本可以判断这题可以用BFS或者DFS来进行遍历搜索问题的解。需要注意的是注意边界，以及如何求一个整数的数位和。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        Queue&lt;Point&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(<span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Point p = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (inArea(m, n, p.x, p.y) &amp;&amp; !visited[p.x][p.y] &amp;&amp;</span><br><span class="line">                    sumOfDigits(p.x) + sumOfDigits(p.y) &lt;= k) &#123;</span><br><span class="line">                visited[p.x][p.y] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : direction) &#123;</span><br><span class="line">                    <span class="keyword">int</span> curX = p.x + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> curY = p.y + dir[<span class="number">1</span>];</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Point(curX, curY));</span><br><span class="line">                &#125;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumOfDigits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> j &gt;= <span class="number">0</span> &amp;&amp; j &lt; col;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="第二种解法dp"><a href="#第二种解法dp" class="headerlink" title="第二种解法dp"></a>第二种解法dp</h4><p>计算整个平面，那些点能够走到，每个点只能从上或从左边走到，并且本身的数位和小于等于K<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span> || sumOfDigits(i) + sumOfDigits(j) &gt; k) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) visited[i][j] |= visited[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) visited[i][j] |= visited[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (visited[i][j]) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumOfDigits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;力扣中国 面试题13. 机器人的运动范围&lt;/a&gt;&lt;br&gt;题目：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。请问该机器人能够到达多少个格子？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="BFS" scheme="https://dpcfury.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>DNS解析过程</title>
    <link href="https://dpcfury.github.io/dns-resolve.html/"/>
    <id>https://dpcfury.github.io/dns-resolve.html/</id>
    <published>2020-04-08T11:01:48.000Z</published>
    <updated>2020-04-08T11:45:26.494Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在日常的开发和问题排查中，难免会遇到DNS解析的问题，尤其是在云计算中，内部组件因为DNS解析问题导致的问题层出不穷。借此，总计一下基本的DNS原理，以及日常生活中，一次DNS解析的过程。</p></blockquote><a id="more"></a><h4 id="为什么需要DNS解析？"><a href="#为什么需要DNS解析？" class="headerlink" title="为什么需要DNS解析？"></a>为什么需要DNS解析？</h4><p>在互联网通信中，大部分应用基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络层只能识别”192.168.1.24”之类的IP地址，而不能认识域名。而互联网大量的服务是无法全部通过IP给用户提供服务的，用户无法记住这么多的IP地址，并且固定IP地址也不利于互联网服务的高可用实现，域名相对来说用户能够容易记住和使用，<strong>www.baidu.com</strong> 肯定比61.135.169.125这种地址方便访问，那么为了能够使用域名进行互联网访问，就需要一个翻译器（DNS）讲域名翻译为对应的IP地址。</p><h4 id="DNS是什么"><a href="#DNS是什么" class="headerlink" title="DNS是什么"></a>DNS是什么</h4><p>DNS的全称是<strong>（Domain Name System）</strong>，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。通过域名，最终得到该域名对应的IP地址的过程则是域名解析的过程。</p><h4 id="DNS如何解析"><a href="#DNS如何解析" class="headerlink" title="DNS如何解析"></a>DNS如何解析</h4><h5 id="1-递归查询"><a href="#1-递归查询" class="headerlink" title="1. 递归查询"></a>1. 递归查询</h5><p>某天，客户端想要访问XXX网站，但是，客户端并不知道XXX网站的IP地址。于是，展开了如下对话</p><ul><li>客户端：“本地DNS服务器大佬，求问XXX的IP地址是多少？”</li><li>本地DNS服务器：“不好意思，我不知道，但是根域名服务器可能会知道，我替去问他吧”</li><li>本地DNS服务器：“根域名服务器大佬，求问XXX的IP地址是多少？”</li><li>根域名服务器：“不好意思，我不也知道，但是A顶级域名服务器可能会知道，我替你去问他吧”</li><li>根域名服务器：“A顶级域名服务器，求问XXX的IP地址是多少？”</li><li>A顶级域名服务器：“不好意思，我不也知道，但是B域名服务器可能会知道，我替你去问他吧”</li><li>A顶级域名服务器：“B域名服务器，求问XXX的IP地址是多少？”</li><li>B域名服务器：“A顶级域名服务器，查到XXX的IP地址是192.168.168.6”</li><li>A顶级域名服务器：“根域名服务器，查到XXX的IP地址是192.168.168.6”</li><li>根域名服务器：“本地DNS服务器，查到XXX的IP地址是192.168.168.6”</li><li>本地DNS服务器： “客户端，查到XXX的IP地址是192.168.168.6”</li><li>客户端：“谢谢各位大佬，XXX的IP地址是192.168.168.6，我可以和他愉快的通讯了”<br><img src="https://user-gold-cdn.xitu.io/2018/5/27/1639fd992859d5f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="dns 递归查询"></li></ul><h5 id="2-迭代查询"><a href="#2-迭代查询" class="headerlink" title="2. 迭代查询"></a>2. 迭代查询</h5><p>客户端：“本地DNS服务器大佬，求问XXX的IP地址是多少？”</p><ul><li>本地DNS服务器：“不好意思，我不知道，但是根域名服务器可能会知道，你去问他吧”，本地DNS服务器说完，并把根域名服务器地址发给客户端。</li><li>客户端：“根域名服务器大佬，求问XXX的IP地址是多少？”</li><li>根域名服务器：“不好意思，我不也知道，但是A顶级域名服务器可能会知道，你去问他吧”，根域名服务器说完，并把A顶级域名服务器地址发给客户端。</li><li>客户端只能又跑去问A顶级域名服务器了。</li><li>客户端：“A顶级域名服务器大佬，求问XXX的IP地址是多少？”</li><li>A顶级域名服务器：“不好意思，我不也知道，但是B域名服务器可能会知道，你去问他吧”，A顶级域名服务器说完，并把B域名服务器地址发给客户端。</li><li>客户端非常无奈，只能又跑去问B域名服务器了。</li><li>客户端：“B域名服务器大佬，求问XXX的IP地址是多少？”</li><li>B域名服务器：“客户端同学，查到XXX的IP地址是192.168.168.6”。</li><li>客户端：“谢谢B域名服务器大佬，XXX的IP地址是192.168.168.6，我可以和他愉快的通讯了”<br>就这样，客户端在询问了一大圈之后，终于知道了XXX的IP地址了。<br><img src="https://user-gold-cdn.xitu.io/2018/5/27/1639fdb27f876e0d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="dns 迭代查询"></li></ul><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>实际上，在DNS查询过程中，客户端和服务器也都会加入缓存的机制，这样可以减少查询的次数，加快域名解析过程。</p><h4 id="一次请求的DNS解析过程"><a href="#一次请求的DNS解析过程" class="headerlink" title="一次请求的DNS解析过程"></a>一次请求的DNS解析过程</h4><ol><li><p>在浏览器中输入<strong>www.baidu.com</strong> 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 </p></li><li><p>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 </p></li><li><p>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 </p></li><li><p>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p></li><li><p>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(<strong>.com</strong>)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址<strong>qq.com</strong>域服务器，重复上面的动作，进行查询，直至找到<strong>www.baidu.com</strong> </p></li><li><p>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p></li></ol><p><strong>TIP</strong>: 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。<br><img src="https://pic4.zhimg.com/80/7fcd81756bdc8b52ade0531402c43e43_720w.jpg" alt="解析过程"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在日常的开发和问题排查中，难免会遇到DNS解析的问题，尤其是在云计算中，内部组件因为DNS解析问题导致的问题层出不穷。借此，总计一下基本的DNS原理，以及日常生活中，一次DNS解析的过程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="network" scheme="https://dpcfury.github.io/categories/network/"/>
    
    
      <category term="dns" scheme="https://dpcfury.github.io/tags/dns/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1092] Shortest Common Supersequence</title>
    <link href="https://dpcfury.github.io/shortest-common-supersequence.html/"/>
    <id>https://dpcfury.github.io/shortest-common-supersequence.html/</id>
    <published>2020-04-07T15:56:26.000Z</published>
    <updated>2020-04-07T16:05:09.685Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/shortest-common-supersequence/" target="_blank" rel="noopener">Leetcode 1092. Shortest Common Supersequence</a><br>这道题延伸自最短编辑距离问题（Edit Distance），题目唯一描述不同的是，需要求出最终的结果，而不仅仅是最短的长度。结题的思路还是先去找问题的收敛入口，进而找到子问题和最优结构，推导出表达式后，再自定向上求解。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>和普通的do不同，这里需要计算出最终的superSequence结果，乍一看会有点懵，但是其实道理相同，还是<br>先令dp[i][j] 为str1前i个字符和str2的前j个字符串，其最短的superSequence长度；<br>那么表达式为：</p><ul><li>case0: s.charAt[i] == s.charAt[j]，则dp[i][j] = dp[i+1][j-1] +1</li><li>case1: s.charAt[i] != s.charAt[j]，则dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])+1</li></ul><p>然后从后往前，分批便利str1和str2，如果当前两个字符串位置上的字符相同，就把字符添加到结果，如果不同，选择dp[i-1][j] 和dp[i][j-1]中小的那个，添加对应的字符即可。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>approach1 : 最初的写法，空间会超<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestCommonSupersequence1</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = str1.length();</span><br><span class="line">        <span class="keyword">int</span> n = str2.length();</span><br><span class="line">        String[][] dp = <span class="keyword">new</span> String[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = str1.substring(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = str2.substring(<span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c1 = str1.charAt(i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">char</span> c2 = str2.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + c1;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    String s1 = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    String s2 = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    String s3 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    String res = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">if</span> (s1.length() &lt; s2.length()) res = s1 + c2;</span><br><span class="line">                    <span class="keyword">else</span> res = s2 + c1;</span><br><span class="line">                    <span class="keyword">if</span> (s3.length() + <span class="number">2</span> &lt; res.length()) res = s3 + c1 + c2;</span><br><span class="line">                    dp[i][j] = res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>approach2: 优化写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestCommonSupersequence</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = str1.length();</span><br><span class="line">        <span class="keyword">int</span> j = str2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = shortestCS(str1, str2);</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i - <span class="number">1</span>) == str2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                str.append(str1.charAt(i - <span class="number">1</span>));</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &lt; dp[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                str.append(str1.charAt(i - <span class="number">1</span>));</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str.append(str2.charAt(j - <span class="number">1</span>));</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            str.append(str1.charAt(i - <span class="number">1</span>));</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            str.append(str2.charAt(j - <span class="number">1</span>));</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/shortest-common-supersequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1092. Shortest Common Supersequence&lt;/a&gt;&lt;br&gt;这道题延伸自最短编辑距离问题（Edit Distance），题目唯一描述不同的是，需要求出最终的结果，而不仅仅是最短的长度。结题的思路还是先去找问题的收敛入口，进而找到子问题和最优结构，推导出表达式后，再自定向上求解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[48] Rotate Image</title>
    <link href="https://dpcfury.github.io/rotate-image.html/"/>
    <id>https://dpcfury.github.io/rotate-image.html/</id>
    <published>2020-04-07T15:50:07.000Z</published>
    <updated>2020-04-07T16:27:20.753Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/rotate-image/" target="_blank" rel="noopener">Leetcode 48. Rotate Image</a><br>题目要求在原地对二维矩阵中的元素进行顺时针90度的旋转，而且不能借助额外的辅助空间（比如创建一个同等大小的二维数组）。这题通过纸上多画图尝试尝试，就能找到规律，我们所能做的操作只有行和列操作，以及围绕对角线的操作，试着试着这题的答案就可以出来了。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对二维数组的行进行围绕中间轴的上线交换，再围绕对角线对元素进行交换，就能得到最终的结果。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = matrix[i];</span><br><span class="line">            matrix[i] = matrix[n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/rotate-image/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 48. Rotate Image&lt;/a&gt;&lt;br&gt;题目要求在原地对二维矩阵中的元素进行顺时针90度的旋转，而且不能借助额外的辅助空间（比如创建一个同等大小的二维数组）。这题通过纸上多画图尝试尝试，就能找到规律，我们所能做的操作只有行和列操作，以及围绕对角线的操作，试着试着这题的答案就可以出来了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="matrix" scheme="https://dpcfury.github.io/tags/matrix/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[516] Longest Palindromic Subsequence</title>
    <link href="https://dpcfury.github.io/longest-palindromic-subsequence.html/"/>
    <id>https://dpcfury.github.io/longest-palindromic-subsequence.html/</id>
    <published>2020-04-06T14:11:08.000Z</published>
    <updated>2020-04-06T14:33:22.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">Leetcode 516. Longest Palindromic Subsequence</a><br>这题也是经典的动态规划题，同样遵循通用的解体思路，首先是理解题目的意思，然后在寻找问题规模缩小的入口，慢慢推导出子问题和最优结构，从而总结出表达式，然后自底向上实现。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先，回文字符串的特点要理解，对单个字符而言，都是长度为1的回文串；<br>其次，我们能够缩小的范围只有字符中字串的大小，即字串的开始和终止位置；<br>令dp[i][j]为字符串subString(i,j+1)中，包含的回文子穿最大长度；<br>进而，可以发现，计算dp[i][j]的方法如下：</p><ul><li>case0: s.charAt[i] == s.charAt[j]，则dp[i][j] = dp[i+1][j-1] +2</li><li>case1: s.charAt[i] != s.charAt[j]，则dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])</li></ul><p>那么最终的我们求的dp[0][s.length()-1]即为最终的解。</p><p>但是，我们如何自底向上进行求解呢，已知dp[i][i]的初始值为1，我们可以从不同长度的回文串开始着手，<br>首先求长度间隙为1（即dp[i][i]），然后长度间隙为2 … 到长度间隙为n-1。一步一步，慢慢实现自底向上。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>下面给出我个人实现的一种算法，目前并未进行优化，理论上这种时间遍历的消耗可以提前削减<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n - <span class="number">1</span>; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start + len &lt; n; start++) &#123;</span><br><span class="line">                <span class="keyword">int</span> end = start + len;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(start) == s.charAt(end)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (start + <span class="number">1</span> == end) &#123;</span><br><span class="line">                        dp[start][end] = <span class="number">2</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[start][end] = dp[start + <span class="number">1</span>][end - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[start][end] = Math.max(dp[start + <span class="number">1</span>][end], dp[start][end - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 516. Longest Palindromic Subsequence&lt;/a&gt;&lt;br&gt;这题也是经典的动态规划题，同样遵循通用的解体思路，首先是理解题目的意思，然后在寻找问题规模缩小的入口，慢慢推导出子问题和最优结构，从而总结出表达式，然后自底向上实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1143] Longest Common Subsequence</title>
    <link href="https://dpcfury.github.io/longest-common-subsequence.html/"/>
    <id>https://dpcfury.github.io/longest-common-subsequence.html/</id>
    <published>2020-04-06T13:02:23.000Z</published>
    <updated>2020-04-06T13:12:46.053Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">Leetcode 1143. Longest Common Subsequence</a><br>题目和字符串编辑问题类似，同样属于非常经典的动态规划，只要我们找到其中问题规模的收敛入口，继而推导出递归表达式，通过自底向下的方式进行实现。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定两个字符串，text1和text2，求其中最长的公共字符子序列长度。为什么说这道题目一样很经典，子序列的问题，通常我们都能一下找到问题规模缩小的入口，即将字符串的规模缩小，再通过比较指定位置字符的是否相同，将问题规模缩小到子问题的求解过程中。<br>我们令dp[i][j] 为text1前i个字符和text2的前j个字符，其最长公共子序列的长度，那么：</p><ul><li>case1:  text1.charAt(i-1) == text2.charAt(j-1)，那么dp[i][j] = dp[i-1][j-1] + 1</li><li>case2:  text1.charAt(i-1) != word2.text2(j-1)：<ul><li>可能1: dp[i][j] = dp[i-1][j]  // 最长为text1前i-1字符串和text2前j个字符</li><li>可能2: dp[i][j] = dp[i][j-1] // 最长为text1前i字符串和text2前j-1个字符</li><li>可能3: dp[i][j] = dp[i-1][j-1] // 最长为text1前i-1字符串和text2前j-1个字符<br>即 dp[i][j] = max(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])</li></ul></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (text1 == <span class="keyword">null</span> || text2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length();</span><br><span class="line">        <span class="keyword">int</span> n = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(Math.max(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1143. Longest Common Subsequence&lt;/a&gt;&lt;br&gt;题目和字符串编辑问题类似，同样属于非常经典的动态规划，只要我们找到其中问题规模的收敛入口，继而推导出递归表达式，通过自底向下的方式进行实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[583] Delete Operation for Two Strings</title>
    <link href="https://dpcfury.github.io/delete-operation-for-two-strings.html/"/>
    <id>https://dpcfury.github.io/delete-operation-for-two-strings.html/</id>
    <published>2020-04-06T12:19:30.000Z</published>
    <updated>2020-04-06T12:33:47.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener"> Leetcode 583 Delete Operation for Two Strings</a><br>题目和经典的Edit Distance 属于同一类问题，只是允许的操作变限制为了删除操作，问需要两个单词需要最少的删除操作，能够变为相同的字符串。核心还是如何找到一个问题规模收敛的入口，从而在问题规模缩小的过程中，找到递推的规律，进而推导出表达式，再利用自顶向下或自底向上的方法去实现。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定word1和word2，通过最少的删除操作，使得两个单词最终变为相同的字符串，先从特殊的情况开始考虑，如果某个单词为空串（长度为0），另一个不为空串，则需要的最少操作步骤为不为空的单词长度。从中又可以感受到一点动态规划的味道。<br>继续分析，假设令dp[i][j] 为word1前i个字符串 和word2前j个字符串，变成相同字符串需要的最少删除次数，那么：</p><ul><li>case1:  word1.charAt(i-1) == word2.charAt(j-1)，那么dp[i][j] = dp[i-1][j-1]</li><li>case2:  word1.charAt(i-1) != word2.charAt(j-1)：<ul><li>可能1: dp[i][j] = dp[i-1][j]+1  // 通过word2insert一个字符</li><li>可能2: dp[i][j] = dp[i][j-1] +1 // 通过word1insert一个字符</li></ul></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1 == <span class="keyword">null</span> || word2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/delete-operation-for-two-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; Leetcode 583 Delete Operation for Two Strings&lt;/a&gt;&lt;br&gt;题目和经典的Edit Distance 属于同一类问题，只是允许的操作变限制为了删除操作，问需要两个单词需要最少的删除操作，能够变为相同的字符串。核心还是如何找到一个问题规模收敛的入口，从而在问题规模缩小的过程中，找到递推的规律，进而推导出表达式，再利用自顶向下或自底向上的方法去实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[72] Edit Distance</title>
    <link href="https://dpcfury.github.io/edit-distance.html/"/>
    <id>https://dpcfury.github.io/edit-distance.html/</id>
    <published>2020-04-06T01:50:05.000Z</published>
    <updated>2020-04-06T14:45:43.666Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">Leetcode 72. Edit Distance</a><br>经典的动态规划题目，求从一个字符串通过三种操作转换为另一个字符串的短编辑记录（最少的转换步骤），允许的操作包括：1. 插入；2. 删除；3. 替换。这题的核心是还是如何找一个收敛的入口，在问题规模缩小过程中，找到递推的规律，再通过自底向上或自顶向下的方式实现即可。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定的word1，word2，在极限情况下，假设word2位空字符串（长度为0），那么word1 转换为word2，需要进行word1.length()次删除操作。假设word1为空字符串（长度为0），需要进行word2.length（）次删除操作。这么一看，是不是有点递推边界的味道。<br>继续往下看，假设令dp[i][j] 为从word1的前i个字符转换为word2前j个字符所需的最短编辑记录，那么如何计算dp[i][j]：</p><ul><li>case1:  word1.charAt(i-1) == word2.charAt(j-1)，那么dp[i][j] = dp[i-1][j-1]</li><li>case2:  word1.charAt(i-1) != word2.charAt(j-1)：<ul><li>可能1: dp[i][j] = dp[i-1][j]+1  // 通过remove</li><li>可能2: dp[i][j] = dp[i][j-1] +1 // 通过insert或replace</li><li>可能3: dp[i][j] = dp[i-1][j-1]+1 //通过insert或replace</li></ul></li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1 == <span class="keyword">null</span> || word2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]), dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/edit-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 72. Edit Distance&lt;/a&gt;&lt;br&gt;经典的动态规划题目，求从一个字符串通过三种操作转换为另一个字符串的短编辑记录（最少的转换步骤），允许的操作包括：1. 插入；2. 删除；3. 替换。这题的核心是还是如何找一个收敛的入口，在问题规模缩小过程中，找到递推的规律，再通过自底向上或自顶向下的方式实现即可。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[46] LFU Cache</title>
    <link href="https://dpcfury.github.io/lfu-cache.html/"/>
    <id>https://dpcfury.github.io/lfu-cache.html/</id>
    <published>2020-04-05T15:53:02.000Z</published>
    <updated>2020-04-05T16:15:19.249Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/lfu-cache/" target="_blank" rel="noopener">Leetcode 46.  LFU Cache</a><br>题目要求实现计算机页面置换中经典的LFU算法，和LRU一字之别，但是含义完全不同，LFU即<br>Least Frequently Used，就是在缓存容量不够，需要置换的时候，替换策略是：将当前时间页面（key）访问次数最少的页面替换，然后将新的缓存更新。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>tip1: 考虑涉及到访问次数的统计</li><li>tip2: 题目要求在O(1)时间完成所有操作</li></ul><p>于是，首先会想到Map，将对应的key和响应的值进行映射，加快get的访问速率；此外，考虑不同访问频率的页面需要在O(1)进行找到和替换，那么需要很快找到对应的访问频率最低元素，这里设计一个<strong>{“frequency”:List<key>}</key></strong>映射。将每个访问频率的key缓存到一个优先队列（LinkedList中），新缓存的在队列尾部，时间久的在队列头部。在进行替换的过程中，首先剔除访问频率最小那个队列中，时间最久的key。<br>    在get访问中，对相应元素key进行访问频率升级，迁移到fre+1 队列中操作需要注意的是，put操作对相同key的更新，也需要进行一次get，从而更新访问频率。</p><p>实现算法如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> fre;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> fre)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.fre = fre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">         * LFUCache obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment">         * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment">         * obj.put(key,value);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> minFre; <span class="comment">// 出现的最小频率</span></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Integer, Item&gt; map; <span class="comment">//key对value索引</span></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; fre; <span class="comment">// key出现频率索引</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">            <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.fre = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 更新频率，返回值</span></span><br><span class="line">            Item item = map.get(key);</span><br><span class="line">            <span class="comment">// 找到频率列表，删除元素</span></span><br><span class="line">            LinkedList&lt;Integer&gt; oldFreList = fre.get(item.fre);</span><br><span class="line">            oldFreList.remove(Integer.valueOf(key));</span><br><span class="line">            <span class="comment">// 对应新的频率列表添加元素</span></span><br><span class="line">            LinkedList&lt;Integer&gt; newFreList = fre.computeIfAbsent(item.fre + <span class="number">1</span>, k -&gt; <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            newFreList.addLast(key);</span><br><span class="line">            item.fre++;</span><br><span class="line">            <span class="comment">//如果freq中频率为minFreq的list为空，minFreq自增1</span></span><br><span class="line">            <span class="keyword">if</span> (fre.get(minFre) == <span class="keyword">null</span> || fre.get(minFre).size() == <span class="number">0</span>) minFre++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> item.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (get(key) != -<span class="number">1</span>) <span class="comment">//更新也算访问一次</span></span><br><span class="line">                    map.get(key).val = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">                LinkedList&lt;Integer&gt; minList = fre.get(minFre);</span><br><span class="line">                <span class="keyword">int</span> k = minList.removeFirst();</span><br><span class="line">                map.remove(k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, <span class="keyword">new</span> Item(value, <span class="number">0</span>));</span><br><span class="line">            LinkedList&lt;Integer&gt; minList = fre.computeIfAbsent(<span class="number">0</span>, k -&gt; <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            minList.addLast(key);</span><br><span class="line">            minFre = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/lfu-cache/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 46.  LFU Cache&lt;/a&gt;&lt;br&gt;题目要求实现计算机页面置换中经典的LFU算法，和LRU一字之别，但是含义完全不同，LFU即&lt;br&gt;Least Frequently Used，就是在缓存容量不够，需要置换的时候，替换策略是：将当前时间页面（key）访问次数最少的页面替换，然后将新的缓存更新。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
      <category term="lfu" scheme="https://dpcfury.github.io/tags/lfu/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[42] Trapping Rain Water</title>
    <link href="https://dpcfury.github.io/trapping-rain-water.html/"/>
    <id>https://dpcfury.github.io/trapping-rain-water.html/</id>
    <published>2020-04-04T01:13:04.000Z</published>
    <updated>2020-04-04T01:21:43.136Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">Leetcode 42. Trapping Rain Water</a><br>题目给定一个整形数组，代表高低相间的柱状体，问下完雨之后，这些柱状体之间的缝隙空间能装载多少水。这里提供自己比较喜欢的一种直观解法，理解非常方便。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>从每个柱体进行考虑，这一格柱体能承载多少水，是由其左侧最高的柱体+ 右侧最高的柱体+本身的柱体高度决定，只要能计算出每个柱体能承载多少水，就能计算出总的盛水量。<br>实现方式：</p><ul><li>从左往右遍历，计算出每个柱体左边最高的柱体，记为leftMax[i]；</li><li>从右往左遍历，计算出每个柱体右侧最高的柱体，记为rightMax[i];</li><li>从迁往后遍历，计算每个柱体盛水量</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span> max1 = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            max1 = Math.max(max1, height[i]);</span><br><span class="line">            leftMax[i] = max1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max2 = height[height.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = height.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            max2 = Math.max(max2, height[j]);</span><br><span class="line">            rightMax[j] = max2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(leftMax[i], rightMax[i]);</span><br><span class="line">            <span class="keyword">if</span> (min &gt; height[i]) num += min - height[i];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/trapping-rain-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 42. Trapping Rain Water&lt;/a&gt;&lt;br&gt;题目给定一个整形数组，代表高低相间的柱状体，问下完雨之后，这些柱状体之间的缝隙空间能装载多少水。这里提供自己比较喜欢的一种直观解法，理解非常方便。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[8]String to Integer (atoi)</title>
    <link href="https://dpcfury.github.io/string-to-integer.html/"/>
    <id>https://dpcfury.github.io/string-to-integer.html/</id>
    <published>2020-04-03T14:41:07.000Z</published>
    <updated>2020-04-03T14:46:43.988Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">Leetcode 8. String to Integer (atoi)</a><br>题目要实现一个 atoi 函数，使其能将字符串转换成整数。确切的说，这种字符的类型五花八门，有很多中形式，除了正负号的判断，还需要判断数字的合法性，数字的长度是否超越32位整数的边界等，属于细节题，不做过多的描述，比较好的方式是不用借助太多的标记为，而是分阶段进行处理，先处理空格，再处理符号，再处理数字。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> negative=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(str.length()&gt;index &amp;&amp; str.charAt(index)==<span class="string">' '</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=str.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(index)==<span class="string">'+'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(index)==<span class="string">'-'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            negative=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index&gt;=str.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Character.isDigit(str.charAt(index))==<span class="keyword">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startIndex=index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> endIndex=startIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex; i&lt;str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)&gt;=<span class="string">'0'</span> &amp;&amp; str.charAt(i)&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">                endIndex++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex; i&lt;endIndex; i++) &#123;</span><br><span class="line">            num=(num*<span class="number">10</span>)+Double.parseDouble(Character.toString(str.charAt(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> (negative)?Integer.MIN_VALUE:Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> negative?(<span class="keyword">int</span>)(-<span class="number">1</span>*num):(<span class="keyword">int</span>)num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/string-to-integer-atoi/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 8. String to Integer (atoi)&lt;/a&gt;&lt;br&gt;题目要实现一个 atoi 函数，使其能将字符串转换成整数。确切的说，这种字符的类型五花八门，有很多中形式，除了正负号的判断，还需要判断数字的合法性，数字的长度是否超越32位整数的边界等，属于细节题，不做过多的描述，比较好的方式是不用借助太多的标记为，而是分阶段进行处理，先处理空格，再处理符号，再处理数字。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>todo-list</title>
    <link href="https://dpcfury.github.io/todo-list.html/"/>
    <id>https://dpcfury.github.io/todo-list.html/</id>
    <published>2020-04-03T07:55:08.000Z</published>
    <updated>2020-04-03T08:07:01.818Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>罗列平时工作学习中需要总结的内容，可以开拓视野的内容。因为来不及实践或总结成博客，暂时记个todo，方便有时间去尝试和整理。</p></blockquote><a id="more"></a><ol><li><p>Spring Boot 微服务应用集成Prometheus + Grafana 实现监控告警(reference :<a href="https://juejin.im/post/5e27acf6e51d4557ea363a65" target="_blank" rel="noopener">https://juejin.im/post/5e27acf6e51d4557ea363a65</a>)</p></li><li><p>python 垃圾回收</p></li><li><p>问题：一次web请求，所创建对象的垃圾回收和session相关的垃圾回收，首先了解拉垃圾对象的判别（核心）</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;罗列平时工作学习中需要总结的内容，可以开拓视野的内容。因为来不及实践或总结成博客，暂时记个todo，方便有时间去尝试和整理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="todo" scheme="https://dpcfury.github.io/categories/todo/"/>
    
    
  </entry>
  
</feed>
