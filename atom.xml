<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DPC&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/bfa2adcbfd5883f9905426b1399816ee</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dpcfury.github.io/"/>
  <updated>2020-04-08T14:30:41.863Z</updated>
  <id>https://dpcfury.github.io/</id>
  
  <author>
    <name>杜鹏程</name>
    <email>dpcspark@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器人运动范围</title>
    <link href="https://dpcfury.github.io/robot-move-range.html/"/>
    <id>https://dpcfury.github.io/robot-move-range.html/</id>
    <published>2020-04-08T14:24:39.000Z</published>
    <updated>2020-04-08T14:30:41.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">力扣中国 面试题13. 机器人的运动范围</a><br>题目：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。请问该机器人能够到达多少个格子？</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目给出的描述和经常遇到的二维矩阵题非常类似，再加上题目限定的1 &lt;= n,m &lt;= 100，基本可以判断这题可以用BFS或者DFS来进行遍历搜索问题的解。需要注意的是注意边界，以及如何求一个整数的数位和。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        Queue&lt;Point&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(<span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Point p = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (inArea(m, n, p.x, p.y) &amp;&amp; !visited[p.x][p.y] &amp;&amp;</span><br><span class="line">                    sumOfDigits(p.x) + sumOfDigits(p.y) &lt;= k) &#123;</span><br><span class="line">                visited[p.x][p.y] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : direction) &#123;</span><br><span class="line">                    <span class="keyword">int</span> curX = p.x + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> curY = p.y + dir[<span class="number">1</span>];</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Point(curX, curY));</span><br><span class="line">                &#125;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumOfDigits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> j &gt;= <span class="number">0</span> &amp;&amp; j &lt; col;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;力扣中国 面试题13. 机器人的运动范围&lt;/a&gt;&lt;br&gt;题目：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。请问该机器人能够到达多少个格子？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="BFS" scheme="https://dpcfury.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>DNS解析过程</title>
    <link href="https://dpcfury.github.io/dns-resolve.html/"/>
    <id>https://dpcfury.github.io/dns-resolve.html/</id>
    <published>2020-04-08T11:01:48.000Z</published>
    <updated>2020-04-08T11:45:26.494Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在日常的开发和问题排查中，难免会遇到DNS解析的问题，尤其是在云计算中，内部组件因为DNS解析问题导致的问题层出不穷。借此，总计一下基本的DNS原理，以及日常生活中，一次DNS解析的过程。</p></blockquote><a id="more"></a><h4 id="为什么需要DNS解析？"><a href="#为什么需要DNS解析？" class="headerlink" title="为什么需要DNS解析？"></a>为什么需要DNS解析？</h4><p>在互联网通信中，大部分应用基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络层只能识别”192.168.1.24”之类的IP地址，而不能认识域名。而互联网大量的服务是无法全部通过IP给用户提供服务的，用户无法记住这么多的IP地址，并且固定IP地址也不利于互联网服务的高可用实现，域名相对来说用户能够容易记住和使用，<strong>www.baidu.com</strong> 肯定比61.135.169.125这种地址方便访问，那么为了能够使用域名进行互联网访问，就需要一个翻译器（DNS）讲域名翻译为对应的IP地址。</p><h4 id="DNS是什么"><a href="#DNS是什么" class="headerlink" title="DNS是什么"></a>DNS是什么</h4><p>DNS的全称是<strong>（Domain Name System）</strong>，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。通过域名，最终得到该域名对应的IP地址的过程则是域名解析的过程。</p><h4 id="DNS如何解析"><a href="#DNS如何解析" class="headerlink" title="DNS如何解析"></a>DNS如何解析</h4><h5 id="1-递归查询"><a href="#1-递归查询" class="headerlink" title="1. 递归查询"></a>1. 递归查询</h5><p>某天，客户端想要访问XXX网站，但是，客户端并不知道XXX网站的IP地址。于是，展开了如下对话</p><ul><li>客户端：“本地DNS服务器大佬，求问XXX的IP地址是多少？”</li><li>本地DNS服务器：“不好意思，我不知道，但是根域名服务器可能会知道，我替去问他吧”</li><li>本地DNS服务器：“根域名服务器大佬，求问XXX的IP地址是多少？”</li><li>根域名服务器：“不好意思，我不也知道，但是A顶级域名服务器可能会知道，我替你去问他吧”</li><li>根域名服务器：“A顶级域名服务器，求问XXX的IP地址是多少？”</li><li>A顶级域名服务器：“不好意思，我不也知道，但是B域名服务器可能会知道，我替你去问他吧”</li><li>A顶级域名服务器：“B域名服务器，求问XXX的IP地址是多少？”</li><li>B域名服务器：“A顶级域名服务器，查到XXX的IP地址是192.168.168.6”</li><li>A顶级域名服务器：“根域名服务器，查到XXX的IP地址是192.168.168.6”</li><li>根域名服务器：“本地DNS服务器，查到XXX的IP地址是192.168.168.6”</li><li>本地DNS服务器： “客户端，查到XXX的IP地址是192.168.168.6”</li><li>客户端：“谢谢各位大佬，XXX的IP地址是192.168.168.6，我可以和他愉快的通讯了”<br><img src="https://user-gold-cdn.xitu.io/2018/5/27/1639fd992859d5f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="dns 递归查询"></li></ul><h5 id="2-迭代查询"><a href="#2-迭代查询" class="headerlink" title="2. 迭代查询"></a>2. 迭代查询</h5><p>客户端：“本地DNS服务器大佬，求问XXX的IP地址是多少？”</p><ul><li>本地DNS服务器：“不好意思，我不知道，但是根域名服务器可能会知道，你去问他吧”，本地DNS服务器说完，并把根域名服务器地址发给客户端。</li><li>客户端：“根域名服务器大佬，求问XXX的IP地址是多少？”</li><li>根域名服务器：“不好意思，我不也知道，但是A顶级域名服务器可能会知道，你去问他吧”，根域名服务器说完，并把A顶级域名服务器地址发给客户端。</li><li>客户端只能又跑去问A顶级域名服务器了。</li><li>客户端：“A顶级域名服务器大佬，求问XXX的IP地址是多少？”</li><li>A顶级域名服务器：“不好意思，我不也知道，但是B域名服务器可能会知道，你去问他吧”，A顶级域名服务器说完，并把B域名服务器地址发给客户端。</li><li>客户端非常无奈，只能又跑去问B域名服务器了。</li><li>客户端：“B域名服务器大佬，求问XXX的IP地址是多少？”</li><li>B域名服务器：“客户端同学，查到XXX的IP地址是192.168.168.6”。</li><li>客户端：“谢谢B域名服务器大佬，XXX的IP地址是192.168.168.6，我可以和他愉快的通讯了”<br>就这样，客户端在询问了一大圈之后，终于知道了XXX的IP地址了。<br><img src="https://user-gold-cdn.xitu.io/2018/5/27/1639fdb27f876e0d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="dns 迭代查询"></li></ul><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>实际上，在DNS查询过程中，客户端和服务器也都会加入缓存的机制，这样可以减少查询的次数，加快域名解析过程。</p><h4 id="一次请求的DNS解析过程"><a href="#一次请求的DNS解析过程" class="headerlink" title="一次请求的DNS解析过程"></a>一次请求的DNS解析过程</h4><ol><li><p>在浏览器中输入<strong>www.baidu.com</strong> 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 </p></li><li><p>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 </p></li><li><p>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 </p></li><li><p>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p></li><li><p>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(<strong>.com</strong>)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址<strong>qq.com</strong>域服务器，重复上面的动作，进行查询，直至找到<strong>www.baidu.com</strong> </p></li><li><p>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p></li></ol><p><strong>TIP</strong>: 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。<br><img src="https://pic4.zhimg.com/80/7fcd81756bdc8b52ade0531402c43e43_720w.jpg" alt="解析过程"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在日常的开发和问题排查中，难免会遇到DNS解析的问题，尤其是在云计算中，内部组件因为DNS解析问题导致的问题层出不穷。借此，总计一下基本的DNS原理，以及日常生活中，一次DNS解析的过程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="network" scheme="https://dpcfury.github.io/categories/network/"/>
    
    
      <category term="dns" scheme="https://dpcfury.github.io/tags/dns/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1092] Shortest Common Supersequence</title>
    <link href="https://dpcfury.github.io/shortest-common-supersequence.html/"/>
    <id>https://dpcfury.github.io/shortest-common-supersequence.html/</id>
    <published>2020-04-07T15:56:26.000Z</published>
    <updated>2020-04-07T16:05:09.685Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/shortest-common-supersequence/" target="_blank" rel="noopener">Leetcode 1092. Shortest Common Supersequence</a><br>这道题延伸自最短编辑距离问题（Edit Distance），题目唯一描述不同的是，需要求出最终的结果，而不仅仅是最短的长度。结题的思路还是先去找问题的收敛入口，进而找到子问题和最优结构，推导出表达式后，再自定向上求解。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>和普通的do不同，这里需要计算出最终的superSequence结果，乍一看会有点懵，但是其实道理相同，还是<br>先令dp[i][j] 为str1前i个字符和str2的前j个字符串，其最短的superSequence长度；<br>那么表达式为：</p><ul><li>case0: s.charAt[i] == s.charAt[j]，则dp[i][j] = dp[i+1][j-1] +1</li><li>case1: s.charAt[i] != s.charAt[j]，则dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])+1</li></ul><p>然后从后往前，分批便利str1和str2，如果当前两个字符串位置上的字符相同，就把字符添加到结果，如果不同，选择dp[i-1][j] 和dp[i][j-1]中小的那个，添加对应的字符即可。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>approach1 : 最初的写法，空间会超<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestCommonSupersequence1</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = str1.length();</span><br><span class="line">        <span class="keyword">int</span> n = str2.length();</span><br><span class="line">        String[][] dp = <span class="keyword">new</span> String[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = str1.substring(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = str2.substring(<span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c1 = str1.charAt(i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">char</span> c2 = str2.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + c1;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    String s1 = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    String s2 = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    String s3 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    String res = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">if</span> (s1.length() &lt; s2.length()) res = s1 + c2;</span><br><span class="line">                    <span class="keyword">else</span> res = s2 + c1;</span><br><span class="line">                    <span class="keyword">if</span> (s3.length() + <span class="number">2</span> &lt; res.length()) res = s3 + c1 + c2;</span><br><span class="line">                    dp[i][j] = res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>approach2: 优化写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestCommonSupersequence</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = str1.length();</span><br><span class="line">        <span class="keyword">int</span> j = str2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = shortestCS(str1, str2);</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i - <span class="number">1</span>) == str2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                str.append(str1.charAt(i - <span class="number">1</span>));</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &lt; dp[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                str.append(str1.charAt(i - <span class="number">1</span>));</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str.append(str2.charAt(j - <span class="number">1</span>));</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            str.append(str1.charAt(i - <span class="number">1</span>));</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            str.append(str2.charAt(j - <span class="number">1</span>));</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/shortest-common-supersequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1092. Shortest Common Supersequence&lt;/a&gt;&lt;br&gt;这道题延伸自最短编辑距离问题（Edit Distance），题目唯一描述不同的是，需要求出最终的结果，而不仅仅是最短的长度。结题的思路还是先去找问题的收敛入口，进而找到子问题和最优结构，推导出表达式后，再自定向上求解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[48] Rotate Image</title>
    <link href="https://dpcfury.github.io/rotate-image.html/"/>
    <id>https://dpcfury.github.io/rotate-image.html/</id>
    <published>2020-04-07T15:50:07.000Z</published>
    <updated>2020-04-07T16:27:20.753Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/rotate-image/" target="_blank" rel="noopener">Leetcode 48. Rotate Image</a><br>题目要求在原地对二维矩阵中的元素进行顺时针90度的旋转，而且不能借助额外的辅助空间（比如创建一个同等大小的二维数组）。这题通过纸上多画图尝试尝试，就能找到规律，我们所能做的操作只有行和列操作，以及围绕对角线的操作，试着试着这题的答案就可以出来了。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对二维数组的行进行围绕中间轴的上线交换，再围绕对角线对元素进行交换，就能得到最终的结果。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = matrix[i];</span><br><span class="line">            matrix[i] = matrix[n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/rotate-image/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 48. Rotate Image&lt;/a&gt;&lt;br&gt;题目要求在原地对二维矩阵中的元素进行顺时针90度的旋转，而且不能借助额外的辅助空间（比如创建一个同等大小的二维数组）。这题通过纸上多画图尝试尝试，就能找到规律，我们所能做的操作只有行和列操作，以及围绕对角线的操作，试着试着这题的答案就可以出来了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="matrix" scheme="https://dpcfury.github.io/tags/matrix/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[516] Longest Palindromic Subsequence</title>
    <link href="https://dpcfury.github.io/longest-palindromic-subsequence.html/"/>
    <id>https://dpcfury.github.io/longest-palindromic-subsequence.html/</id>
    <published>2020-04-06T14:11:08.000Z</published>
    <updated>2020-04-06T14:33:22.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">Leetcode 516. Longest Palindromic Subsequence</a><br>这题也是经典的动态规划题，同样遵循通用的解体思路，首先是理解题目的意思，然后在寻找问题规模缩小的入口，慢慢推导出子问题和最优结构，从而总结出表达式，然后自底向上实现。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先，回文字符串的特点要理解，对单个字符而言，都是长度为1的回文串；<br>其次，我们能够缩小的范围只有字符中字串的大小，即字串的开始和终止位置；<br>令dp[i][j]为字符串subString(i,j+1)中，包含的回文子穿最大长度；<br>进而，可以发现，计算dp[i][j]的方法如下：</p><ul><li>case0: s.charAt[i] == s.charAt[j]，则dp[i][j] = dp[i+1][j-1] +2</li><li>case1: s.charAt[i] != s.charAt[j]，则dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])</li></ul><p>那么最终的我们求的dp[0][s.length()-1]即为最终的解。</p><p>但是，我们如何自底向上进行求解呢，已知dp[i][i]的初始值为1，我们可以从不同长度的回文串开始着手，<br>首先求长度间隙为1（即dp[i][i]），然后长度间隙为2 … 到长度间隙为n-1。一步一步，慢慢实现自底向上。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>下面给出我个人实现的一种算法，目前并未进行优化，理论上这种时间遍历的消耗可以提前削减<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n - <span class="number">1</span>; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start + len &lt; n; start++) &#123;</span><br><span class="line">                <span class="keyword">int</span> end = start + len;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(start) == s.charAt(end)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (start + <span class="number">1</span> == end) &#123;</span><br><span class="line">                        dp[start][end] = <span class="number">2</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[start][end] = dp[start + <span class="number">1</span>][end - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[start][end] = Math.max(dp[start + <span class="number">1</span>][end], dp[start][end - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 516. Longest Palindromic Subsequence&lt;/a&gt;&lt;br&gt;这题也是经典的动态规划题，同样遵循通用的解体思路，首先是理解题目的意思，然后在寻找问题规模缩小的入口，慢慢推导出子问题和最优结构，从而总结出表达式，然后自底向上实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1143] Longest Common Subsequence</title>
    <link href="https://dpcfury.github.io/longest-common-subsequence.html/"/>
    <id>https://dpcfury.github.io/longest-common-subsequence.html/</id>
    <published>2020-04-06T13:02:23.000Z</published>
    <updated>2020-04-06T13:12:46.053Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">Leetcode 1143. Longest Common Subsequence</a><br>题目和字符串编辑问题类似，同样属于非常经典的动态规划，只要我们找到其中问题规模的收敛入口，继而推导出递归表达式，通过自底向下的方式进行实现。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定两个字符串，text1和text2，求其中最长的公共字符子序列长度。为什么说这道题目一样很经典，子序列的问题，通常我们都能一下找到问题规模缩小的入口，即将字符串的规模缩小，再通过比较指定位置字符的是否相同，将问题规模缩小到子问题的求解过程中。<br>我们令dp[i][j] 为text1前i个字符和text2的前j个字符，其最长公共子序列的长度，那么：</p><ul><li>case1:  text1.charAt(i-1) == text2.charAt(j-1)，那么dp[i][j] = dp[i-1][j-1] + 1</li><li>case2:  text1.charAt(i-1) != word2.text2(j-1)：<ul><li>可能1: dp[i][j] = dp[i-1][j]  // 最长为text1前i-1字符串和text2前j个字符</li><li>可能2: dp[i][j] = dp[i][j-1] // 最长为text1前i字符串和text2前j-1个字符</li><li>可能3: dp[i][j] = dp[i-1][j-1] // 最长为text1前i-1字符串和text2前j-1个字符<br>即 dp[i][j] = max(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])</li></ul></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (text1 == <span class="keyword">null</span> || text2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length();</span><br><span class="line">        <span class="keyword">int</span> n = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(Math.max(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1143. Longest Common Subsequence&lt;/a&gt;&lt;br&gt;题目和字符串编辑问题类似，同样属于非常经典的动态规划，只要我们找到其中问题规模的收敛入口，继而推导出递归表达式，通过自底向下的方式进行实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[583] Delete Operation for Two Strings</title>
    <link href="https://dpcfury.github.io/delete-operation-for-two-strings.html/"/>
    <id>https://dpcfury.github.io/delete-operation-for-two-strings.html/</id>
    <published>2020-04-06T12:19:30.000Z</published>
    <updated>2020-04-06T12:33:47.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener"> Leetcode 583 Delete Operation for Two Strings</a><br>题目和经典的Edit Distance 属于同一类问题，只是允许的操作变限制为了删除操作，问需要两个单词需要最少的删除操作，能够变为相同的字符串。核心还是如何找到一个问题规模收敛的入口，从而在问题规模缩小的过程中，找到递推的规律，进而推导出表达式，再利用自顶向下或自底向上的方法去实现。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定word1和word2，通过最少的删除操作，使得两个单词最终变为相同的字符串，先从特殊的情况开始考虑，如果某个单词为空串（长度为0），另一个不为空串，则需要的最少操作步骤为不为空的单词长度。从中又可以感受到一点动态规划的味道。<br>继续分析，假设令dp[i][j] 为word1前i个字符串 和word2前j个字符串，变成相同字符串需要的最少删除次数，那么：</p><ul><li>case1:  word1.charAt(i-1) == word2.charAt(j-1)，那么dp[i][j] = dp[i-1][j-1]</li><li>case2:  word1.charAt(i-1) != word2.charAt(j-1)：<ul><li>可能1: dp[i][j] = dp[i-1][j]+1  // 通过word2insert一个字符</li><li>可能2: dp[i][j] = dp[i][j-1] +1 // 通过word1insert一个字符</li></ul></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1 == <span class="keyword">null</span> || word2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/delete-operation-for-two-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; Leetcode 583 Delete Operation for Two Strings&lt;/a&gt;&lt;br&gt;题目和经典的Edit Distance 属于同一类问题，只是允许的操作变限制为了删除操作，问需要两个单词需要最少的删除操作，能够变为相同的字符串。核心还是如何找到一个问题规模收敛的入口，从而在问题规模缩小的过程中，找到递推的规律，进而推导出表达式，再利用自顶向下或自底向上的方法去实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[72] Edit Distance</title>
    <link href="https://dpcfury.github.io/edit-distance.html/"/>
    <id>https://dpcfury.github.io/edit-distance.html/</id>
    <published>2020-04-06T01:50:05.000Z</published>
    <updated>2020-04-06T14:45:43.666Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">Leetcode 72. Edit Distance</a><br>经典的动态规划题目，求从一个字符串通过三种操作转换为另一个字符串的短编辑记录（最少的转换步骤），允许的操作包括：1. 插入；2. 删除；3. 替换。这题的核心是还是如何找一个收敛的入口，在问题规模缩小过程中，找到递推的规律，再通过自底向上或自顶向下的方式实现即可。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>给定的word1，word2，在极限情况下，假设word2位空字符串（长度为0），那么word1 转换为word2，需要进行word1.length()次删除操作。假设word1为空字符串（长度为0），需要进行word2.length（）次删除操作。这么一看，是不是有点递推边界的味道。<br>继续往下看，假设令dp[i][j] 为从word1的前i个字符转换为word2前j个字符所需的最短编辑记录，那么如何计算dp[i][j]：</p><ul><li>case1:  word1.charAt(i-1) == word2.charAt(j-1)，那么dp[i][j] = dp[i-1][j-1]</li><li>case2:  word1.charAt(i-1) != word2.charAt(j-1)：<ul><li>可能1: dp[i][j] = dp[i-1][j]+1  // 通过remove</li><li>可能2: dp[i][j] = dp[i][j-1] +1 // 通过insert或replace</li><li>可能3: dp[i][j] = dp[i-1][j-1]+1 //通过insert或replace</li></ul></li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1 == <span class="keyword">null</span> || word2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]), dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/edit-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 72. Edit Distance&lt;/a&gt;&lt;br&gt;经典的动态规划题目，求从一个字符串通过三种操作转换为另一个字符串的短编辑记录（最少的转换步骤），允许的操作包括：1. 插入；2. 删除；3. 替换。这题的核心是还是如何找一个收敛的入口，在问题规模缩小过程中，找到递推的规律，再通过自底向上或自顶向下的方式实现即可。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[46] LFU Cache</title>
    <link href="https://dpcfury.github.io/lfu-cache.html/"/>
    <id>https://dpcfury.github.io/lfu-cache.html/</id>
    <published>2020-04-05T15:53:02.000Z</published>
    <updated>2020-04-05T16:15:19.249Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/lfu-cache/" target="_blank" rel="noopener">Leetcode 46.  LFU Cache</a><br>题目要求实现计算机页面置换中经典的LFU算法，和LRU一字之别，但是含义完全不同，LFU即<br>Least Frequently Used，就是在缓存容量不够，需要置换的时候，替换策略是：将当前时间页面（key）访问次数最少的页面替换，然后将新的缓存更新。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>tip1: 考虑涉及到访问次数的统计</li><li>tip2: 题目要求在O(1)时间完成所有操作</li></ul><p>于是，首先会想到Map，将对应的key和响应的值进行映射，加快get的访问速率；此外，考虑不同访问频率的页面需要在O(1)进行找到和替换，那么需要很快找到对应的访问频率最低元素，这里设计一个<strong>{“frequency”:List<key>}</key></strong>映射。将每个访问频率的key缓存到一个优先队列（LinkedList中），新缓存的在队列尾部，时间久的在队列头部。在进行替换的过程中，首先剔除访问频率最小那个队列中，时间最久的key。<br>    在get访问中，对相应元素key进行访问频率升级，迁移到fre+1 队列中操作需要注意的是，put操作对相同key的更新，也需要进行一次get，从而更新访问频率。</p><p>实现算法如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> fre;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> fre)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.fre = fre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">         * LFUCache obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment">         * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment">         * obj.put(key,value);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> minFre; <span class="comment">// 出现的最小频率</span></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Integer, Item&gt; map; <span class="comment">//key对value索引</span></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; fre; <span class="comment">// key出现频率索引</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">            <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.fre = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 更新频率，返回值</span></span><br><span class="line">            Item item = map.get(key);</span><br><span class="line">            <span class="comment">// 找到频率列表，删除元素</span></span><br><span class="line">            LinkedList&lt;Integer&gt; oldFreList = fre.get(item.fre);</span><br><span class="line">            oldFreList.remove(Integer.valueOf(key));</span><br><span class="line">            <span class="comment">// 对应新的频率列表添加元素</span></span><br><span class="line">            LinkedList&lt;Integer&gt; newFreList = fre.computeIfAbsent(item.fre + <span class="number">1</span>, k -&gt; <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            newFreList.addLast(key);</span><br><span class="line">            item.fre++;</span><br><span class="line">            <span class="comment">//如果freq中频率为minFreq的list为空，minFreq自增1</span></span><br><span class="line">            <span class="keyword">if</span> (fre.get(minFre) == <span class="keyword">null</span> || fre.get(minFre).size() == <span class="number">0</span>) minFre++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> item.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (get(key) != -<span class="number">1</span>) <span class="comment">//更新也算访问一次</span></span><br><span class="line">                    map.get(key).val = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">                LinkedList&lt;Integer&gt; minList = fre.get(minFre);</span><br><span class="line">                <span class="keyword">int</span> k = minList.removeFirst();</span><br><span class="line">                map.remove(k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, <span class="keyword">new</span> Item(value, <span class="number">0</span>));</span><br><span class="line">            LinkedList&lt;Integer&gt; minList = fre.computeIfAbsent(<span class="number">0</span>, k -&gt; <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            minList.addLast(key);</span><br><span class="line">            minFre = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/lfu-cache/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 46.  LFU Cache&lt;/a&gt;&lt;br&gt;题目要求实现计算机页面置换中经典的LFU算法，和LRU一字之别，但是含义完全不同，LFU即&lt;br&gt;Least Frequently Used，就是在缓存容量不够，需要置换的时候，替换策略是：将当前时间页面（key）访问次数最少的页面替换，然后将新的缓存更新。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
      <category term="lfu" scheme="https://dpcfury.github.io/tags/lfu/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[42] Trapping Rain Water</title>
    <link href="https://dpcfury.github.io/trapping-rain-water.html/"/>
    <id>https://dpcfury.github.io/trapping-rain-water.html/</id>
    <published>2020-04-04T01:13:04.000Z</published>
    <updated>2020-04-04T01:21:43.136Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">Leetcode 42. Trapping Rain Water</a><br>题目给定一个整形数组，代表高低相间的柱状体，问下完雨之后，这些柱状体之间的缝隙空间能装载多少水。这里提供自己比较喜欢的一种直观解法，理解非常方便。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>从每个柱体进行考虑，这一格柱体能承载多少水，是由其左侧最高的柱体+ 右侧最高的柱体+本身的柱体高度决定，只要能计算出每个柱体能承载多少水，就能计算出总的盛水量。<br>实现方式：</p><ul><li>从左往右遍历，计算出每个柱体左边最高的柱体，记为leftMax[i]；</li><li>从右往左遍历，计算出每个柱体右侧最高的柱体，记为rightMax[i];</li><li>从迁往后遍历，计算每个柱体盛水量</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span> max1 = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            max1 = Math.max(max1, height[i]);</span><br><span class="line">            leftMax[i] = max1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max2 = height[height.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = height.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            max2 = Math.max(max2, height[j]);</span><br><span class="line">            rightMax[j] = max2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(leftMax[i], rightMax[i]);</span><br><span class="line">            <span class="keyword">if</span> (min &gt; height[i]) num += min - height[i];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/trapping-rain-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 42. Trapping Rain Water&lt;/a&gt;&lt;br&gt;题目给定一个整形数组，代表高低相间的柱状体，问下完雨之后，这些柱状体之间的缝隙空间能装载多少水。这里提供自己比较喜欢的一种直观解法，理解非常方便。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="hard" scheme="https://dpcfury.github.io/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[8]String to Integer (atoi)</title>
    <link href="https://dpcfury.github.io/string-to-integer.html/"/>
    <id>https://dpcfury.github.io/string-to-integer.html/</id>
    <published>2020-04-03T14:41:07.000Z</published>
    <updated>2020-04-03T14:46:43.988Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">Leetcode 8. String to Integer (atoi)</a><br>题目要实现一个 atoi 函数，使其能将字符串转换成整数。确切的说，这种字符的类型五花八门，有很多中形式，除了正负号的判断，还需要判断数字的合法性，数字的长度是否超越32位整数的边界等，属于细节题，不做过多的描述，比较好的方式是不用借助太多的标记为，而是分阶段进行处理，先处理空格，再处理符号，再处理数字。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> negative=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(str.length()&gt;index &amp;&amp; str.charAt(index)==<span class="string">' '</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=str.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(index)==<span class="string">'+'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(index)==<span class="string">'-'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            negative=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index&gt;=str.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Character.isDigit(str.charAt(index))==<span class="keyword">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startIndex=index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> endIndex=startIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex; i&lt;str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)&gt;=<span class="string">'0'</span> &amp;&amp; str.charAt(i)&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">                endIndex++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex; i&lt;endIndex; i++) &#123;</span><br><span class="line">            num=(num*<span class="number">10</span>)+Double.parseDouble(Character.toString(str.charAt(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> (negative)?Integer.MIN_VALUE:Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> negative?(<span class="keyword">int</span>)(-<span class="number">1</span>*num):(<span class="keyword">int</span>)num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/string-to-integer-atoi/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 8. String to Integer (atoi)&lt;/a&gt;&lt;br&gt;题目要实现一个 atoi 函数，使其能将字符串转换成整数。确切的说，这种字符的类型五花八门，有很多中形式，除了正负号的判断，还需要判断数字的合法性，数字的长度是否超越32位整数的边界等，属于细节题，不做过多的描述，比较好的方式是不用借助太多的标记为，而是分阶段进行处理，先处理空格，再处理符号，再处理数字。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>todo-list</title>
    <link href="https://dpcfury.github.io/todo-list.html/"/>
    <id>https://dpcfury.github.io/todo-list.html/</id>
    <published>2020-04-03T07:55:08.000Z</published>
    <updated>2020-04-03T08:07:01.818Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>罗列平时工作学习中需要总结的内容，可以开拓视野的内容。因为来不及实践或总结成博客，暂时记个todo，方便有时间去尝试和整理。</p></blockquote><a id="more"></a><ol><li><p>Spring Boot 微服务应用集成Prometheus + Grafana 实现监控告警(reference :<a href="https://juejin.im/post/5e27acf6e51d4557ea363a65" target="_blank" rel="noopener">https://juejin.im/post/5e27acf6e51d4557ea363a65</a>)</p></li><li><p>python 垃圾回收</p></li><li><p>问题：一次web请求，所创建对象的垃圾回收和session相关的垃圾回收，首先了解拉垃圾对象的判别（核心）</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;罗列平时工作学习中需要总结的内容，可以开拓视野的内容。因为来不及实践或总结成博客，暂时记个todo，方便有时间去尝试和整理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="todo" scheme="https://dpcfury.github.io/categories/todo/"/>
    
    
  </entry>
  
  <entry>
    <title>内存泄漏和内存溢出</title>
    <link href="https://dpcfury.github.io/memory-leak-and-memory-overflow.html/"/>
    <id>https://dpcfury.github.io/memory-leak-and-memory-overflow.html/</id>
    <published>2020-04-03T06:35:50.000Z</published>
    <updated>2020-04-03T07:35:17.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>内存泄漏（Memory Leak）</strong>指的是申请了内存，但是在后续不用的时候没有进行释放，对程序而言这块内存一直处于占用状态。<br><strong>内存溢出（Memory Overflow）</strong>：指的是申请内存时，已经没有足够的内容可供使用；或者，给定一块内存，你却操作这块内存意外的地址空间，这时候就会OOM，即所谓的内存溢出。</p></blockquote><a id="more"></a><h4 id="二者关系"><a href="#二者关系" class="headerlink" title="二者关系"></a>二者关系</h4><p>内存泄漏的堆积最终必然会导致内存溢出，内存溢出就是需要的空间超过了系统所能分配给你的最大空间，此时系统无法满足分配器请求，就会报内存溢出的错误。<br>内存泄漏更倾向于是说，你申请了空间，但是没有在不使用的情况下释放，导致系统无法将这些空间分配给其他程序，也无法被gc进行回收。</p><h4 id="内存泄漏分类"><a href="#内存泄漏分类" class="headerlink" title="内存泄漏分类"></a>内存泄漏分类</h4><ol><li><p><strong>常发性内存泄漏</strong>：造成内存泄漏的代码经常被执行到，每次执行程序都会造成对应代码段的内存泄漏。</p></li><li><p><strong>偶发性内存泄漏</strong>：造成内存泄漏的代码段很少被执行到，只有在特定的环境和条件下执行某种操作才会发生。常发性和偶发性是相对的。在特定条件下，偶发的泄漏可能演化常发性的内存泄漏，所以需要考虑泄漏发生的条件和环境。</p></li><li><p><strong>一次性内存泄漏</strong>：在整个应用程序的生命周期中，造成内存泄漏的代码段只会执行一次，可能是由于算法、程序设计、加载机制上的缺陷，导致总会发生一次内存泄漏。例如在加载阶段的初始化分配内存，但是后续类一直需要使用，因此不使用的内存一直没有被释放。</p></li><li><p><strong>隐式内存泄漏</strong>：程序在执行过程中（例如处理web用户的一次查询请求），由于程序设计问题，不停的在请求分配内存，但是直到请求处理完成才能释放内存。严格来说，这里并不能成为内存泄漏，因为程序如果能吹完成请求会释放所申请的内存。但是对于程序而言，不断申请大量的内内存，并且不及时释放（相对及时），最终还是会导致系统的内存耗尽。因此，把这种泄漏行为成为隐式内存泄漏。</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>内存泄漏多处于程序设计原因，产生内存泄漏不一定会导致系统问题，但是内存泄漏的情况频繁、泄漏的内存较大，就会导致程序内存溢出，严重的会导致机器hang住，只能重启。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;内存泄漏（Memory Leak）&lt;/strong&gt;指的是申请了内存，但是在后续不用的时候没有进行释放，对程序而言这块内存一直处于占用状态。&lt;br&gt;&lt;strong&gt;内存溢出（Memory Overflow）&lt;/strong&gt;：指的是申请内存时，已经没有足够的内容可供使用；或者，给定一块内存，你却操作这块内存意外的地址空间，这时候就会OOM，即所谓的内存溢出。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发" scheme="https://dpcfury.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="内存泄漏" scheme="https://dpcfury.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="内存溢出" scheme="https://dpcfury.github.io/tags/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Mac下安装Mysql-Python</title>
    <link href="https://dpcfury.github.io/mac-mysql-python-installation.html/"/>
    <id>https://dpcfury.github.io/mac-mysql-python-installation.html/</id>
    <published>2020-04-03T03:00:34.000Z</published>
    <updated>2020-04-03T06:35:25.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>历史原因，接受项目的运行和调试基本放在开发测试机上，买了Pycharm之后，希望能借助本地的调试功能避免在开机上测试的时间成本，但是在本地安装依赖的过程中，发现着实遇到不少的坑，这次先说说安装的Mysql-python这个库。</p></blockquote><a id="more"></a><h4 id="Mysql-python"><a href="#Mysql-python" class="headerlink" title="Mysql-python"></a>Mysql-python</h4><p>MySQL-python又叫MySQLdb，是Python连接MySQL最流行的一个驱动，很多框架都也是基于此库进行开发，遗憾的是它只支持 Python2.x，而且安装的时候有很多前置条件，因为它是基于C开发的库，这意味着，你在不同的开发测试环境，可能需要安装额外的上游依赖。</p><p>系统环境：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -V</span><br><span class="line">$ Python 2.7.10</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sw_vers</span><br><span class="line">ProductName:  Mac OS X</span><br><span class="line">ProductVersion: 10.14.6</span><br><span class="line">BuildVersion:   18G103</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>首先使用Pycharm安装失败，然后转为手动到命令行安装，可以报错信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dupengcheng@dpc-MacBook ~ pip install MySQL-python</span><br><span class="line">DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won<span class="string">'t be maintained after that date. A future version of pip will drop support for Python 2.7.</span></span><br><span class="line"><span class="string">Collecting MySQL-python</span></span><br><span class="line"><span class="string">  Downloading https://files.pythonhosted.org/packages/a5/e9/51b544da85a36a68debe7a7091f068d802fc515a3a202652828c73453cad/MySQL-python-1.2.5.zip (108kB)</span></span><br><span class="line"><span class="string">    100% |████████████████████████████████| 112kB 3.1kB/s</span></span><br><span class="line"><span class="string">    Complete output from command python setup.py egg_info:</span></span><br><span class="line"><span class="string">    sh: mysql_config: command not found</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      File "&lt;string&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">      File "/private/var/folders/8h/kmnz1jj95s9g674q6vd1bmv40000gp/T/pip-install-DNT2Pa/MySQL-python/setup.py", line 17, in &lt;module&gt;</span></span><br><span class="line"><span class="string">        metadata, options = get_config()</span></span><br><span class="line"><span class="string">      File "setup_posix.py", line 43, in get_config</span></span><br><span class="line"><span class="string">        libs = mysql_config("libs_r")</span></span><br><span class="line"><span class="string">      File "setup_posix.py", line 25, in mysql_config</span></span><br><span class="line"><span class="string">        raise EnvironmentError("%s not found" % (mysql_config.path,))</span></span><br><span class="line"><span class="string">    EnvironmentError: mysql_config not found</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ----------------------------------------</span></span><br></pre></td></tr></table></figure></p><p>和Java中不同，python的mysql连接驱动依赖了部分c库实现，推测这里的mysql_config也是某个c库提供，于是goole一波，mysql_config 在 Mac 下是由 mysql-connector-c 提供的。</p><blockquote><p>diss 一波，联动的依赖管理和坑，给开发和后续维护埋了多少坑，2.7语言即将不支持，Mysql-Python也过于老旧，这种后续在客户侧升级演进隐藏的成本极高。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install mysql <span class="comment"># 非本地数据库可以不安装</span></span><br><span class="line">$ brew install mysql-connector-c</span><br></pre></td></tr></table></figure><p>安装mysql-connector-c之后，重新pip install<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won<span class="string">'t be maintained after that date. A future version of pip will drop support for Python 2.7.</span></span><br><span class="line"><span class="string">Collecting MySQL-python</span></span><br><span class="line"><span class="string">  Using cached https://files.pythonhosted.org/packages/a5/e9/51b544da85a36a68debe7a7091f068d802fc515a3a202652828c73453cad/MySQL-python-1.2.5.zip</span></span><br><span class="line"><span class="string">    Complete output from command python setup.py egg_info:</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      File "&lt;string&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">      File "/private/var/folders/8h/kmnz1jj95s9g674q6vd1bmv40000gp/T/pip-install-bQBOWl/MySQL-python/setup.py", line 17, in &lt;module&gt;</span></span><br><span class="line"><span class="string">        metadata, options = get_config()</span></span><br><span class="line"><span class="string">      File "setup_posix.py", line 53, in get_config</span></span><br><span class="line"><span class="string">        libraries = [ dequote(i[2:]) for i in libs if i.startswith(compiler_flag("l")) ]</span></span><br><span class="line"><span class="string">      File "setup_posix.py", line 8, in dequote</span></span><br><span class="line"><span class="string">        if s[0] in "\"'</span><span class="string">" and s[0] == s[-1]:</span></span><br><span class="line"><span class="string">    IndexError: string index out of range</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ----------------------------------------</span></span><br></pre></td></tr></table></figure></p><p>修改/usr/local/Cellar/mysql-connector-c/6.1.11/bin/mysql_config<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create options</span></span><br><span class="line">113 libs=<span class="string">"-L<span class="variable">$pkglibdir</span>"</span></span><br><span class="line">114 <span class="comment"># libs="$libs -l "</span></span><br><span class="line">115 libs=<span class="string">"<span class="variable">$libs</span> -lmysqlclient -lssl -lcrypto"</span></span><br></pre></td></tr></table></figure></p><p>再次pip isstall 一次，又出了新问题，提示库缺少，命名已经安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">13 warnings generated.</span><br><span class="line">    cc -bundle -undefined dynamic_lookup -Wl,-F. build/temp.macosx-10.14-intel-2.7/_mysql.o -L/usr/<span class="built_in">local</span>/Cellar/mysql-connector-c/6.1.11/lib -lmysqlclient -lssl -lcrypto -o build/lib.macosx-10.14-intel-2.7/_mysql.so</span><br><span class="line">    ld: library not found <span class="keyword">for</span> -lssl</span><br><span class="line">    clang: error: linker <span class="built_in">command</span> failed with <span class="built_in">exit</span> code 1 (use -v to see invocation)</span><br><span class="line">    error: <span class="built_in">command</span> <span class="string">'cc'</span> failed with <span class="built_in">exit</span> status 1</span><br></pre></td></tr></table></figure></p><p>没法了，继续google解决方案，尝试添加连接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LDFLAGS=<span class="string">"-I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib"</span></span><br></pre></td></tr></table></figure></p><p>再次安装，发现权限问题,加上sudo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo env LDFLAGS=<span class="string">"-I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib"</span> pip install Mysql-python</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collecting Mysql-python</span><br><span class="line">  Downloading https://files.pythonhosted.org/packages/a5/e9/51b544da85a36a68debe7a7091f068d802fc515a3a202652828c73453cad/MySQL-python-1.2.5.zip (108kB)</span><br><span class="line">    100% |████████████████████████████████| 112kB 5.3kB/s</span><br><span class="line">Installing collected packages: Mysql-python</span><br><span class="line">  Running setup.py install <span class="keyword">for</span> Mysql-python ... <span class="keyword">done</span></span><br><span class="line">Successfully installed Mysql-python-1.2.5</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>python在平台无关性上确实不如Java，环境的依赖管理尽管有pip这样的工具，但是实际的对操作系统依赖还是无法避免，在做代码移植上确实会存在问题。此外，遇到这种老版本依赖的升级，相比也会遇到更多的坑，这个在技术规划阶段就需要考虑，用的时候一时爽，后面维护火葬场。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;历史原因，接受项目的运行和调试基本放在开发测试机上，买了Pycharm之后，希望能借助本地的调试功能避免在开机上测试的时间成本，但是在本地安装依赖的过程中，发现着实遇到不少的坑，这次先说说安装的Mysql-python这个库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="django" scheme="https://dpcfury.github.io/categories/django/"/>
    
    
      <category term="开发" scheme="https://dpcfury.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="django" scheme="https://dpcfury.github.io/tags/django/"/>
    
      <category term="python" scheme="https://dpcfury.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[289] Game of Life</title>
    <link href="https://dpcfury.github.io/leetcode-game-of-life.html/"/>
    <id>https://dpcfury.github.io/leetcode-game-of-life.html/</id>
    <published>2020-04-02T14:44:34.000Z</published>
    <updated>2020-04-02T15:45:29.786Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener">Leetcode 289. Game of Life</a><br>题目给定一个二维面板，每个格子中的细胞存活由0，1代表，给定一定的繁衍规律，希望在面板上直接更新细胞的下一次存活状态。题目特别强调的是in-place修改，以及边界控制。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由于不能使用额外的存储空间标记细胞的上一轮状态，所以想到了，有没有社么办法，先在遍历过程中，将值做一个转换，在计算每个细胞的下一个状态时，同时还能保持记录上一轮状态。此时，题目的重点就是：如何提供一种编码方式，将细胞的更新值和上一轮状态保留，后续再进行一次遍历，即获取最终的值。</p><p>分析值变化情况：</p><ul><li>0 -&gt; 1 利用101标记，上一轮状态为0，更新状态为1</li><li>1 -&gt; 0 利用10 标记，上一轮状态为1，更新状态为0</li><li>0 -&gt; 0 不变</li><li>1 -&gt; 1 不变</li></ul><p>再加上八个方向的边界控制，题目的解法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> row = board.length;</span><br><span class="line">       <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">               <span class="keyword">int</span> numOfOne = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">int</span> numOfZero = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                   <span class="keyword">int</span> curX = i + dir[<span class="number">0</span>];</span><br><span class="line">                   <span class="keyword">int</span> curY = j + dir[<span class="number">1</span>];</span><br><span class="line">                   <span class="keyword">if</span> (inArea(curX, curY, row, col)) &#123;</span><br><span class="line">                       <span class="keyword">int</span> value = board[curX][curY];</span><br><span class="line">                       <span class="keyword">if</span> (value == <span class="number">1</span> || value == <span class="number">10</span>) numOfOne++;</span><br><span class="line">                       <span class="keyword">else</span> numOfZero++;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (board[i][j] == <span class="number">0</span> &amp;&amp; numOfOne == <span class="number">3</span>) board[i][j] = <span class="number">101</span>; <span class="comment">// 0-&gt;1</span></span><br><span class="line">               <span class="keyword">if</span> (board[i][j] == <span class="number">1</span> &amp;&amp; (numOfOne &lt; <span class="number">2</span> || numOfOne &gt; <span class="number">3</span>)) board[i][j] = <span class="number">10</span>; <span class="comment">// 1-&gt;0</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">               <span class="keyword">int</span> value = board[i][j];</span><br><span class="line">               <span class="keyword">if</span> (value == <span class="number">101</span>) board[i][j] = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span> (value == <span class="number">10</span>) board[i][j] = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= row) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (y &lt; <span class="number">0</span> || y &gt;= col) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/game-of-life/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 289. Game of Life&lt;/a&gt;&lt;br&gt;题目给定一个二维面板，每个格子中的细胞存活由0，1代表，给定一定的繁衍规律，希望在面板上直接更新细胞的下一次存活状态。题目特别强调的是in-place修改，以及边界控制。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="bit" scheme="https://dpcfury.github.io/tags/bit/"/>
    
  </entry>
  
  <entry>
    <title>django 启动 libmysqlclient_r.so.16找不到</title>
    <link href="https://dpcfury.github.io/django-libmysqlclient-error.html/"/>
    <id>https://dpcfury.github.io/django-libmysqlclient-error.html/</id>
    <published>2020-04-02T05:51:29.000Z</published>
    <updated>2020-04-02T06:03:29.870Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>问题：开发环境由于yum安装的mysql版本太低，卸载后从mysql官网下载rpm进行安装，正常设置mysql之后，在启动Django时，提示libmysqlclient_r.so.16找不到。</p></blockquote><a id="more"></a><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module: libmysqlclient_r.so.16: cannot open shared object file: No such file or directory.</p></blockquote><p>在网上找了不少回答，发现都是扯的很，最后发现的问题是，在通过rpm方式安装mysql时，使用的是mysql-rpm-bundle的版本，当时只安装了mysql-client和mysql-server。</p><p>完整的安装包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- -rw-r--r--  1 root root  285470720 Mar 31 19:53 MySQL-5.6.46-1.el6.x86_64.rpm-bundle.tar</span><br><span class="line">- -rw-r--r--  1 7155 31415  35528000 Sep 29  2019 MySQL-client-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415   6191888 Sep 29  2019 MySQL-devel-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415  98136984 Sep 29  2019 MySQL-embedded-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415  80628348 Sep 29  2019 MySQL-server-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415   3722376 Sep 29  2019 MySQL-shared-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415   3969752 Sep 29  2019 MySQL-shared-compat-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">- -rw-r--r--  1 7155 31415  57279436 Sep 29  2019 MySQL-test-5.6.46-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>缺少libmysqlclient_r.so.16是因为MySQL-shared-compat-5.6.46-1.el6.x86_64.rpm没有安装，直接安装即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh MySQL-shared-compat-5.6.46-1.el6.x86_64.rpm</span><br><span class="line">warning: MySQL-shared-compat-5.6.46-1.el6.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing...                <span class="comment">########################################### [100%]</span></span><br><span class="line">   1:MySQL-shared-compat    <span class="comment">########################################### [100%]</span></span><br><span class="line"></span><br><span class="line">[root@dpctest upload]<span class="comment"># find / -name libmysqlclient_r.so.16</span></span><br><span class="line">/usr/lib64/libmysqlclient_r.so.16</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;问题：开发环境由于yum安装的mysql版本太低，卸载后从mysql官网下载rpm进行安装，正常设置mysql之后，在启动Django时，提示libmysqlclient_r.so.16找不到。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="django" scheme="https://dpcfury.github.io/categories/django/"/>
    
    
      <category term="开发" scheme="https://dpcfury.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="django" scheme="https://dpcfury.github.io/tags/django/"/>
    
      <category term="mysql" scheme="https://dpcfury.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[1111] Maximum Nesting Depth of Two Valid Parentheses Strings</title>
    <link href="https://dpcfury.github.io/Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings.html/"/>
    <id>https://dpcfury.github.io/Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings.html/</id>
    <published>2020-04-01T15:18:21.000Z</published>
    <updated>2020-04-01T15:59:09.464Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/" target="_blank" rel="noopener">Leetcode 1111. Maximum Nesting Depth of Two Valid Parentheses Strings</a><br>题目的描述很长，但是表达的意思我理解就是，怎么均分一下A B两个子括号，这边借用的是交替均分‘（’的方法，这题有点偏trick，👎的比例相对较高，不做过多细节描述。</p></blockquote><a id="more"></a><h4 id="方法一：用栈进行括号匹配"><a href="#方法一：用栈进行括号匹配" class="headerlink" title="方法一：用栈进行括号匹配"></a>方法一：用栈进行括号匹配</h4><p>思路及算法</p><p>要求划分出使得最大嵌套深度最小的分组，我们首先得知道如何计算嵌套深度。我们可以通过栈实现括号匹配来计算：</p><p>维护一个栈 s，从左至右遍历括号字符串中的每一个字符：</p><ul><li><p>如果当前字符是 (，就把 ( 压入栈中，此时这个 ( 的嵌套深度为栈的高度；</p></li><li><p>如果当前字符是 )，此时这个 ) 的嵌套深度为栈的高度，随后再从栈中弹出一个 (。</p></li></ul><p>下面给出了括号序列 (()(())()) 在每一个字符处的嵌套深度：</p><blockquote><p>括号序列   ( ( ) ( ( ) ) ( ) )<br>下标编号   0 1 2 3 4 5 6 7 8 9<br>嵌套深度   1 2 2 2 3 3 2 2 2 1 </p></blockquote><p>知道如何计算嵌套深度，问题就很简单了：只要在遍历过程中，我们保证栈内一半的括号属于序列 A，一半的括号属于序列 B，那么就能保证拆分后最大的嵌套深度最小，是当前最大嵌套深度的一半。要实现这样的对半分配，我们只需要把奇数层的 ( 分配给 A，偶数层的 ( 分配给 B 即可。对于上面的例子，我们将嵌套深度为 1 和 3 的所有括号 (()) 分配给 A，嵌套深度为 2 的所有括号 ()()() 分配给 B。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxDepthAfterSplit(String seq) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[seq.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, depth = <span class="number">0</span>; i &lt; seq.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                res[i] = depth++ &amp; <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = --depth &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：找规律"><a href="#方法二：找规律" class="headerlink" title="方法二：找规律"></a>方法二：找规律</h4><p>思路及算法</p><p>我们还是使用上面的例子 (()(())())，但这里我们把 ( 和 ) 的嵌套深度分成两行：</p><blockquote><p>括号序列   ( ( ) ( ( ) ) ( ) )<br>下标编号   0 1 2 3 4 5 6 7 8 9<br>嵌套深度   1 2 - 2 3 - - 2 - -<br>嵌套深度   - - 2 - - 3 2 - 2 1<br>有没有发现什么规律？</p></blockquote><ul><li><p>左括号 ( 的下标编号与嵌套深度的奇偶性相反，也就是说：</p><ul><li><p>下标编号为奇数的 (，其嵌套深度为偶数，分配给 B；</p></li><li><p>下标编号为偶数的 (，其嵌套深度为奇数，分配给 A。</p></li><li><p>右括号 ) 的下标编号与嵌套深度的奇偶性相同，也就是说：</p></li></ul></li><li><p>下标编号为奇数的 )，其嵌套深度为奇数，分配给 A；</p><ul><li><p>下标编号为偶数的 )，其嵌套深度为偶数，分配给 B。</p></li><li><p>这样以来，我们只需要根据每个位置是哪一种括号以及该位置的下标编号，就能确定将对应的对应的括号分到哪个组了。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 1111. Maximum Nesting Depth of Two Valid Parentheses Strings&lt;/a&gt;&lt;br&gt;题目的描述很长，但是表达的意思我理解就是，怎么均分一下A B两个子括号，这边借用的是交替均分‘（’的方法，这题有点偏trick，👎的比例相对较高，不做过多细节描述。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="trick" scheme="https://dpcfury.github.io/tags/trick/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode[322] Coin Change</title>
    <link href="https://dpcfury.github.io/leetcode-coin-change.html/"/>
    <id>https://dpcfury.github.io/leetcode-coin-change.html/</id>
    <published>2020-04-01T15:06:32.000Z</published>
    <updated>2020-04-01T15:16:22.315Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">Leetcode 322. Coin Change</a><br>经典的找零问题，遇到此类问题，首先分析是否可以缩小amount的规模，来找到子问题（最优子结构），然后自顶向下分析，推导出递归表达式，再写出对应的自顶向下或者自底向上代码。</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>令F(amount) 为拼凑amount需要的最少硬币数量，那么F(amount) = min(F(amout-coin[i]))中来的，得到这样的一个递归后，就可将问题一步步拆解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i &amp;&amp; dp[i - coins[j]] != -<span class="number">1</span>)<span class="comment">//之前能满足</span></span><br><span class="line">                    min = Math.min(dp[i - coins[j]] + <span class="number">1</span>, min);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = min == Integer.MAX_VALUE ? -<span class="number">1</span> : min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/coin-change/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 322. Coin Change&lt;/a&gt;&lt;br&gt;经典的找零问题，遇到此类问题，首先分析是否可以缩小amount的规模，来找到子问题（最优子结构），然后自顶向下分析，推导出递归表达式，再写出对应的自顶向下或者自底向上代码。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="medium" scheme="https://dpcfury.github.io/tags/medium/"/>
    
      <category term="dynamic programming" scheme="https://dpcfury.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot统一异常处理实践</title>
    <link href="https://dpcfury.github.io/spring-boot-exception-handling.html/"/>
    <id>https://dpcfury.github.io/spring-boot-exception-handling.html/</id>
    <published>2020-04-01T11:14:57.000Z</published>
    <updated>2020-04-01T12:09:55.870Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在web开发中，经常需要处理各类异常情况，这种处理逻辑经常会被分散在代码的各个层次，导致异常的处理和业务逻辑混杂，后续重构代价升高，前后端交互成本提高，不利用系统的持续演进。本文针对工作中遇到的不良实践进行总结，试图找寻一种可以解决大部分问题的工程实践方案。</p></blockquote><a id="more"></a><h4 id="核心关注点"><a href="#核心关注点" class="headerlink" title="核心关注点"></a>核心关注点</h4><p>对异常的处理，总结先来，主要有三个核心的关注点：</p><ul><li>在什么时候，什么地方捕获异常（try-catch），什么时候需要抛出（throws）异常</li><li>在DAO、Service还是在Controller层次进行捕获</li><li>抛出一场后，如何处理，如何向前端返回错误</li></ul><h4 id="工作中遇到的反例"><a href="#工作中遇到的反例" class="headerlink" title="工作中遇到的反例"></a>工作中遇到的反例</h4><p>以个人在工作中接触的一个django项目为例，其业务逻辑都集中在view.py文件中，通过装饰器，将返回内容统一转换为json形式进行返回，系统在异常处理存在的问题集中体现在：</p><ul><li>分散在业务各处的返回信息处理</li><li>满大街的try-catch，可能一层套一层</li><li>混乱的返回方式</li></ul><p>后端和前端约定返回结果形式：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message"</span>:<span class="string">"ok"</span>,</span><br><span class="line">    <span class="attr">"data"</span>:[],</span><br><span class="line">    <span class="attr">"success"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>分散的返回处理</strong><br>即返回结果的处理没有统一的入口，可能分散在代码的多个层次中，导致返回信息的组织和业务逻辑交织在一起，代码逻辑非常不清晰，其次，会导致返回信息不对的情况下，排查人力投入明显增加。经常看到返回的结果message对应的从约定的”ok”变成了其他的词，”success”也出现五花八门的返回结果。</p><p><strong>满大街的try-catch</strong><br>在代码的不同层次，你都能找到活多或少的try-cath处理段，过多的try-catch 导致业务代码分割严重，也增加了对应处理逻辑，导致系统的复杂度上升，后续维护重构举步维艰。</p><p><strong>混乱的返回方式</strong><br>在spring-mvc中，返回统一在controller层次，第一层的函数就负责了结果的返回，但是接触到的django项目，它的返回逻辑甚至能在入口跳转6次的函数中，没有统一的处理入口，出了问题需要到处排查，前后端要一起折腾。</p><p><strong>总结</strong><br>当前项目的异常处理方式非常失败，处于xx原因，就不好列举代码了。</p><h4 id="异常处理规范"><a href="#异常处理规范" class="headerlink" title="异常处理规范"></a>异常处理规范</h4><p>为了进行统一的异常处理，一般会约定异常处理规范，这里不仅仅是将结果形式定义了就完事了，还得通过前后端各种工程实践将这个规范践行下去。</p><h4 id="原则一：-不捕获任何异常"><a href="#原则一：-不捕获任何异常" class="headerlink" title="原则一： 不捕获任何异常"></a>原则一： 不捕获任何异常</h4><p>根据大佬们的实践经验，不再对与业务逻辑和数据处理中的异常进行捕获，即将DAO、Service、Controller中所有的异常全部抛出到上层，从而不眠代码中一堆的try-catch，减少维护的难度。</p><h4 id="原则二：统一返回结果集"><a href="#原则二：统一返回结果集" class="headerlink" title="原则二：统一返回结果集"></a>原则二：统一返回结果集</h4><p>这个原则很多开发实践都已经明确，就是按照统一的一个格式进行结果返回，返回结果中应该起码包含请求的处理状态标志，此外用一层数组包装查询的结果。</p><p>而在spring-boot(mvc)架构中，通常会定义一个Java的DTO对象，用来进行统一的结果返回，for example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code; <span class="comment">// 统一协商的状态码</span></span><br><span class="line">    <span class="keyword">private</span> String message; <span class="comment">// 携带的额外提示信息</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;T&gt; data; <span class="comment">// 请求返回的数据集</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ResultBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultBean <span class="title">error</span><span class="params">(<span class="keyword">int</span> code, String message)</span> </span>&#123;</span><br><span class="line">        ResultBean resultBean = <span class="keyword">new</span> ResultBean();</span><br><span class="line">        resultBean.setCode(code);</span><br><span class="line">        resultBean.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> resultBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultBean <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ResultBean resultBean = <span class="keyword">new</span> ResultBean();</span><br><span class="line">        resultBean.setCode(<span class="number">0</span>);</span><br><span class="line">        resultBean.setMessage(<span class="string">"success"</span>);</span><br><span class="line">        <span class="keyword">return</span> resultBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function">ResultBean&lt;V&gt; <span class="title">success</span><span class="params">(Collection&lt;V&gt; data)</span> </span>&#123;</span><br><span class="line">        ResultBean resultBean = <span class="keyword">new</span> ResultBean();</span><br><span class="line">        resultBean.setCode(<span class="number">0</span>);</span><br><span class="line">        resultBean.setMessage(<span class="string">"success"</span>);</span><br><span class="line">        resultBean.setData(data);</span><br><span class="line">        <span class="keyword">return</span> resultBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter / setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而，在成功的情况下，只需要返回ResultBean.success() 或 ResultBean.success(Collection<v> data)需要返回数据按照下面的形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/host/add"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultBean&lt;Goods&gt; <span class="title">getAllHosts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Host&gt; hosts = hostService.findAll();</span><br><span class="line">    <span class="keyword">return</span> ResultBean.success(hosts);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/host/update"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultBean <span class="title">updatehosts</span><span class="params">(Host hosts)</span> </span>&#123;</span><br><span class="line">    hostsService.update(host);</span><br><span class="line">    <span class="keyword">return</span> ResultBean.success();</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></v></p><p>只有查询方法需要调用 ResultBean.success(Collection<v> data) 来返回 N 条数据, 删除, 修改等方法都应该调用 ResultBean.success(), 即在业务代码中只处理正确的功能, 不对异常做任何判断. 也不需要对 update 或 delete 的更新条数做判断. 只要没有抛出异常, 就等价于用户请求处理成功，再加足够的日志即可，且操作成功的提示信息在前端处理, 不要后台返回 “操作成功” 等字段，这种设计在国际化的时候能减轻不少的工作量。</v></p><p>前台接受的json for example：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"success"</span>,</span><br><span class="line">    <span class="string">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"sn"</span>: <span class="string">"xxxx"</span>,</span><br><span class="line">            <span class="string">"hostname"</span>: <span class="string">"xxxxx"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"sn"</span>: <span class="string">"xxxx"</span>,</span><br><span class="line">            <span class="string">"hostname"</span>: <span class="string">"xxxx"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在后端报错情况下，在后端统一调用ResultBean.error(int code, String message), 来将状态码和错误信息返回, 我们约定 code 为 0 表示操作成功, 1 标示系统错误， 2标示 参数错误（协商解决）</li></ul><p>前台收到错误结果后，只要根据对应的错误code进行相应的提示信息弹出即可。</p><h4 id="后端统一异常处理"><a href="#后端统一异常处理" class="headerlink" title="后端统一异常处理"></a>后端统一异常处理</h4><p>这里是最重点的地方，spring-boot（mvc）开发的web应用中，如何进行统一的异常处理呢，spring利用AOP，提供了一种@Advice的处理方式，我们所有的异常只要能保证抛出到controller层次， 就能由统一的Advice进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(RequestExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultBean <span class="title">unknownSn</span><span class="params">(UnknownSntException e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"机器sn不存在"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(<span class="number">1</span>, <span class="string">"sn不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultBean <span class="title">incorrectMac</span><span class="params">(IncorrectMacException e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"mac地址不对"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(-<span class="number">2</span>, <span class="string">"mac地址错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultBean <span class="title">unknownException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"内部错误"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(-<span class="number">99</span>, <span class="string">"系统出现错误，联系管理员处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>不要满大街的try-catch</li><li>统一返回值，集中异常的处理逻辑</li><li>认真对待写的代码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在web开发中，经常需要处理各类异常情况，这种处理逻辑经常会被分散在代码的各个层次，导致异常的处理和业务逻辑混杂，后续重构代价升高，前后端交互成本提高，不利用系统的持续演进。本文针对工作中遇到的不良实践进行总结，试图找寻一种可以解决大部分问题的工程实践方案。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发" scheme="https://dpcfury.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
      <category term="spring-boot" scheme="https://dpcfury.github.io/categories/%E5%BC%80%E5%8F%91/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="https://dpcfury.github.io/tags/spring-boot/"/>
    
      <category term="工程实践" scheme="https://dpcfury.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://dpcfury.github.io/sorting.html/"/>
    <id>https://dpcfury.github.io/sorting.html/</id>
    <published>2020-03-31T14:11:02.000Z</published>
    <updated>2020-03-31T15:54:32.613Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>十大排序算法可以说是每个程序员都必须得掌握的了，为了方便个人复习和总结，把它整理成一篇独立文章，每种算法会有简单的算法思想描述，为了方便大家理解，从网上搜集了动图演示。</p></blockquote><a id="more"></a><ul><li>选择排序</li><li>插入排序</li><li>冒泡排序</li><li>非优化版本</li><li>优化版本</li><li>希尔排序</li><li>归并排序</li><li>递归式归并排序</li><li>非递归式归并排序</li><li>快速排序</li><li>堆排序</li><li>基数排序</li><li>非优化版本</li><li>优化版本</li><li>桶排序</li><li>基数排序</li></ul><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>过程简单描述：</strong> 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为选择排序。</p><p><img src="https://pic1.zhimg.com/v2-f20b8898585b3ca03843d93ce2c35a68_b.gif" alt="选择排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[min]) min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[min];</span><br><span class="line">            nums[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="https://zhuanlan.zhihu.com/p/57088609" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57088609</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;十大排序算法可以说是每个程序员都必须得掌握的了，为了方便个人复习和总结，把它整理成一篇独立文章，每种算法会有简单的算法思想描述，为了方便大家理解，从网上搜集了动图演示。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://dpcfury.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://dpcfury.github.io/tags/leetcode/"/>
    
      <category term="sorting" scheme="https://dpcfury.github.io/tags/sorting/"/>
    
  </entry>
  
</feed>
