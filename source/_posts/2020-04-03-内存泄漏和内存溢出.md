---
title: 内存泄漏和内存溢出
date: 2020-04-03 14:35:50
urlname: memory-leak-and-memory-overflow
categories:
- 开发
tags:
- 内存泄漏
- 内存溢出
---
>**内存泄漏（Memory Leak）**指的是申请了内存，但是在后续不用的时候没有进行释放，对程序而言这块内存一直处于占用状态。
**内存溢出（Memory Overflow）**：指的是申请内存时，已经没有足够的内容可供使用；或者，给定一块内存，你却操作这块内存意外的地址空间，这时候就会OOM，即所谓的内存溢出。

<!-- more-->


#### 二者关系
内存泄漏的堆积最终必然会导致内存溢出，内存溢出就是需要的空间超过了系统所能分配给你的最大空间，此时系统无法满足分配器请求，就会报内存溢出的错误。
内存泄漏更倾向于是说，你申请了空间，但是没有在不使用的情况下释放，导致系统无法将这些空间分配给其他程序，也无法被gc进行回收。

#### 内存泄漏分类
1. **常发性内存泄漏**：造成内存泄漏的代码经常被执行到，每次执行程序都会造成对应代码段的内存泄漏。

2. **偶发性内存泄漏**：造成内存泄漏的代码段很少被执行到，只有在特定的环境和条件下执行某种操作才会发生。常发性和偶发性是相对的。在特定条件下，偶发的泄漏可能演化常发性的内存泄漏，所以需要考虑泄漏发生的条件和环境。

3. **一次性内存泄漏**：在整个应用程序的生命周期中，造成内存泄漏的代码段只会执行一次，可能是由于算法、程序设计、加载机制上的缺陷，导致总会发生一次内存泄漏。例如在加载阶段的初始化分配内存，但是后续类一直需要使用，因此不使用的内存一直没有被释放。

4. **隐式内存泄漏**：程序在执行过程中（例如处理web用户的一次查询请求），由于程序设计问题，不停的在请求分配内存，但是直到请求处理完成才能释放内存。严格来说，这里并不能成为内存泄漏，因为程序如果能吹完成请求会释放所申请的内存。但是对于程序而言，不断申请大量的内内存，并且不及时释放（相对及时），最终还是会导致系统的内存耗尽。因此，把这种泄漏行为成为隐式内存泄漏。

#### 总结
内存泄漏多处于程序设计原因，产生内存泄漏不一定会导致系统问题，但是内存泄漏的情况频繁、泄漏的内存较大，就会导致程序内存溢出，严重的会导致机器hang住，只能重启。


