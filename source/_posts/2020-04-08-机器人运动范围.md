---
title: 机器人运动范围
date: 2020-04-08 22:24:39
urlname: robot-move-range
categories:
- leetcode
tags:
- leetcode
- BFS
- medium
---
>[力扣中国 面试题13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)
题目：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。请问该机器人能够到达多少个格子？

<!--more-->

#### 思路
题目给出的描述和经常遇到的二维矩阵题非常类似，再加上题目限定的1 <= n,m <= 100，基本可以判断这题可以用BFS或者DFS来进行遍历搜索问题的解。需要注意的是注意边界，以及如何求一个整数的数位和。

#### 算法实现
```java
static class Point {
        int x;
        int y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    public int movingCount(int m, int n, int k) {
        if (m <= 0 || n <= 0) return 0;
        int[][] direction = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
        boolean[][] visited = new boolean[m][n];
        Queue<Point> queue = new LinkedList<>();

        queue.offer(new Point(0, 0));
        int sum = 0;

        while (!queue.isEmpty()) {
            Point p = queue.poll();
            if (inArea(m, n, p.x, p.y) && !visited[p.x][p.y] &&
                    sumOfDigits(p.x) + sumOfDigits(p.y) <= k) {
                visited[p.x][p.y] = true;
                for (int[] dir : direction) {
                    int curX = p.x + dir[0];
                    int curY = p.y + dir[1];
                    queue.offer(new Point(curX, curY));
                }
                sum++;
            }
        }
        return sum;
    }

    private int sumOfDigits(int x) {
        int sum = 0;
        while (x != 0) {
            sum += x % 10;
            x = x / 10;
        }
        return sum;
    }

    private boolean inArea(int row, int col, int i, int j) {
        if (i < 0 || i >= row) return false;
        return j >= 0 && j < col;
    }
```

#### 第二种解法dp
计算整个平面，那些点能够走到，每个点只能从上或从左边走到，并且本身的数位和小于等于K
```java
public int movingCount(int m, int n, int k) {
        if (m <= 0 || n <= 0) return 0;
        boolean[][] visited = new boolean[m][n];
        visited[0][0] = true;
        int ans = 1;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j == 0 || sumOfDigits(i) + sumOfDigits(j) > k) continue;
                if (i - 1 >= 0) visited[i][j] |= visited[i - 1][j];
                if (j - 1 >= 0) visited[i][j] |= visited[i][j - 1];
                if (visited[i][j]) ans++;
            }
        }

        return ans;
    }

    private int sumOfDigits(int x) {
        int sum = 0;
        while (x != 0) {
            sum += x % 10;
            x = x / 10;
        }
        return sum;
    }
```