---
title: Leetcode[46] LFU Cache
date: 2020-04-05 23:53:02
urlname: lfu-cache
categories:
- leetcode
tags:
- leetcode
- hard
- lfu
---

>[Leetcode 46.  LFU Cache](https://leetcode.com/problems/lfu-cache/)
题目要求实现计算机页面置换中经典的LFU算法，和LRU一字之别，但是含义完全不同，LFU即
Least Frequently Used，就是在缓存容量不够，需要置换的时候，替换策略是：将当前时间页面（key）访问次数最少的页面替换，然后将新的缓存更新。

<!-- more-->

#### 思路
- tip1: 考虑涉及到访问次数的统计
- tip2: 题目要求在O(1)时间完成所有操作

于是，首先会想到Map，将对应的key和响应的值进行映射，加快get的访问速率；此外，考虑不同访问频率的页面需要在O(1)进行找到和替换，那么需要很快找到对应的访问频率最低元素，这里设计一个**{"frequency":List<key>}**映射。将每个访问频率的key缓存到一个优先队列（LinkedList中），新缓存的在队列尾部，时间久的在队列头部。在进行替换的过程中，首先剔除访问频率最小那个队列中，时间最久的key。
    在get访问中，对相应元素key进行访问频率升级，迁移到fre+1 队列中操作需要注意的是，put操作对相同key的更新，也需要进行一次get，从而更新访问频率。


实现算法如下，
```java
class LFUCache {
    
    static class Item {
        int val;
        int fre;

        public Item(int val, int fre) {
            this.val = val;
            this.fre = fre;
        }

    }

        /**
         * Your LFUCache object will be instantiated and called as such:
         * LFUCache obj = new LFUCache(capacity);
         * int param_1 = obj.get(key);
         * obj.put(key,value);
         */

        private int capacity;
        private int minFre; // 出现的最小频率
        private HashMap<Integer, Item> map; //key对value索引
        private HashMap<Integer, LinkedList<Integer>> fre; // key出现频率索引

        public LFUCache(int capacity) {
            this.capacity = capacity;
            this.map = new HashMap<>();
            this.fre = new HashMap<>();
        }

        public int get(int key) {
            if (!map.containsKey(key)) return -1;
            // 更新频率，返回值
            Item item = map.get(key);
            // 找到频率列表，删除元素
            LinkedList<Integer> oldFreList = fre.get(item.fre);
            oldFreList.remove(Integer.valueOf(key));
            // 对应新的频率列表添加元素
            LinkedList<Integer> newFreList = fre.computeIfAbsent(item.fre + 1, k -> new LinkedList<>());
            newFreList.addLast(key);
            item.fre++;
            //如果freq中频率为minFreq的list为空，minFreq自增1
            if (fre.get(minFre) == null || fre.get(minFre).size() == 0) minFre++;

            return item.val;
        }

        public void put(int key, int value) {
             if (capacity <= 0) return;
            if (map.containsKey(key)) {
                if (get(key) != -1) //更新也算访问一次
                    map.get(key).val = value;
                return;
            }

            if (map.size() == capacity) {
                LinkedList<Integer> minList = fre.get(minFre);
                int k = minList.removeFirst();
                map.remove(k);
            }
            map.put(key, new Item(value, 0));
            LinkedList<Integer> minList = fre.computeIfAbsent(0, k -> new LinkedList<>());
            minList.addLast(key);
            minFre = 0;
        }


    }
```