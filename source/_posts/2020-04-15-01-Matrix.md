---
title: Leetcode[542] 01 Matrix
date: 2020-04-15 21:58:01
urlname: 01-matrix
categories:
- leetcode
tags:
- leetcode
- dynamic programming
- matrix
---
>[Leetcode 542. 01 Matrix](https://leetcode.com/problems/01-matrix/)
题目给定一个‘0’和‘1’元素组成的矩阵，要求计算每个元素到最近的‘0’元素的距离。看到矩阵以及距离的问题，很容易想到动态规划，这题只要我们找到切入点，就能列出dp表达式，再注意下边界条件即可。

<!--more-->
#### 思路
- 令dp[i][j]表示matrix[i][j]离‘0’元素的最近距离：
    - 情况一： matrix[i][j] == 0: dp[i][j]= 0
    - 情况二：matrix[i][j] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1],dp[i+1][j],dp[i][j+1])
- 那么怎么自低向上计算dp[i][j]呢，我们可以分别进行两次遍历，一次从左往右，从上往下，一次从下往上，从右往左，再进行比较即可得到最终结果。


#### 算法实现
```java
public int[][] updateMatrix(int[][] matrix) {
        if (matrix == null) return null;
        int row = matrix.length;
        int col = matrix[0].length;
        int[][] dp = new int[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                dp[i][j] = Integer.MAX_VALUE;
                if (matrix[i][j] == 0) dp[i][j] = 0;
                else {
                    if (inArea(i - 1, j, row, col) && dp[i - 1][j] != Integer.MAX_VALUE) {
                        dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + 1);
                    }
                    if (inArea(i, j - 1, row, col) && dp[i][j - 1] != Integer.MAX_VALUE) {
                        dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1);
                    }
                }
            }
        }

        for (int i = row - 1; i >= 0; i--) {
            for (int j = col - 1; j >= 0; j--) {
                if (inArea(i, j + 1, row, col) && dp[i][j + 1] != Integer.MAX_VALUE) {
                    dp[i][j] = Math.min(dp[i][j], dp[i][j + 1] + 1);
                }
                if (inArea(i + 1, j, row, col) && dp[i + 1][j] != Integer.MAX_VALUE) {
                    dp[i][j] = Math.min(dp[i][j], dp[i + 1][j] + 1);
                }
            }
        }

        return dp;
    }

    private boolean inArea(int i, int j, int row, int col) {
        return i >= 0 && i < row && j >= 0 && j < col;
    }
```