---
title: Leetcode笔记
urlname: Leetcode
date: 2019-01-07 21:59:51
tags: 刷题笔记
---

>参考[cspiration](https://cspiration.com/%EF%BC%89)制作的Leetcode前400题[分类顺序](https://cspiration.com/leetcodeClassification/#10301)，将之前看过刷过的题整理成笔记，分类其实因人而异
>

<!--more-->

### Array

---

#### [27. Remove Element](https://leetcode.com/problems/remove-element/)

```java
public int removeElement(int[] nums, int val) {
        int i = 0;
        int j ;
        if (nums.length < 1)
            return nums.length;
        for (; i < nums.length; i++) {
            if (nums[i] == val) {
                for (j=i+1; j < nums.length; j++)
                    if (nums[j] != val)
                        break;

                if (j < nums.length){
                    int temp = nums[i];
                    nums[i] = nums[j];
                    nums[j] = temp;
                }else
                    break;
            }
        }
        return i;
    }
```



---

####  [26 .Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)

```java
public int removeDuplicates(int[] nums) {
        int p1 = 0;
        int p2 = p1 + 1;
        int end = nums.length - 1;
        while (p1 < end) {
            if (nums[p1] == nums[p2]) {
                for (int i = p2; i < end; i++)
                    nums[i] = nums[i + 1];
                end -= 1;
            } else {
                p1++;
                p2++;
            }
        }
        return end + 1;
    }
```



---

#### [80. Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)

```java
public int removeDuplicates(int[] nums) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int p = l + 2;
            if (p <= r && nums[l] == nums[p]) {
                int start = p;
                while (p <= r && nums[p] == nums[l]) {
                    p++;
                }
                int gap = p - start;
                for (; start + gap <= r; start++) nums[start] = nums[start + gap];
                r -= gap;
            } else {
                l++;
            }

        }
        return r + 1;
    }
```



---

#### [189. Rotate Array](https://leetcode.com/problems/rotate-array/)

```java
 public void rotate(int[] nums, int k) {
        k = k % nums.length;
        for (int i = 0; i < k; i++) {
            int n = nums[nums.length - 1];
            for (int j = nums.length - 1; j >= 1; j--) {
                nums[j] = nums[j - 1];
            }
            nums[0] = n;
        }
    }
```



---

#### [41. First Missing Positive](https://leetcode.com/problems/first-missing-positive/)

```java
public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for(int i=0;i<n ;i++){
            while(nums[i]>0 && nums[i]<=n && nums[nums[i]-1] != nums[i])
                swap(nums,i,nums[i]-1);
        }
        
        for(int i=0;i<n;i++){
            if(nums[i] != i+1 ) return i+1;
        }
        
        return n+1;
    }
    
    private void swap(int[] nums, int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;               
    }
```



---

#### [299. Bulls and Cows](https://leetcode.com/problems/bulls-and-cows/)

```java
public String getHint(String secret, String guess) {
        int len = secret.length();
        int bull=0,cow=0;
        int[] s = new int[10];
        int[] g = new int[10];
        for(int i=0;i<len;i++){
            char c1 = secret.charAt(i);
            char c2 = guess.charAt(i);
            if(c1 == c2) bull++;
            else{
                s[c1-'0']++;
                g[c2-'0']++;
            }
        }
        
        for(int i=0;i < 10 ;i++){
            cow += Math.min(s[i] , g[i]);
        }
        
        return bull + "A" + cow + "B";
    }
```



---

#### [134. Gas Station](https://leetcode.com/problems/gas-station/)

```java
public int canCompleteCircuit(int[] gas, int[] cost) {
        int total = 0, start = 0;
        int sum = 0;
        for (int i = 0; i < gas.length; i++) {
            int remain = gas[i] - cost[i];
            if (sum >= 0) {
                sum += remain;
            } else {
                sum = remain;
                start = i;
            }
            total += remain;
        }

        if (total >= 0){
            return start;
        }else{
            return -1;
        }
    }
```



---

#### [118. Pascal's Triangle](https://leetcode.com/problems/pascals-triangle/)

```java
public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<>(numRows);
        for (int i = 0; i < numRows; i++) {
            int[] list = new int[i + 1];
            if (i != 0) {
                List<Integer> above = res.get(i - 1);
                for (int j = 1; j < i; j++) {
                    list[j] = above.get(j - 1) + above.get(j);
                }
            }
            list[0] = 1;
            list[i] = 1;

            List<Integer> tmp = new ArrayList<>(i + 1);
            for (int i1 : list) {
                tmp.add(i1);
            }
            res.add(i, tmp);

        }
        return res;
    }
```



---

#### [119. Pascal's Triangle II](https://leetcode.com/problems/pascals-triangle-ii/)

```java
public List<Integer> getRow(int rowIndex) {
        List<Integer> res = new ArrayList<>(rowIndex);
        for (int i = 0; i <= rowIndex; i++) {
            res.add(0, 1);

            for (int j = 1; j < i; j++) {
                res.set(j, res.get(j) + res.get(j + 1));
            }
        }

        return res;
    }
```



---

#### [169. Majority Element](https://leetcode.com/problems/majority-element/)

```java
public int majorityElement(int[] nums) {
        int res =0,count =0;
        
        for(int i=0;i<nums.length;i++){
            if(count == 0) {
                res = nums[i];
                count =1;
            }else if(nums[i] == res){
                count++;
            }else
                count--;
        }
        
        return res;
    }
```



---

#### [229. Majority Element II](https://leetcode.com/problems/majority-element-ii/)

```java
public List<Integer> majorityElement(int[] nums) {
        List<Integer> res = new ArrayList<>();
        if (nums.length == 0) return res;
        int c1 = 0, c2 = 0, n1 = 0, n2 = 0;
        for (int i = 0; i < nums.length; i++) {
            if (n1 == nums[i]) {
                c1++;
            } else if (n2 == nums[i]) {
                c2++;
            } else if (c1 != 0 && c2 != 0) {
                c1--;
                c2--;
            } else {
                if (c1 == 0) {
                    n1 = nums[i];
                    c1 = 1;
                } else {
                    n2 = nums[i];
                    c2 = 1;
                }
            }
        }

        c1 = 0;
        c2 = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == n1) c1++;
            else if (nums[i] == n2) c2++;
        }
        if (c1 > nums.length / 3) res.add(n1);
        if (c2 > nums.length / 3) res.add(n2);

        return res;
    }
```



---

#### [274. H-Index](https://leetcode.com/problems/h-index/)

```java
public int hIndex(int[] citations) {
        int n = citations.length;
        int[] bucket = new int[n + 1];
        for (int c : citations) {
            if (c >= n) {
                bucket[n]++;
            } else {
                bucket[c]++;
            }
        }

        int count = 0;
        for (int i = n; i >= 0; i--) {
            count += bucket[i];
            if (count >= i) return i;
        }

        return 0;
    }
```



---

#### [275. H-Index II](https://leetcode.com/problems/h-index-ii/)

```java
public int hIndex(int[] citations) {
        int left = 0, right = citations.length - 1;
        int len = citations.length;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (citations[mid] == len - mid) return citations[mid];
            else if (citations[mid] > len - mid) right = mid - 1;
            else left = mid + 1;
        }
        return len - left;
    }
```



---

#### [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)

```java
public boolean containsDuplicate(int[] nums) {
        boolean result = false;
        HashMap<Integer,Integer> index  =new HashMap<>();
        for (Integer i :nums) {
            if(index.containsKey(i)){
                result= true;
                break;
            }else
                index.put(i,1);
        }
        return result;
    }
```



---

#### [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/)

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
        boolean result = false;
        HashMap<Integer, Integer> index = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if(index.containsKey(nums[i])){
                if(i-index.get(nums[i]) <=k ){
                    result=true;
                    break;
                }
                else
                    index.put(nums[i],i);//跟新最近的一个坐标

            }else
                index.put(nums[i],i);

        }
        return result;
    }
```



---

#### [220. Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/)

```java
public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        if (k < 1 || t < 0) return false;
        TreeSet<Integer> set = new TreeSet<>();
        for (int i = 0; i < nums.length; i++) {
            int n = nums[i];
            if (set.ceiling(n) != null && set.ceiling(n) <= t + n || set.floor(n) != null && n <= t + set.floor(n))
                return true;
            set.add(n);
            if (i >= k) set.remove(nums[i - k]);
        }
        return false;
    }
```



---

#### [55. Jump Game](https://leetcode.com/problems/jump-game/)

```java
public boolean canJump(int[] nums) {
        int index = 0;
        int max = 0;
        int target = nums.length - 1;
        if (target == 0) return true;
        while (index <= max) {
            max = Math.max(nums[index] + index, max);
            index++;
            if (max >= target) return true;

        }
        return false;
    }
```



---

#### [45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)

```java
public int jump(int[] nums) { //greedy
        int n = nums.length;
        int max = nums[0];
        int step = n == 1 ? 0 : 1;
        int start = 0;
        while (max < n - 1) {
            int curMax = max;
            while (start <= curMax) {
                if (start + nums[start] > max) max = start + nums[start];
                start++;
            }
            start = curMax + 1;
            step++;
        }

        return step;
    }
```



---

#### [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

```java
public int maxProfit(int[] prices) {
        int profit = 0;
        int buy = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < prices[buy]) {
                buy = i;
            } else {
                int tmp = prices[i] - prices[buy];
                if (tmp > profit)
                    profit = tmp;
            }

        }
        return profit;
    }
```



---

#### [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)

```java
public int maxProfit(int[] prices) {
        int hold = Integer.MIN_VALUE;
        int sold = 0;
        for (int price : prices) {
            int preHold = hold;
            int preSold = sold;
            hold = Math.max(preHold, preSold - price);
            sold = Math.max(preSold, preHold + price);
        }
        return sold;
    }
```



---

#### [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)

```java
public int maxProfit(int[] prices) {
        if (prices.length < 2) return 0;
        int[][] dp = new int[3][prices.length];
        for (int k = 1; k <= 2; k++) {
            int min = prices[0];
            for (int i = 1; i < prices.length; i++) {
                min = Math.min(prices[i] - dp[k - 1][i - 1], min);
                dp[k][i] = Math.max(dp[k][i - 1], prices[i] - min);
            }
        }
        return dp[2][prices.length - 1];
    }
```



---

#### [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)

```java
public int maxProfit(int k, int[] prices) {//memory limit exceed
        int len = prices.length;
        if (len < 2) return 0;
        if (k >= len / 2) return quickSolve(prices);
        int[][] dp = new int[k + 1][len];
        for (int t = 1; t <= k; t++) {
            int min = prices[0];
            for (int i = 1; i < len; i++) {
                min = Math.min(prices[i] - dp[t - 1][i - 1], min);
                dp[t][i] = Math.max(dp[t][i - 1], prices[i] - min);
            }
        }
        return dp[k][len - 1];
    }

    private int quickSolve(int[] prices) {
        int len = prices.length, profit = 0;
        for (int i = 1; i < len; i++)
            // as long as there is a price gap, we gain a profit.
            if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];
        return profit;
    }
```



---

#### [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

```java
public int maxProfit(int[] prices) {
        int[] states = {Integer.MIN_VALUE, 0, 0};
        for (int i = 0; i < prices.length; i++) {
            int preHold = states[0];
            int preSold = states[1];
            int preRest = states[2];
            states[0] = Math.max(preHold, preRest - prices[i]);//hold update
            states[1] = preHold + prices[i];//sold update
            states[2] = Math.max(preRest, preSold);//rest update
        }

        return Math.max(states[1], states[2]);
    }
```



---

#### [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)

```java
 public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int max = 0;
        while (left < right) {
            max = Math.max(max, (right - left) * Math.min(height[left], height[right]));
            if (height[left] < height[right])
                left++;
            else
                right--;
        }
        return max;
    }
```



---

#### [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)

```java
public int trap(int[] height) {
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        int max = 0;
        while (left <= right) {
            leftMax = Math.max(height[left], leftMax);
            rightMax = Math.max(height[right], rightMax);
            if (leftMax < rightMax) {
                max += leftMax - height[left];
                left++;
            } else {
                max += rightMax - height[right];
                right--;
            }
        }
        return max;
    }
```



---

#### [334. Increasing Triplet Subsequence](https://leetcode.com/problems/increasing-triplet-subsequence/)

```java
public boolean increasingTriplet(int[] nums) {
        int min = Integer.MAX_VALUE, secondMin = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] < min) min = nums[i];
            else if (nums[i] > min && nums[i] < secondMin) secondMin = nums[i];
            else if (nums[i] > secondMin) return true;
        }
        return false;
    }
```



---

#### [128. Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/)

```java
public int longestConsecutive(int[] nums) {
        int max = 0;
        HashSet<Integer> set = new HashSet<>();
        for (int i : nums) set.add(i);
        for (int num : nums) {
            int count = 0;
            int val = num;
            while (set.remove(val++)) count++;
            val = num;
            while (set.remove(--val)) count++;
            max = Math.max(max, count);
        }
        return max;
    }
```



---

#### [164. Maximum Gap](https://leetcode.com/problems/maximum-gap/)

```java
private class Bucket {
        boolean used = false;
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
    }

    public int maximumGap(int[] nums) {
        if (nums == null || nums.length < 2) return 0;
        int n = nums.length;
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;

        for (int num : nums) {
            min = Math.min(min, num);
            max = Math.max(max, num);
        }

        int b = Math.max(1, (max - min) / (n - 1));
        int k = (max - min) / b + 1;
        Bucket[] buckets = new Bucket[k];

        for (int num : nums) {
            int index = (num - min) / b;
            if (buckets[index] == null) buckets[index] = new Bucket();
            buckets[index].used = true;

            buckets[index].min = Math.min(buckets[index].min, num);
            buckets[index].max = Math.max(buckets[index].max, num);
        }

        int preBucketMax = min, maxGap = 0;
        for (Bucket bucket : buckets) {
            if (bucket == null || !bucket.used) continue;
            maxGap = Math.max(maxGap, bucket.min - preBucketMax);

            preBucketMax = bucket.max;
        }

        return maxGap;
    }
```





---

#### [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)

```java
public int findDuplicate(int[] nums) {//某个范围内数字的个数入手,二分查找
        int start = 1;
        int end = nums.length - 1;
        while (start <= end) {
            int middle = (end + start) >> 1;
            int count = countRange(nums, start, middle);
            if (end == start) {
                if (count > 1)
                    return start;
                else
                    break;
            }
            if (count > (middle - start) + 1)
                end = middle;
            else
                start = middle + 1;
        }
        return 0;
    }

    private int countRange(int[] nums, int start, int end) {
        if (nums == null || nums.length == 0)
            return 0;
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] >= start && nums[i] <= end)
                count++;
        }
        return count;
    }
```



---

#### [135. Candy](https://leetcode.com/problems/candy/)

```java
public int candy(int[] ratings) {
        int len = ratings.length;
        int[] left2Right = new int[len];
        int[] right2Left = new int[len];
        Arrays.fill(left2Right, 1);
        Arrays.fill(right2Left, 1);

        for (int i = 1; i < len; i++) {
            if (ratings[i] > ratings[i - 1])
                left2Right[i] = left2Right[i - 1] + 1;
        }

        for (int i = len - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1])
                right2Left[i] = right2Left[i + 1] + 1;
        }

        int max = 0;
        for (int i = 0; i < len; i++) {
            max += Math.max(left2Right[i], right2Left[i]);
        }

        return max;
    }
```





---

#### [330. Patching Array](https://leetcode.com/problems/patching-array/)

```java
public int minPatches(int[] nums, int n) {
        int i = 0, count = 0;
        long cur = 0;
        while (cur < n) {
            if (i < nums.length && nums[i] <= cur + 1) {
                cur += nums[i++];
            } else {
                cur += cur + 1;
                count++;
            }
        }
        return count;
    }
```



------

#### [4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

```java
public double findMedianSortedArrays(int[] A, int[] B) {

        int m = A.length;
        int n = B.length;
        if (m > n) { // to ensure m<=n
            int[] temp = A;
            A = B;
            B = temp;
            int tmp = m;
            m = n;
            n = tmp;
        }
        int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2;
        while (iMin <= iMax) {
            int i = (iMin + iMax) / 2;
            int j = halfLen - i;
            if (i < iMax && B[j - 1] > A[i]) {
                iMin = i + 1; // i is too small
            } else if (i > iMin && A[i - 1] > B[j]) {
                iMax = i - 1; // i is too big
            } else { // i is perfect
                int maxLeft = 0;
                if (i == 0) {
                    maxLeft = B[j - 1];
                } else if (j == 0) {
                    maxLeft = A[i - 1];
                } else {
                    maxLeft = Math.max(A[i - 1], B[j - 1]);
                }
                if ((m + n) % 2 == 1) {
                    return maxLeft;
                }

                /**
                 * max(A[i−1],B[j−1]),  when m + nm+n is odd

                 \frac{\max(\text{A}[i-1], \text{B}[j-1]) + \min(\text{A}[i], \text{B}[j])}{2}, \
                 2
                 
                 max(A[i−1],B[j−1])+min(A[i],B[j])
                  ,  when m + nm+n is even
                 */

                int minRight = 0;
                if (i == m) {
                    minRight = B[j];
                } else if (j == n) {
                    minRight = A[i];
                } else {
                    minRight = Math.min(B[j], A[i]);
                }

                return (maxLeft + minRight) / 2.0;
            }
        }

        return 0.0;
    }
```



------

####  [321. Create Maximum Number](https://leetcode.com/problems/create-maximum-number/)

```java
public int[] maxNumber(int[] nums1, int[] nums2, int k) {
        int n = nums1.length;
        int m = nums2.length;
        int[] ans = new int[k];
        for (int i = Math.max(0, k - m); i <= k && i <= n; ++i) {
            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);
            if (greater(candidate, 0, ans, 0)) ans = candidate;
        }
        return ans;
    }

    private int[] merge(int[] nums1, int[] nums2, int k) {
        int[] ans = new int[k];
        for (int i = 0, j = 0, r = 0; r < k; ++r)
            ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];
        return ans;
    }

    public boolean greater(int[] nums1, int i, int[] nums2, int j) {
        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {
            i++;
            j++;
        }
        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);
    }

    public int[] maxArray(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[k];
        for (int i = 0, j = 0; i < n; ++i) {
            while (n - i + j > k && j > 0 && ans[j - 1] < nums[i]) j--;
            if (j < k) ans[j++] = nums[i];
        }
        return ans;
    }
```



---

#### [327. Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/)

>Prefix sum + MergeSort

```java
public int countRangeSum(int[] nums, int lower, int upper) {
        int n = nums.length;
        long[] sums = new long[n + 1];
        for (int i = 0; i < n; i++) {
            sums[i + 1] = sums[i] + nums[i];
        }
        return countWithMergeSort(sums, 0, n + 1, lower, upper);
    }

    private int countWithMergeSort(long[] sums, int start, int end, int lower, int upper) {
        if (end - start <= 1) return 0;
        int mid = (start + end) >> 1;
        int count = countWithMergeSort(sums, start, mid, lower, upper) + countWithMergeSort(sums, mid, end, lower, upper);
        int j = mid, k = mid, t = mid;
        long[] cache = new long[end - start];
        for (int i = start, r = 0; i < mid; i++, r++) {
            while (k < end && sums[k] - sums[i] < lower) k++; //the first index satisfy sums[k] - sums[i] >= lower.
            while (j < end && sums[j] - sums[i] <= upper) j++;//the first index satisfy sums[j] - sums[i] > upper
            while (t < end && sums[t] < sums[i]) cache[r++] = sums[t++]; //merge sort
            cache[r] = sums[i];
            count += j - k;
        }
        System.arraycopy(cache, 0, sums, start, t - start);
        return count;
    }
```



---









---



### Dynamic Programming

---

#### [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)

```java
public int climbStairs(int n) {
        int[] tmp = new int[n];
        if (n == 1)
            tmp[0] = 1;
        if (n == 2)
            tmp[1] = 2;
        if (n >= 3) {
            tmp[0] = 1;
            tmp[1] = 2;
            for (int i = 3; i <= n; i++) {
                tmp[i - 1] = tmp[i - 2] + tmp[i - 3];
            }
        }

        return tmp[n - 1];
    }
```



---

#### [62. Unique Paths](https://leetcode.com/problems/unique-paths/)

```java
public int uniquePaths(int m, int n) {
        int[][] ways = new int[n][m];
        for (int i = 0; i < m; i++) ways[0][i] = 1;
        for (int j = 0; j < n; j++) ways[j][0] = 1;
        for (int i = 1; i < n; i++)
            for (int j = 1; j < m; j++) {
                ways[i][j] = ways[i - 1][j] + ways[i][j - 1];
            }
        return ways[n - 1][m - 1];
    }
```



---

#### [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)

```java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int rowLength = obstacleGrid.length;
        int columnLength = obstacleGrid[0].length;
        int[][] ways = new int[rowLength][columnLength];
        if (obstacleGrid[0][0] == 1) return 0;
        ways[0][0] = 1;
        for (int i = 1; i < columnLength; i++) {
            if (obstacleGrid[0][i] == 1) ways[0][i] = 0;
            else ways[0][i] = ways[0][i - 1];
        }
        for (int i = 1; i < rowLength; i++) {
            if (obstacleGrid[i][0] == 1) ways[i][0] = 0;
            else ways[i][0] = ways[i - 1][0];
        }
        for (int i = 1; i < rowLength; i++)
            for (int j = 1; j < columnLength; j++) {
                if (obstacleGrid[i][j] == 1)
                    ways[i][j] = 0;
                else
                    ways[i][j] = ways[i - 1][j] + ways[i][j - 1];
            }

        return ways[rowLength - 1][columnLength - 1];
    }
```



---

#### [120. Triangle](https://leetcode.com/problems/triangle/)

```java
public int minimumTotal(List<List<Integer>> triangle) {
        for (int i = 1; i < triangle.size(); i++) {
            List<Integer> pre = triangle.get(i - 1);
            List<Integer> cur = triangle.get(i);
            for (int j = 0; j < cur.size(); j++) {
                int tmp;
                if (j == 0) {
                    tmp = pre.get(0) + cur.get(j);
                } else if (j == cur.size() - 1) {
                    tmp = pre.get(pre.size() - 1) + cur.get(j);
                } else {
                    tmp = Math.min(pre.get(j - 1), pre.get(j)) + cur.get(j);
                }
                cur.set(j, tmp);
            }
        }
        int res = Integer.MAX_VALUE;
        for (Integer i : triangle.get(triangle.size() - 1)) {
            if (i < res) res = i;
        }
        return res;
    }
```



---

#### [279. Perfect Squares](https://leetcode.com/problems/perfect-squares/)

```java
public int numSquares(int n) { //DP o(n^2)
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j * j <= i; j++) {
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }
```



---

#### [139. Word Break](https://leetcode.com/problems/word-break/)

```java
public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length()];
        dp[0] = wordDict.contains(s.substring(0, 1));
        for (int i = 1; i < s.length(); i++) {
            if (wordDict.contains(s.substring(0, i + 1))) {
                dp[i] = true;
                continue;
            }
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDict.contains(s.substring(j + 1, i + 1))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length() - 1];
    }
```



---

#### [375. Guess Number Higher or Lower II](https://leetcode.com/problems/guess-number-higher-or-lower-ii/)

```java
public int getMoneyAmount(int n) {
        int[][] dp = new int[n + 1][n + 1];
        for (int d = 1; d < n; d++) {
            for (int i = 1; i <= n - d; i++) {
                int min = Integer.MAX_VALUE;
                int k;
                for (k = i + 1; k < i + d; k++) {
                    min = Math.min(min, k + Math.max(dp[i][k - 1], dp[k + 1][i + d]));
                }
                if (k == i + 1) {
                    dp[i][i + d] = i;
                } else
                    dp[i][i + d] = min;
            }
        }
        return dp[1][n];
    }
```



---

#### [312. Burst Balloons](https://leetcode.com/problems/burst-balloons/)

```java
public int maxCoins(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        int[][] coins = new int[nums.length][nums.length];
        for (int len = 1; len <= nums.length; len++
            for (int start = 0; start <= nums.length - len; start++) {
                int end = start + len - 1;
                for (int j = start; j <= end; j++) {
                    int leftVal = start == 0 ? 1 : nums[start - 1];
                    int rightVal = end == nums.length - 1 ? 1 : nums[end + 1];
                    int left = j == start ? 0 : coins[start][j - 1];
                    int right = j == end ? 0 : coins[j + 1][end];
                    coins[start][end] = Math.max(coins[start][end],
                            right + left + leftVal * rightVal * nums[j]);
                }
            }
        return coins[0][nums.length - 1];
    }
```



---

#### [322. Coin Change](https://leetcode.com/problems/coin-change/)

```java
public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        dp[0] = 0;
        Arrays.sort(coins);
        for (int i = 1; i <= amount; i++) {
            int min = Integer.MAX_VALUE;
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i && dp[i - coins[j]] != -1)//之前能满足
                    min = Math.min(dp[i - coins[j]] + 1, min);
            }
            dp[i] = min == Integer.MAX_VALUE ? -1 : min;
        }
        return dp[amount];
    }
```



---

#### [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)

```java
public int minPathSum(int[][] grid) {
        int rowLength = grid.length;
        int columnLength = grid[0].length;
        int[][] minsum = new int[rowLength][columnLength];
        minsum[0][0] = grid[0][0];
        for (int i = 1; i < columnLength; i++)
            minsum[0][i] = minsum[0][i - 1] + grid[0][i];
        for (int i = 1; i < rowLength; i++)
            minsum[i][0] = minsum[i - 1][0] + grid[i][0];
        for (int i = 1; i < rowLength; i++)
            for (int j = 1; j < columnLength; j++) {
                minsum[i][j] = Math.min(minsum[i][j - 1], minsum[i - 1][j]) + grid[i][j];
            }
        return minsum[rowLength - 1][columnLength - 1];
    }
```



---

#### [72. Edit Distance](https://leetcode.com/problems/edit-distance/)

```java
public int minDistance(String word1, String word2) {
        int n = word1.length();
        int m = word2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i <= n; i++) dp[0][i] = i;
        for (int j = 0; j <= m; j++) dp[j][0] = j;
        for (int i = 1; i <= m; i++)
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(j - 1) == word2.charAt(i - 1))
                    dp[i][j] = dp[i - 1][j - 1];
                else
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
            }
        return dp[m][n];
    }
```



---

#### [97. Interleaving String](https://leetcode.com/problems/interleaving-string/)

```java
public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];
        dp[0][0] = true;

        for (int i = 1; i < s2.length() + 1; i++) {
            dp[0][i] = dp[0][i - 1] && s2.charAt(i - 1) == s3.charAt(i - 1);
        }
        for (int i = 1; i < s1.length() + 1; i++) {
            dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);
        }

        for (int i = 1; i < s1.length() + 1; i++) {
            for (int j = 1; j < s2.length() + 1; j++) {
                dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) | (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));
            }
        }
        return dp[s1.length()][s2.length()];
    }
```



---

#### [174. Dungeon Game](https://leetcode.com/problems/dungeon-game/)

```java
public int calculateMinimumHP(int[][] dungeon) {
        int row = dungeon.length;
        int col = dungeon[0].length;
        int[][] dp = new int[row][col];

        dp[row - 1][col - 1] = dungeon[row - 1][col - 1] >= 0 ? 1 : Math.abs(dungeon[row - 1][col - 1]) + 1;
        for (int i = col - 2; i >= 0; i--) {
            int tmp = dp[row - 1][i + 1] - dungeon[row - 1][i];
            dp[row - 1][i] = tmp > 0 ? tmp : 1;
        }
        for (int i = row - 2; i >= 0; i--) {
            int tmp = dp[i + 1][col - 1] - dungeon[i][col - 1];
            dp[i][col - 1] = tmp > 0 ? tmp : 1;
        }

        for (int i = row - 2; i >= 0; i--) {
            for (int j = col - 2; j >= 0; j--) {
                int right = (dp[i][j + 1] - dungeon[i][j]) > 0 ? dp[i][j + 1] - dungeon[i][j] : 1;
                int down = (dp[i + 1][j] - dungeon[i][j]) > 0 ? dp[i + 1][j] - dungeon[i][j] : 1;
                dp[i][j] = Math.min(right, down);
            }
        }

        return dp[0][0];
    }
```



---

#### [221. Maximal Square](https://leetcode.com/problems/maximal-square/)

```java
public int maximalSquare(char[][] matrix) {
        int row = matrix.length;
        int col = matrix.length > 0 ? matrix[0].length : 0;
        int dp[][] = new int[row][col];
        int maxLen = 0;
        for (int i = 0; i < col; i++)
            if (matrix[0][i] == '1') {
                dp[0][i] = 1;
                maxLen = 1;
            }
        for (int i = 0; i < row; i++)
            if (matrix[i][0] == '1') {
                dp[i][0] = 1;
                maxLen = 1;
            }
        for (int i = 1; i < row; i++)
            for (int j = 1; j < col; j++) {
                if (matrix[i][j] == '1') {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    if (dp[i][j] > maxLen) maxLen = dp[i][j];
                }
            }
        return maxLen * maxLen;
    }
```



---

#### [85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/)

```java
public int maximalRectangle(char[][] matrix) {
        int maxArea = 0;
        int m = matrix.length;
        if(m==0) return 0;
        int n = matrix[0].length;
        int[] heights = new int[n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') heights[j] += 1;
                else heights[j] = 0;
                
            }
            maxArea = Math.max(maxArea, largestRectangleArea(heights));
        }
        return maxArea;
    }

    private int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        int maxAra = 0;
        int h;
        for (int i = 0; i <= heights.length; i++) {
            h = i == heights.length ? 0 : heights[i];
            if (stack.isEmpty() || h > heights[stack.peek()])
                stack.push(i);
            else {
                while (!stack.isEmpty() && heights[stack.peek()] >= h) {
                    int height = heights[stack.peek()];
                    stack.pop();
                    int w = stack.empty() ? i : i - stack.peek() - 1;
                    maxAra = Math.max(maxAra, height * w);
                }
                stack.push(i);
            }
        }
        return maxAra;
    }
```



---

#### [363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/)

```java
public int maxSumSubmatrix(int[][] matrix, int k) {
        int row = matrix.length;
        int col = matrix[0].length;
        int maxSum = Integer.MIN_VALUE;
        for (int l = 0; l < col; l++) {
            int[] sum = new int[row];
            for (int r = l; r < col; r++) {
                for (int i = 0; i < row; i++) {
                    sum[i] += matrix[i][r];
                }
                int curSum = maxSumSubArray(sum, k);
                if (curSum > maxSum) maxSum = curSum;
            }
        }
        return maxSum;
    }

    private int maxSumSubArray(int[] a, int k) {

        int max = Integer.MIN_VALUE;
        int sumj = 0;
        TreeSet<Integer> ts = new TreeSet<>();
        ts.add(0);

        for (int i = 0; i < a.length; i++) {
            sumj += a[i];
            Integer gap = ts.ceiling(sumj - k);
            if (gap != null) max = Math.max(max, sumj - gap);
            ts.add(sumj);
        }
        return max;
    }
```



---

#### [198. House Robber](https://leetcode.com/problems/house-robber/)

```java
public int rob(int[] nums) {
        if (nums.length == 0)
            return 0;
        int[] max = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            if (i == 0)
                max[i] = nums[i];
            else if (i == 1)
                max[i] = Math.max(nums[0], nums[1]);
            else
                max[i] = Math.max(max[i - 1], max[i - 2] + nums[i]);
        }
        return max[nums.length - 1];
    }
```



---

#### [213. House Robber II](https://leetcode.com/problems/house-robber-ii/)

```java
public int rob(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        if (nums.length == 1) return nums[0];
        if (nums.length == 2) return Math.max(nums[0], nums[1]);
        int x = rob(nums, 0, nums.length - 2);
        int y = rob(nums, 1, nums.length - 1);
        return Math.max(x, y);
    }

    private int rob(int[] nums, int start, int end) {
        if (end - start == 0) return nums[start];
        if (end - start == 1) return Math.max(nums[start], nums[end]);
        int pre2 = nums[start];
        int pre1 = Math.max(nums[start], nums[start + 1]);
        int cur = 0;
        for (int i = start + 2; i <= end; i++) {
            cur = Math.max(pre1, pre2 + nums[i]);
            pre2 = pre1;
            pre1 = cur;
        }
        return cur;
    }
```



---

#### [91. Decode Ways](https://leetcode.com/problems/decode-ways/)

```java
public int numDecodings(String s) {
        if (s == null || s.length() == 0) return 0;
        int n = s.length();
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = s.charAt(0) == '0' ? 0 : 1;
        for (int i = 2; i <= n; i++) {
            int one = Integer.valueOf(s.substring(i - 1, i));
            if (one != 0) dp[i] += dp[i - 1];
            if (s.charAt(i - 2) == '0') continue;
            int two = Integer.valueOf(s.substring(i - 2, i));
            if (two <= 26) dp[i] += dp[i - 2];
        }
        return dp[n];
    }
```



---

#### [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)

```java
public boolean isMatch(String s, String p) {
        if (s == null || p == null) return false;
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        dp[0][0] = true;
        for (int i = 1; i <= p.length(); i++) {
            if (p.charAt(i - 1) == '*' && dp[0][i - 2]) {
                dp[0][i] = true;
            }
        }

        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= p.length(); j++) {
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                if (p.charAt(j - 1) == '*') {
                    if (p.charAt(j - 2) != s.charAt(i - 1) && p.charAt(j - 2) != '.') dp[i][j] = dp[i][j - 2];
                    else {
                        dp[i][j] = (dp[i - 1][j] | dp[i][j - 1] | dp[i][j - 2]);

                    }
                }
            }
        }
        return dp[s.length()][p.length()];
    }
```





---

#### [44. Wildcard Matching](https://leetcode.com/problems/wildcard-matching/)

```java
public boolean isMatch(String s, String p) {
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        dp[0][0] = true;
        for (int i = 0; i < p.length(); i++) {
            if (p.charAt(i) == '*') dp[0][i + 1] = dp[0][i];
        }
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= p.length(); j++) {
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '?') {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                if (p.charAt(j - 1) == '*') {
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
                }
            }
        }

        return dp[s.length()][p.length()];
    }
```





---

####
